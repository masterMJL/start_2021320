**世上无难事，只怕有心人！！！**

# 第九部分：集合框架源码解读

## Hash(散列函数)Map集合框架源码解读



### 基础知识

#### ==与equals之间区别与底层实现

#### 为什么重写equals还要重写hashcode

#### 二进制与十进制转换/^(异或运算)/>>>(无符号右移)/&（与运算）



### 底层实现方式



#### JDK1.7

##### 数组+链表

##### 头插入方式(并发扩容死循环问题)

##### 代码写法简单



#### JDK1.8

##### 数组+链表+红黑树

##### 尾插入方式

##### 代码写法高大上



##### 红黑树转换

###### （数组容量>=64&链表长度大于8）

###### 红黑树节点个数<6转换链表



#### Hash函数计算

##### (h = key.hashCode()) ^ (h >>> 16)

##### i = (n - 1) & hash



#### 时间复杂度



##### Key没有产生冲突

###### 时间复杂度则为O(1)



##### Key产生冲突

###### 链表存放则为O(N)

###### 红黑树存放则为O（LogN）



##### hashcode碰撞问题

###### hashcode值相同，内容值不等



#### 特点

##### key为null存放数组0位置

##### 采用单向链表实现

##### 无序散列存放



### 性能优化

#### HashMap如何避免内存泄露问题

#### HashMap如何降低Hash冲突概率

#### HashMap如何合理指定集合初始值大小



### HashMap常见面试题

#### 为什么重写Equals还要重写HashCode方法

#### HashMap如何避免内存泄漏问题

#### HashMap1.7底层是如何实现的

#### HashMapKey为null存放在什么位置

#### HashMap1.7底层是如何实现的

#### HashMapKey为null存放在什么位置

#### HashMap如何解决Hash冲突问题

#### HashMap如何实现数组扩容问题

#### HashMap底层采用单链表还是双链表

#### HashMap根据key查询的时间复杂度

#### HashMap1.7与1.8有那些区别？

#### HashMap1.8如何避免多线程扩容死循环问题

#### 为什么HashMap1.8需要引入红黑树

#### 为什么加载因子是0.75而不是1

#### HashMap底层如何降低Hash冲突概率

#### HashMap如何存放1万条key效率最高

#### HashMap高低位与取模运算有那些好处

#### 为什么不直接将key作为哈希值而是与高16位做异或运算？

#### HashMap中hash函数是怎么实现的？

#### HashMap底层是有序存放的吗？

#### LinkedHashMap 和 TreeMap底层如何实现有序的

#### 如何在高并发的情况下使用HashMap

#### ConcurrentHashMap底层实现的原理



## ConcurrentHashMap集合框架源码解读



### 基础知识

#### synchronized与lock锁

#### 如何理解分段锁概念

#### CAS算法和volatile



### 底层实现



#### JDK1.7



##### 数据结构

###### 数组+Segments分段锁+HashEntry链表实现



##### 锁的实现

###### Lock锁+CAS乐观锁+UNSAFE类



##### 扩容实现

###### 支持多个Segment同时扩容



#### Jdk1.8



##### 数据结构

###### 直接使用Node数组来保存数据

###### 数组+链表+红黑树



##### 锁的实现

###### 取消segment分段设计

###### index没有发生冲突使用cas锁

###### index发生冲突使用synchronized



##### 扩容实现

###### 支持并发扩容

#### 特点：支持多线程效率高、默认分成16个Segments



### 特点

#### ConcurrentHashMap 不支持key为null



## List集合源码分析



### Arraylist底层实现



#### 数据结构

##### 数组



#### 时间复杂度

##### 下标查询时间复杂度o(1)



#### 扩容

##### 扩容是原来1.5倍

##### 线程不安全



#### 优缺点

##### 增删效率低需要扩容，查询效率比较高 



### Vector底层实现



#### 数据结构

##### 数组



#### 时间复杂度

##### 下标查询时间复杂度o(1)



#### 扩容

##### 扩容是原来2倍

#### 线程安全



### LinkedList底层实现

#### 基于链表数据结构，下标查询时间复杂度()



#### 数据结构

##### 链表



#### 时间复杂度

##### 下标查询时间复杂度log2(n) 二分查找

#### 线程不安全



#### 优缺点

##### 增删改效率高，查询效率比较低