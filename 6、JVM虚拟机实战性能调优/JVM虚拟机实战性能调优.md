**世上无难事，只怕有心人！！！**

# 第六部分：JVM虚拟机实战性能调优原生

## 编程语言发展历程

### 汇编语言/机器语言

### C/C++语言

### java/php/易语言/ython



## JVM类加载器ClassLoader

### 从HotSpot虚拟机（C++）源码分析类加载器实现原理

### 启动类/扩展/应用类加载器深度源码解析

### 类加载器双亲委派原则及如何打破

### Java SPIService Provider Interface 原理

### Tomcat/Jetty类加载器实现原理



### 如何自定义一个类加载器加载字节码与手写热部署插件

#### 本地磁盘

#### 网络获取

#### 数据库

#### 动态代理生成

#### war/jar



## JVM内存结构原理分析

### 堆/栈/元空间/字符串常量池/程序计数器等

### 线程栈及栈帧内部结构分析

#### 局部变量表

#### 操作数栈

#### 动态连接

#### 方法出口

### 本地方法栈(JNI调用C代码)技术



### 字符串常量池

#### 静态常量池

#### 运行常量池

#### 字符串常量池

#### 常见的String面试题

#### 常量池到不同JDK版本存放区域



## JVM对象内存布局



### 对象的布局的

#### 对象头

#### 实例数据

#### 对齐填充

#### new一个对象到底占多少字节



### 对象的访问定位

#### 句柄方式

#### 直接指针方式



## JVM垃圾回收算法



### 垃圾收集算法



#### 标记清除算法

优点：效率高/不移动内存地址

缺点：容易产生碎片化



#### 标记整理算法

优点：避免碎片化问题

缺点：移动内存地址，效率低



#### 标记复制算法

优点：避免碎片化问题

缺点：移动内存地址，效率高



#### 分代算法原理

新生代

老年代



### 垃圾复制算法

#### 垃圾回收机制三色标记算法原理



#### 三色标记算法产生的多标/漏标问题

##### 浮动垃圾

##### 漏标问题



#### 对象漏标解决方案

##### 基于增量更新方式(CMS)

##### 基于原始快照方式satb(G1)

#### Region记忆集(Remember Set)与卡表(Cardtable)详解



### stop the world

#### 为什么会发生stop the world问题

#### 如何避免stop the world问题



### JDK1.0-14收集器



#### 串行

##### Serial垃圾收集器详解



#### 并行

##### ParNew垃圾收集器详解

##### Parallel垃圾收集器详解



#### 并发



##### CMS垃圾收集器原理（重点）



###### 实现原理

初始标记

并发标记

重新标记

并发清除



###### CMS收集器有那些缺点

标记清除算法引发碎片化问题

备选方案SerialOld效率低

基于增量更新方式解决漏标问题



##### G1收集器原理（重点）



###### 实现原理

n多个不同region

Region记忆集(Remember Set)

卡表(Cardtable)详解

基于原始快照(satb)解决楼标问题

##### ZGC垃圾收集器详解

##### Epsilon与Shenandoah垃圾收集器详解



## JVM调优工具详解

### JDK自带Jstat、Jinfo、Jmap、Jhat及Jstack调优命令详解

### Jvisualvm、Jconsole调优工具详解

### 阿里工具arthas使用详解



## GC日志分析工具

### 如何阅读GC日志详细信息

### GCEasy日志分析工具使用

### GCViewer日志分析工具使用



## JVM参数调优实战

### 亿级流量项目堆内存年轻代与老年代垃圾回收参数设置与调优

### 线上生产环境OMM内存溢出监控工具及定位解决方案

### 线上生产环境如何减少严重Full GC导致系统直接卡死的优化实战

### 高并发系统，线上生产环境如何避免频繁GC操作

### 高并发系统，如何优化G1/CMS收集器

### 日均百万PV服务如何设置JVM堆初始内存大小