**世上无难事，只怕有心人！！！**

# 第七部分：并发编程实战

## 操作系统基础

### 用户态与内核态切换过程

### linux进程模型管理

### linux进程间通信原理

### linux网络通讯原理



## 多线程基础



### 多线程快速入门

#### 什么是进程/线程

##### 进程：

$$
进程实际就是程序运行的实体，类似可执行的.exe文件或.jar。一个进程中可以有多个线程执行。
$$

##### 线程：

```
线程是计算机的最小执行单位，一个线程都是一个单一顺序的控制流
```



#### 多线程应用场景

异步调用：用过多线程使某个方法可以异步执行，从而不影响主业务的执行。

多文件操作：多文件下载，FTP等操作，文件解码。都可使用多线程去调用执行。

任务调度：定时任务，同一时间可以操作多个任务调度。

高并发操作：对于一些并发量比较高的业务。



#### 多线程与单线程之间的区别

#### 如何理解多线程cpu切换概念

```
因为一些原因导致cpu不再执行当前线程，转为执行另一个线程代码

线程cpu时间片用完
垃圾回收
有更高优先级的线程执行
线程自己调用了sleep、yield、wait、join、synchronized、lock等方法

发生Context Switch发生时，需要操作系统保存当前线程状态，用于恢复执行，java中由jvm的程序计数器来保存线程状态。
频繁的上下文切换是很耗资源的。
```



#### 多线程真的开的越多越好吗

#### 用户线程与守护线程的区别

#### 如何优雅的停止一个线程

#### 多线程五种状态分析

##### 创建

##### 就绪

##### 运行

##### 阻塞

##### 死亡



#### 创建多线程五种方式

##### 继承Thread类创建线程

```
Thread t1 = new Thread(){
	public void run(){
		//方法体
	}
}
t1.setName("线程名称");
t1.start();
```



##### 实现Runnable接口创建线程（推荐）

将线程和任务分离，Runnable为可运行的任务，Thread代表线程

```
Runnable r = () -> log.debug("running");
        new Thread(r, "t1").start();
```

Runnable更容易和线程池等高级API配合，让任务脱离了Thread继承体系，更灵活。



##### 使用Callable和Future创建线程

FutureTask通过接收Callable类型的参数（Callable源码如下），来处理带有返回结果的情况，FutureTask实现RunnableFuture。

![image-20210927234450226](image\image-20210927234450226.png)

![image-20210927234518930](image\image-20210927234518930.png)

```
FutureTask futureTask = new FutureTask(new Callable() {
            @Override
            public Object call() throws Exception {
                System.out.println("renwu");
                Thread.sleep(1000);
                return 110;
            }
        });
        new Thread(futureTask,"t3").start();
        System.out.println("zhuxiancheng");
        futureTask.get();// 获取结果
```

![image-20210927234115545](image\image-20210927234115545.png)

Future 就是对于具体的 Runnable 或者 Callable 任务的执行结果进行取消、查询是否完成、获取结果。

```
package java.util.concurrent;
public interface Future<V> {
取消任务执行，视具体情况而定，如果传为true并且任务正在运行，则会被取消，如果为false并且任务正在运行，则不会取消。如果该线程存在某些原因不可取消时将会返回false
    boolean cancel(boolean mayInterruptIfRunning);

判断当前task是否被取消。
    boolean isCancelled();

判断当前Future是否执行完成。
    boolean isDone();

用户返回计算结果，如果计算还没有完成，则在get的时候会进行阻塞，直到获取到结果为止
    V get() throws InterruptedException, ExecutionException;

如果在指定时间内没有完成计算，则会抛出TimeoutException
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```




##### 使用线程池例如用Executor框架

##### 使用@Async异步注解创建线程

#### 线程运行原理

```
线程使用栈内存，每个线程启动后，虚拟机会给其分配一块栈内存，栈内存又由多个栈帧组成，对应着当前正在执行的方法。同一个线程内活动的栈帧只能有一个。
```

![image-20210922203343695](image\image-20210922203343695.png)

### 多线程线程安全

#### 什么是线程安全问题

#### Synchronized解决线程安全问题

#### lock与Synchronized锁区别

#### Lock锁解决线程安全问题

#### 多线程死锁线程产生的原因

#### 多线程如何排查死锁的现象

#### lock读写锁的使用



### 多线程之间通讯

#### 生产者与消费者

#### wait和notify

#### join方法的原理

join()：等待线程运行结束

join(long n)：等待线程运行结束，最多等待n毫秒



## volatile关键字原理



### 关键字特性

#### 保证可见性

#### 禁止重排序

#### 不保证原子性



### java内存模型

#### CPU多核硬件架构剖析

#### jmm八大同步的规范



### Volatile缓存一致性协议

#### 总线锁

#### MESI协议



### 伪共享的问题

#### 缓存行基本的概念

#### 存行填充方案

### 重排序/内存屏障/双重检验锁为什么需要加上volatile

### synchronized 与volatile存在的区别

### 为什么Volatile不能保证原子性



## synchronized原理

### Synchronized内置锁实现原理

### 站在C++源码如何分析Synchronized原理

### 锁池/等待池/Monitor监视器锁/对象头原理

### Synchronized锁膨胀过程原理分析

### 偏向锁/轻量锁/自旋锁/重量锁

### 锁的粗化、与消除及性能优化



## 并发锁的分类

### 悲观锁

### 乐观锁

### 自旋锁

### 重入锁

### 公平锁

### 非公平锁



## aqs源码解读

### LockSupport源码解读

### AbstractQueuedSynchronizer源码解读

### ReentrantLock/ReentrantReadWriteLock、ReadWriteLock源码解读

### Semaphore/CountDownLatch/CyclicBarrie源码解读



## 并发atomic原子操作

### Atomic原子类

### CAS（乐观锁）原理

### Unsafe魔法类详解



## 阻塞队列BlockingQueue原理



### 阻塞队列分类

#### ArrayBlockingQueue 数组有界队列

#### ConcurrentLinkedQueue 链表有界队列

#### PriorityBlockingQueue 优先级排序无界队列

#### DelayQueue 延时无界队列



### 框架应用

#### 基于BlockingQueue手写线程池

#### 基于BlockingQueue手写消息中间件

#### 基于BlockingQueue手写日志框架



## Executor线程池详解及核心源码剖析

### 为什么要使用线程池

### 线程池核心原理分析

### 为什么阿里不建议使用Executors

### 线程池参数如何合理配置

### 线程池实现优缺点

### 如何基于ThreadPoolExecutor自定义线程池



## FutureTask源码解读

### 基于LockSupport实现FutureTask

### 基于Wait/Notify实现FutureTask



## ForkJoin源码解读

### 并发编程发展

### 工作窃取机制

### Fork Join原理



## Threadlocal源码解读

### 什么是Threadlocal

### Threadlocal应用场景

### Threadlocal与Synchronized区别

### 如何防御Threadlocal内存泄漏问题