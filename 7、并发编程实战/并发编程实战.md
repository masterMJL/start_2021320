世上无难事，只怕有心人！！！**

# 第七部分：并发编程实战

## 操作系统基础

### 用户态与内核态切换过程

- 用户态和内核态的区别

```
当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称该进程处于内核态，此时处理器处于特权级最高的（0级）内核代码。当进程处于内核状态时，执行内核代码会使用当前的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户态。即此时处理器在特权级最低的用户代码中运行。当正在执行用户程序突然中断时，此时用户程序也可以象征性的处于进程的内核态。因为中断处理程序将使用当前进程的内核态。
```

```
a. 系统调用

​    这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。

b. 异常

​    当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

c. 外围设备的中断

​    当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。
```



### linux进程模型管理

### linux进程间通信原理

### linux网络通讯原理



## 多线程基础



### 查看进程线程的方法

#### windowns

- 任务管理器
- tasklist 查看进程
- taskkill 杀死进程

#### linux

- ps -fe 查看所有进程
- ps -ft -p 查看某个进程的所有线程
- kill 杀死进程
- top 按大写H切换是否显示线程
- top -H -p 擦好看某个进程的所有线程

#### java

- jps 查看所有java进程
- jstack查看某个java进程所有线程状态
- jconsole 查看某个java进程中线程的运行情况



### 多线程快速入门

#### 什么是进程/线程

##### 进程：

$$
进程实际就是程序运行的实体，类似可执行的.exe文件或.jar。一个进程中可以有多个线程执行。
$$

##### 线程：

```
线程是计算机的最小执行单位，一个线程都是一个单一顺序的控制流
```



#### 多线程应用场景

```
异步调用：用过多线程使某个方法可以异步执行，从而不影响主业务的执行。

多文件操作：多文件下载，FTP等操作，文件解码。都可使用多线程去调用执行。

任务调度：定时任务，同一时间可以操作多个任务调度。

高并发操作：对于一些并发量比较高的业务
```

。



#### 多线程与单线程之间的区别

#### 如何理解多线程cpu切换概念

```
因为一些原因导致cpu不再执行当前线程，转为执行另一个线程代码

线程cpu时间片用完
垃圾回收
有更高优先级的线程执行
线程自己调用了sleep、yield、wait、join、synchronized、lock等方法

发生Context Switch发生时，需要操作系统保存当前线程状态，用于恢复执行，java中由jvm的程序计数器来保存线程状态。
频繁的上下文切换是很耗资源的。
```



#### 多线程真的开的越多越好吗

#### 用户线程与守护线程的区别

#### 如何优雅的停止一个线程

#### 多线程五种状态分析

- 操作系统层面：

![image-20211005114500504](image\image-20211005114500504.png)

##### 创建：

初始创建线程

##### 就绪：

等待cpu调度的线程

##### 运行：

被cpu调度执行的线程

##### 阻塞：

##### 死亡：

- javaApi

![image-20211005142221711](image\image-20211005142221711.png)

- NEW：新建状态
- RUNNABLE：涵盖运行，阻塞，可运行三种状态

- TERMINATED：终止状态
- BLOCKED：根据源码注释，由于调用wait、join及LockSupport.park方法，使线程处于等待状态
- WAITING：

![image-20211005163529149](image\image-20211005163529149.png)

- TIMED WAITING：

```
Thread state for a terminated thread. The thread has completed execution.--终止线程的线程状态。线程已完成执行。
```



#### 创建多线程五种方式

##### 继承Thread类创建线程

```
Thread t1 = new Thread(){
	public void run(){
		//方法体
	}
}
t1.setName("线程名称");
t1.start();
```



##### 实现Runnable接口创建线程（推荐）

将线程和任务分离，Runnable为可运行的任务，Thread代表线程

```
Runnable r = () -> log.debug("running");
        new Thread(r, "t1").start();
```

Runnable更容易和线程池等高级API配合，让任务脱离了Thread继承体系，更灵活。



##### 使用Callable和Future创建线程

FutureTask通过接收Callable类型的参数（Callable源码如下），来处理带有返回结果的情况，FutureTask实现RunnableFuture。

![image-20210927234450226](image\image-20210927234450226.png)

![image-20210927234518930](image\image-20210927234518930.png)

```
FutureTask futureTask = new FutureTask(new Callable() {
            @Override
            public Object call() throws Exception {
                System.out.println("renwu");
                Thread.sleep(1000);
                return 110;
            }
        });
        new Thread(futureTask,"t3").start();
        System.out.println("zhuxiancheng");
        futureTask.get();// 获取结果
```

![image-20210927234115545](image\image-20210927234115545.png)

Future 就是对于具体的 Runnable 或者 Callable 任务的执行结果进行取消、查询是否完成、获取结果。

```
package java.util.concurrent;
public interface Future<V> {
取消任务执行，视具体情况而定，如果传为true并且任务正在运行，则会被取消，如果为false并且任务正在运行，则不会取消。如果该线程存在某些原因不可取消时将会返回false
    boolean cancel(boolean mayInterruptIfRunning);

判断当前task是否被取消。
    boolean isCancelled();

判断当前Future是否执行完成。
    boolean isDone();

用户返回计算结果，如果计算还没有完成，则在get的时候会进行阻塞，直到获取到结果为止
    V get() throws InterruptedException, ExecutionException;

如果在指定时间内没有完成计算，则会抛出TimeoutException
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```



##### 使用线程池例如用Executor框架

```
package com.current.demo;

import java.util.concurrent.*;

/**
 * @program: threadDemo
 * @description:
 * @author: mengjianglong@e6yun.com
 * @create: 2021-10-18 13:44
 **/

public class CreateThreadDemo {
    public static void main(String[] args) {
        /*1、提供线程池运行的基本参数*/
        ExecutorService service = Executors.newFixedThreadPool(10,Executors.defaultThreadFactory());
        ThreadPoolExecutor poolExecutor = (ThreadPoolExecutor) service;
        // 核心池大小
        //poolExecutor.setCorePoolSize(10);
        //最大线程数
        //poolExecutor.setMaximumPoolSize(9);
        //线程没有任务时最多保持多长时间后会终止
        //poolExecutor.setKeepAliveTime(2, TimeUnit.SECONDS);

        /*创建加入线程*/
        service.execute(new NumberThread());
        service.execute(new NumberThread1());

        /*停止线程*/
        service.shutdown();
    }
}

class NumberThread implements Runnable{

    public void run() {
        for(int i = 0;i <= 100;i++){
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ": " + i);
            }
        }
    }
}

class NumberThread1 implements Runnable{

    public void run() {
        for(int i = 0;i <= 100;i++){
            if(i % 2 != 0){
                System.out.println(Thread.currentThread().getName() + ": " + i);
            }
        }
    }
}

```



##### 使用@Async异步注解创建线程

```

```



#### 线程运行原理

```
线程使用栈内存，每个线程启动后，虚拟机会给其分配一块栈内存，栈内存中会根据方法执行的前后顺序创建每一个栈帧用于存储局部变量表，动态链接，操作数栈，方法出口等信息。每次会将执行的栈帧（方法）从栈顶弹出，执行完成后再将返回值交给下一个方法继续执行。
```

![image-20210922203343695](image\image-20210922203343695.png)



### 线程中常见的方法

```
sleep：
线程由runing-->TimedWaiting
其他线程可以使用interrupt方法打断正在睡眠的线程，这时sleep会抛出异常
睡眠结束后线程未必会立刻执行
建议用TimeUnit休眠   TimeUnit.SECOUND.sleep（1）
```

```
yield：
线程从Running-->Runable就绪状态
```

```
join、join(long n):
等待线程运行结束(等待n秒后没结果继续往后运行)
```

```
interrupt：
打断阻塞状态的线程
sleep、wait、join被打断后会抛出异常

打断执行中的线程
通过打断标记结束运行isInterrupt()
```

```
park线程：
/**
 * @author 25283
 * @version 1.0
 * @description: TODO park线程
 * @date 2021/10/5 11:23
 */
public class ParkThread {
    public static void main(String[] args) {
        Thread t1 = new Thread(()->{
            System.out.println("park....");
            LockSupport.park();
            System.out.println("unPark...");
            // 将打断状态置为
            Thread.currentThread().interrupted();
            LockSupport.park();
            System.out.println("unpark..");
        },"t1");
        t1.start();

        //打断park
        t1.interrupt();
    }
}
park线程是属于LockSupport工具类中的一个打断线程的方法，该方法收到isInterrupt的影响，如果为true会导致park打断失效。因此在使用时需要注意及时将当前线程的打断状态调整为false，及利用interrupted回归为false；
```



### 两阶段终止模式（设计模式）

在线程T1中如何优雅的终止线程T2

实际上就是利用interrupt去打断一个线程，打断完成后则利用isInterrupt去判断线程是否被打断，若被打断则正常结束当前线程也就是这里的正常跳出循环，结束该方法体的执行。一般情况下我们不可以直接使用java自带的stop去结束一个线程，而且jdk1.8已经不推荐使用，盲目使用stop去终止一个线程，有可能会导致该线程所占用的共享资源锁不被释放，从而造成程序的错误。而System.exit()会直接结束运行当前程序。

```
/**
 * @author 25283
 * @version 1.0
 * @description: 两阶段终止模式
 * @date 2021/10/5 10:54
 */
public class TwoStageTerminationMode {
    public static void main(String[] args) {
        TwoThread twoThread = new TwoThread();
        twoThread.start();

        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        twoThread.stop();
    }
}
class TwoThread{
    public Thread mode;

    public void start(){
        mode = new Thread(()->{
            while (true){
                Thread currentThread = Thread.currentThread();
                if (currentThread.isInterrupted()) {
                    System.out.println("我正常离职了");
          break;
                }

                try {
                    TimeUnit.SECONDS.sleep(1);
                    System.out.println("我在履职");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    currentThread.interrupt();
                }
            }
        });
        mode.start();
    }
    public void stop(){
        mode.interrupt();
    }
}
```



### 线程优先级

不是所有优先级高的线程会先执行，所有的调度都去决于CPU，在cpu比较繁忙的时候，优先级高的有可能先执行。



### 主线程和守护线程

- 守护线程：等其他非守护线程结束了，即使守护线程代码没执行完他也会停止运行。
- 应用：垃圾回收器就是一种守护线程，tomcat中的Acceptor和poller



### 多线程线程安全

#### 什么是线程安全问题

线程安全图解：

![img](https://img-blog.csdnimg.cn/20201219094936132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20201219095022810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

- 根本原因

```
共享资源操作，线程上线文操作导致一个线程指令没有完全的执行完毕就去执行另一个线程指令，导致共享资源拿到的结果不一致，失去原子性。
```

- java字节码

```
以count++和count--为例：
getstatic i // 获取静态变量i的值
iconst_1 // 准备常量1
iadd // 自增
putstatic i // 将修改后的值存入静态变量i
    
getstatic i // 获取静态变量i的值
iconst_1 // 准备常量1
isub // 自减
putstatic i // 将修改后的值存入静态变量i
```



#### 共享资源问题

##### 临界区

```
一段代码中如果对共享资源有读写操作，称这段代码块为临界区
```

##### 竞态条件

```
多个线程操作临界区，导致代码执行序列不同而导致结果无法预测，称为竞态条件
```



#### Synchronized解决线程安全问题

为避免临界区中的竞态条件发生

```
阻塞式解决方案：synchronized,Lock
非阻塞式解决方案：原子变量CAS
```

synchronized俗称对象锁，采用互斥的方式让多线程在同一时间只能有一个线程持有对象所，其他线程被阻塞等待，这样就能保证临界区的代码顺序，也不用担心上下文切换。

```
java中的互斥和同步：
互斥：保证临界区的竞态条件发生，并且当前只能有一个线程去操作临界区的代码。
同步：由于线程执行的先后不一样，一个线程要等待其他线程运行到某个点，如一个消费者需要等生产者将产品生产出来才可进行消费。
```



```
static int counter = 0;
static final Object room = new Object();
public static void main(String[] args) throws InterruptedException {
     Thread t1 = new Thread(() -> {
         for (int i = 0; i < 5000; i++) {
         	 // 对临界资源(共享资源的操作) 进行 加锁
             synchronized (room) {
             counter++;
        	}
 		}
 	}, "t1");
     Thread t2 = new Thread(() -> {
         for (int i = 0; i < 5000; i++) {
             synchronized (room) {
             counter--;
         }
     }
     }, "t2");
     t1.start();
     t2.start();
     t1.join();
     t2.join();
     log.debug("{}",counter);
}

09:56:24.210 guizy.ThreadLocalDemo [main] - count的值是0
```

#### synchronized原理

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201219110609489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20201219110651392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/img_convert/e7dda8af005cdee39d206896de899745.png)

```
如果把synchronized(obj)放在for循环的外面, 如何理解?
for循环也是一个原子操作, 表现出原子性

如果t1 synchronized(obj1) 而 t2 synchronized(obj2)会怎么运行?
因为t1, t2拿到不是同一把对象锁, 所以他们仍然会发现安全问题 – 必须要是同一把对象锁

如果t1 synchronized(obj) 而 t2 没有加会怎么样 ?
因为t2没有加锁, 所以t2, 不需要获取t1的锁, 直接就可以执行下面的代码, 仍然会出现安全问题
```

#### synchronized 加在方法上

- 加在`实例方法`上, 锁对象就是对象实例

```
public class Demo{
//在方法上加上synchronized关键字
	public synchronized void test() {
	
	}
	
	public void test() {
		synchronized(this){
	
		}
	}
}
```

- 加在`静态方法`上, 锁对象就是当前类的Class实例

```
public class Demo{
//在方法上加上synchronized关键字
	public synchronized static void test() {
	
	}
	
	public void test() {
		synchronized(Demo.class){
	
		}
	}
}
```

#### 成员变量和静态变量的线程安全分析 (`重要`)

- `如果变量没有在线程间共享，那么变量是安全的`
- 如果变量在线程间共享
  - 如果只有`读操作`，则`线程安全`
  - 如果有`读写操作`，则这段代码是`临界区`，`需要考虑线程安全`

#### 局部变量线程安全分析 (`重要`)

- 局部变量`【局部变量被初始化为基本数据类型】是安全的`
- 但局部变量引用的对象则未必 （要看该对象是否被共享且被执行了读写操作）
  - 如果`该对象没有逃离方法的作用范围`，它是`线程安全的`
  - 如果`该对象逃离方法的作用范围`，需要`考虑线程安全`

#### 常见线程安全类

- String
- Integer
- StringBuffer
- Random
- Vector
- Hashtable
- java.util.concurrent 包下的类 JUC

**`重点:`**

- 这里`说它们是线程安全`的是指，**`多个线程调用它们同一个实例的某个方法时，是线程安全的`** , 也可以理解为 **`它们的每个方法是原子的`**
- 它们的每个方法是原子的`（方法都被加上了synchronized）`
- 但注意它们`多个方法的组合不是原子的`，所以可能**会出现线程安全问题**

- String和Integer类都是不可变的类，因为其类内部状态是不可改变的，因此它们的方法都是线程安全的, 都被final修饰, 不能被继承.
  肯定有些人他们知道String 有 replace，substring 等方法【可以】改变值啊，其实调用这些方法返回的已经是一个新创建的对象了！ (在字符串常量池中当修改了String的值,它不会再原有的基础上修改, 而是会重新开辟一个空间来存储)

#### lock与Synchronized锁区别

![img](https://img-blog.csdnimg.cn/20210202223437264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

#### 多锁机制

- 小故事

- 一间大屋子有两个功能：`睡觉、学习，互不相干`。

- 现在小南要学习，小女要睡觉，但如果只用一间屋子（一个对象锁）的话，那么

  ```
  并发度很低
  ```

  - 小南获得锁之后, 学完习之后, 小女才能进来睡觉。

- **解决方法是准备多个房间`（多个对象锁）`**

```
@Slf4j(topic = "guizy.BigRoomTest")
public class BigRoomTest {
    public static void main(String[] args) {
        BigRoom bigRoom = new BigRoom();
        new Thread(() -> bigRoom.sleep(), "小南").start();
        new Thread(() -> bigRoom.study(), "小女").start();
    }
}

@Slf4j(topic = "guizy.BigRoom")
class BigRoom {
    public void sleep() {
        synchronized (this) {
            log.debug("sleeping 2 小时");
            Sleeper.sleep(2);
        }
    }

    public void study() {
        synchronized (this) {
            log.debug("study 1 小时");
            Sleeper.sleep(1);
        }
    }
}
```

- 改进让`小南, 小女`获取不同的锁即可

```
@Slf4j(topic = "guizy.BigRoomTest")
public class BigRoomTest {
    private static final BigRoom sleepRoom = new BigRoom();
    private static final BigRoom studyRoom = new BigRoom();

    public static void main(String[] args) {
    	// 不同对象调用
        new Thread(() -> sleepRoom.sleep(), "小南").start();
        new Thread(() -> studyRoom.study(), "小女").start();
    }
}
```

- 将锁的粒度细分
  - 好处，是可以`增强并发度`
  - 坏处，如果一个线程需要同时获得多把锁，就`容易发生死锁`

##### 活跃性

- 因为某种原因，使得代码一直无法执行完毕，这样的现象叫做 **活跃性**
- 活跃性相关的一系列问题都可以用 **`ReentrantLock`** 进行解决。



#### Lock锁解决线程安全问题

#### 多线程死锁线程产生的原因

- 实际就是线程1拥有A对象的锁单它同时也需要B对象的锁，恰好线程2拥有B对象的锁但它又要获取A对象的锁，此时形成一个循环链路，两者都不肯释放自己锁占的锁，导致两者都阻塞等待，形成死锁。

```
public static void main(String[] args) {
	final Object A = new Object();
	final Object B = new Object();
	
	new Thread(()->{
		synchronized (A) {
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			synchronized (B) {

			}
		}
	}).start();

	new Thread(()->{
		synchronized (B) {
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			synchronized (A) {

			}
		}
	}).start();
}
```

- 发生死锁的必要条件
  - 互斥条件：一段时间内，一种资源只能被一个线程使用
  - 请求和保持条件：自己所占有的资源在没有执行完时，不会主动释放。
  - 不可抢占条件：对以获得资源没有使用完成前不能被强占。
  - 循环等待条件：发生死锁时回形成进程-资源的循环链。





#### 多线程如何排查死锁的现象

- 方法一：利用java的控制台

在Java控制台中的`Terminal`中输入 **`jps`** 指令可以查看`正在运行中的进程ID`，使用 **`jstack 进程ID`** 可以查看进程状态。

![img](https://img-blog.csdnimg.cn/20201223123336643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20201223123406253.png)

![img](https://img-blog.csdnimg.cn/20201223123554788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

- 方法二：利用jconsole检测死锁

![img](https://img-blog.csdnimg.cn/img_convert/359638cf867dbe8d03da37c3e19fefe3.png)

![img](https://img-blog.csdnimg.cn/img_convert/e9f23bd07142b38d856fef84e6ded641.png)

##### 死锁举例 - 哲学家就餐问题 (`重点`)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201223123802724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

有五位哲学家，围坐在圆桌旁。

他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。
吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。
如果筷子被身边的人拿着，自己就得等待
当每个哲学家即线程持有一根筷子时，他们都在等待另一个线程释放锁，因此造成了死锁。

```
@Slf4j(topic = "guizy.PhilosopherEat")
public class PhilosopherEat {
    public static void main(String[] args) {
        Chopstick c1 = new Chopstick("1");
        Chopstick c2 = new Chopstick("2");
        Chopstick c3 = new Chopstick("3");
        Chopstick c4 = new Chopstick("4");
        Chopstick c5 = new Chopstick("5");
        new Philosopher("苏格拉底", c1, c2).start();
        new Philosopher("柏拉图", c2, c3).start();
        new Philosopher("亚里士多德", c3, c4).start();
        new Philosopher("赫拉克利特", c4, c5).start();
        new Philosopher("阿基米德", c5, c1).start();
    }
}

@Slf4j(topic = "guizy.Philosopher")
class Philosopher extends Thread {
    final Chopstick left;
    final Chopstick right;

    public Philosopher(String name, Chopstick left, Chopstick right) {
        super(name);
        this.left = left;
        this.right = right;
    }

    @Override
    public void run() {
        while (true) {
            // 尝试获取左手筷子
            synchronized (left) {
                // 尝试获取右手筷子
                synchronized (right) {
                    eat();
                }
            }
        }
    }

    private void eat() {
        log.debug("eating...");
        Sleeper.sleep(0.5);
    }
}

class Chopstick{
    String name;

    public Chopstick(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "筷子{" + name + '}';
    }
}
```

通过`jps, jstack 进程id`查看死锁原因
`Found one Java-level deadlock:` 发现了一个Java级别的死锁

```
Found one Java-level deadlock:
=============================
"阿基米德":
  waiting to lock monitor 0x000000001ae2a358 (object 0x00000000d6ea7420, a com.guizy.reentrantlock.Chopstick),
  which is held by "苏格拉底"
"苏格拉底":
  waiting to lock monitor 0x0000000017fb3518 (object 0x00000000d6ea7430, a com.guizy.reentrantlock.Chopstick),
  which is held by "柏拉图"
"柏???图":
  waiting to lock monitor 0x0000000017fb3468 (object 0x00000000d6ea7440, a com.guizy.reentrantlock.Chopstick),
  which is held by "亚里士多德"
"亚里士多德":
  waiting to lock monitor 0x0000000017fb0bd8 (object 0x00000000d6ea7450, a com.guizy.reentrantlock.Chopstick),
  which is held by "赫拉克利特"
"赫拉克利特":
  waiting to lock monitor 0x0000000017fb0c88 (object 0x00000000d6ea7460, a com.guizy.reentrantlock.Chopstick),
  which is held by "阿基米德"

Java stack information for the threads listed above:
===================================================
"阿基米德":
        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:47)
        - waiting to lock <0x00000000d6ea7420> (a com.guizy.reentrantlock.Chopstick)
        - locked <0x00000000d6ea7460> (a com.guizy.reentrantlock.Chopstick)
"苏格拉底":
        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:47)
        - waiting to lock <0x00000000d6ea7430> (a com.guizy.reentrantlock.Chopstick)
        - locked <0x00000000d6ea7420> (a com.guizy.reentrantlock.Chopstick)
"柏拉图":
        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:47)
        - waiting to lock <0x00000000d6ea7440> (a com.guizy.reentrantlock.Chopstick)
        - locked <0x00000000d6ea7430> (a com.guizy.reentrantlock.Chopstick)
"亚里士多德":
        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:47)
        - waiting to lock <0x00000000d6ea7450> (a com.guizy.reentrantlock.Chopstick)
        - locked <0x00000000d6ea7440> (a com.guizy.reentrantlock.Chopstick)
"赫拉克利特":
        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:47)
        - waiting to lock <0x00000000d6ea7460> (a com.guizy.reentrantlock.Chopstick)
        - locked <0x00000000d6ea7450> (a com.guizy.reentrantlock.Chopstick)

Found 1 deadlock.
```





#### 避免死锁的方法

- 在线程使用锁对象时, 采用**固定加锁的顺序**, 可以使用Hash值的大小来确定加锁的先后

- 尽可能缩减加锁的范围, 等到操作共享变量的时候才加锁

- 使用可释放的定时锁 (一段时间申请不到锁的权限了, 直接释放掉)

![img](https://img-blog.csdnimg.cn/img_convert/b8a0466afe78fa85b406d66813c15c9b.png)

#### 活锁

- `活锁`出现在两个线程 **`互相改变对方的结束条件`**，谁也无法结束。

##### 避免活锁的方法

- 在线程执行时，中途给予 **`不同的间隔时间`**, 让某个线程先结束即可。





#### lock读写锁的使用



### 多线程之间通讯

#### 生产者与消费者

#### wait和notify

![img](https://img-blog.csdnimg.cn/20201220084049915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20201220084213239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

##### wait、notify介绍 (必须要获取到锁对象, 才能调用这些方法)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201220084652893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

- **当`线程0`获得到了`锁`, 成为`Monitor`的`Owner`, 但是此时它发现自己想要执行`synchroized代码块`的条件不满足; 此时它就调用`obj.wait`方法, 进入到Monitor中的`WaitSet`集合, 此时`线程0`的状态就变为`WAITING`**

- 处于BLOCKED和WAITING状态的线程都为阻塞状态，CPU都不会分给他们时间片。但是有所区别：
  - BLOCKED状态的线程是在竞争锁对象时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于BLOCKED状态
  - WAITING状态的线程是获得了对象的锁，但是自身的原因无法执行synchroized的临界区资源需要进入阻塞状态时，锁对象调用了wait方法而进入了WaitSet中，处于WAITING状态
- **`处于BLOCKED状态的线程会在锁被释放的时候被唤醒`**
- **`处于WAITING状态的线程只有被锁对象调用了notify方法(obj.notify/obj.notifyAll)，才会被唤醒。然后它会进入到EntryList, 重新竞争锁`** (此时就将锁升级为`重量级锁`)



##### API

下面的三个方法都是Object中的方法; 通过锁对象来调用

- wait(): 让获得对象锁的线程到waitSet中一直等待

- wait(long n) : 当该等待线程没有被notify, 等待时间到了之后, 也会自动唤醒

- notify(): 让获得对象锁的线程, 使用锁对象调用notify去waitSet的等待线程中挑一个唤醒

- notifyAll() : 让获得对象锁的线程, 使用锁对象调用notifyAll去唤醒waitSet中所有的等待线程

它们都是线程之间进行协作的手段, 都属于Object对象的方法, 必须获得此对象的锁, 才能调用这些方法

注：只有当对象被锁以后(成为Owner)，才能调用wait和notify方法

```
public class Test1 {
	final static Object LOCK = new Object();
	public static void main(String[] args) throws InterruptedException {
        //只有在对象被锁住后才能调用wait方法
		synchronized (LOCK) {
			LOCK.wait();
		}
	}
	}
```

- 演示`wait和notify`方法

```
@Slf4j(topic = "guizy.WaitNotifyTest")
public class WaitNotifyTest {
    static final Object obj = new Object();

    public static void main(String[] args) throws Exception {

        new Thread(() -> {
            synchronized (obj) {
                log.debug("执行...");
                try {
                    // 只有获得锁对象之后, 才能调用wait/notify
                    obj.wait(); // 此时t1线程进入WaitSet等待
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("其它代码...");
            }
        }, "t1").start();

        new Thread(() -> {
            synchronized (obj) {
                log.debug("执行...");
                try {
                    obj.wait(); // 此时t2线程进入WaitSet等待
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("其它代码...");
            }
        }, "t2").start();

        // 让主线程等两秒在执行,为了`唤醒`,不睡的话,那两个线程还没进入waitSet,主线程就开始唤醒了
        Thread.sleep(1000);
        log.debug("唤醒waitSet中的线程!");
        // 只有获得锁对象之后, 才能调用wait/notify
        synchronized (obj) {
            // obj.notify(); // 唤醒waitset中的一个线程
             obj.notifyAll(); // 唤醒waitset中的全部等待线程
        }
    }
}

13:01:36.176 guizy.WaitNotifyTest [t1] - 执行...
13:01:36.178 guizy.WaitNotifyTest [t2] - 执行...
13:01:37.175 guizy.WaitNotifyTest [main] - 唤醒waitSet中的线程!
13:01:37.175 guizy.WaitNotifyTest [t2] - 其它代码...
13:01:37.175 guizy.WaitNotifyTest [t1] - 其它代码...
```

##### Sleep(long n) 和 Wait(long n)的区别 `(重点)`

不同点

Sleep是Thread类的静态方法，Wait是Object的方法，Object又是所有类的父类，所以所有类都有Wait方法。
Sleep在阻塞的时候不会释放锁，而Wait在阻塞的时候会释放锁 (不释放锁的话, 其他线程就无法唤醒该线程了)
Sleep方法不需要与synchronized一起使用，而Wait方法需要与synchronized一起使用（wait/notify等方法, 必须要使用对象锁来调用）
相同点

阻塞状态都为TIMED_WAITING (限时等待)
sleep方法 / wait方法 测试

```
@Slf4j(topic = "guizy.SleepTest")
public class SleepTest {

    public static final Object lock = new Object();

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (lock) {
                log.debug("获得锁了");
                try {
                    // Thread.sleep(5000); // 主线程需要等5s才能获得到锁.所以所在sleep期间, 是不会释放锁的
                    lock.wait(5000); // 调用wait方法会立刻释放锁, 不然主线程就拿不到lock锁了, 当等待5s后程序才结束
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "t1").start();

        // 主线程睡一秒
        Sleeper.sleep(1);
        synchronized (lock) {
            log.debug("获得锁了");
        }
}
```

sleep打印结果 : 表明在sleep期间, 锁是不会被释放的

![img](https://img-blog.csdnimg.cn/20201220094013513.png)

wait打印结果 : 当调用wait方法后, 锁就会被立刻释放

![img](https://img-blog.csdnimg.cn/20201220094129242.png)

##### wait/notify的正确使用

```
@Slf4j(topic = "guizy.WaitNotifyTest")
public class WaitNotifyTest {
    static final Object room = new Object();
    static boolean hasCigarette = false;
    static boolean hasTakeout = false;

    public static void main(String[] args) {
        //思考下面的解决方案好不好，为什么？
        new Thread(() -> {
            synchronized (room) {
                log.debug("有烟没？[{}]", hasCigarette);
                if (!hasCigarette) {
                    log.debug("没烟，先歇会！");
                    Sleeper.sleep(2);   // 会阻塞2s, 不会释放锁
                }
                log.debug("有烟没？[{}]", hasCigarette);
                if (hasCigarette) {
                    log.debug("可以开始干活了");
                }
            }
        }, "小南").start();

        for (int i = 0; i < 5; i++) {
            new Thread(() -> {
                synchronized (room) {
                    log.debug("可以开始干活了");
                }
            }, "其它人").start();
        }

        Sleeper.sleep(1);
        new Thread(() -> {
            // 此时没有加锁, 所以会优先于其他人先执行
            // 这里能不能加 synchronized (room)？
            //synchronized (room) { // 如果加锁的话, 送烟人也需要等待小南睡2s的时间,此时即使送到了,小南线程也将锁释放了..
                hasCigarette = true;
                log.debug("烟到了噢！");
            //}
        }, "送烟的").start();
    }
}
```

- 不给`送烟线程加synchronized`输出情况

```
10:16:32.311 guizy.WaitNotifyTest [小南] - 有烟没？[false]
10:16:32.318 guizy.WaitNotifyTest [小南] - 没烟，先歇会！
10:16:33.318 guizy.WaitNotifyTest [送烟的] - 烟到了噢！
10:16:34.320 guizy.WaitNotifyTest [小南] - 有烟没？[true]
10:16:34.320 guizy.WaitNotifyTest [小南] - 可以开始干活了
10:16:34.320 guizy.WaitNotifyTest [其它人] - 可以开始干活了
10:16:34.320 guizy.WaitNotifyTest [其它人] - 可以开始干活了
10:16:34.320 guizy.WaitNotifyTest [其它人] - 可以开始干活了
10:16:34.321 guizy.WaitNotifyTest [其它人] - 可以开始干活了
10:16:34.321 guizy.WaitNotifyTest [其它人] - 可以开始干活了
```

- 给`送烟线程加synchronized`输出情况

```
10:16:57.565 guizy.WaitNotifyTest [小南] - 有烟没？[false]
10:16:57.570 guizy.WaitNotifyTest [小南] - 没烟，先歇会！
10:16:59.574 guizy.WaitNotifyTest [小南] - 有烟没？[false]
10:16:59.574 guizy.WaitNotifyTest [送烟的] - 烟到了噢！
10:16:59.575 guizy.WaitNotifyTest [其它人] - 可以开始干活了
10:16:59.575 guizy.WaitNotifyTest [其它人] - 可以开始干活了
10:16:59.575 guizy.WaitNotifyTest [其它人] - 可以开始干活了
10:16:59.575 guizy.WaitNotifyTest [其它人] - 可以开始干活了
10:16:59.576 guizy.WaitNotifyTest [其它人] - 可以开始干活了
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201220101906421.png)

- 使用`while循环`来解决`虚假唤醒`

```
@Slf4j(topic = "guizy.WaitNotifyTest")
public class Main {
    static final Object room = new Object();
    static boolean hasCigarette = false;
    static boolean hasTakeout = false;

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (room) {
                log.debug("有烟没？[{}]", hasCigarette);
                while (!hasCigarette) {
                    log.debug("没烟，先歇会！");
                    try {
                        room.wait(); // 此时进入到waitset等待集合, 同时会释放锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.debug("有烟没？[{}]", hasCigarette);
                if (hasCigarette) {
                    log.debug("可以开始干活了");
                }
            }
        }, "小南").start();

        new Thread(() -> {
            synchronized (room) {
                log.debug("外卖送到没？[{}]", hasTakeout);
                while (!hasTakeout) {
                    log.debug("没外卖，先歇会！");
                    try {
                        room.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.debug("外卖送到没？[{}]", hasTakeout);
                if (hasTakeout) {
                    log.debug("可以开始干活了");
                } else {
                    log.debug("没干成活...");
                }
            }
        }, "小女").start();

        Sleeper.sleep(1);
        new Thread(() -> {
            synchronized (room) {
                hasTakeout = true;
                log.debug("外卖到了噢！");
                room.notifyAll();
            }
        }, "送外卖的").start();
    }
}
```

```
11:19:25.275 guizy.WaitNotifyTest [小南] - 有烟没？[false]
11:19:25.282 guizy.WaitNotifyTest [小南] - 没烟，先歇会！
11:19:25.282 guizy.WaitNotifyTest [小女] - 外卖送到没？[false]
11:19:25.283 guizy.WaitNotifyTest [小女] - 没外卖，先歇会！
11:19:26.287 guizy.WaitNotifyTest [送外卖的] - 外卖到了噢！
11:19:26.287 guizy.WaitNotifyTest [小女] - 外卖送到没？[true]
11:19:26.287 guizy.WaitNotifyTest [小女] - 可以开始干活了
11:19:26.288 guizy.WaitNotifyTest [小南] - 没烟，先歇会！
```

因为改为`while`如果唤醒之后, 就在while循环中执行了, 不会跑到while外面去执行"有烟没…", 此时小南就不需要每次notify, 就去看是不是送来的烟, 如果是烟, while就为false了.



#### join方法的原理

##### 同步模式之保护性暂停 (`join、Future的实现`)

- 即Guarded Suspension，用在一个线程等待另一个线程的执行结果

- 有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject
  如果有结果不断从一个线程到另一个线程 那么可以使用消息队列（见生产者/消费者）
  JDK 中，join 的实现、Future 的实现，采用的就是此模式
  因为要等待另一方的结果，因此归类到同步模式

![img](https://img-blog.csdnimg.cn/img_convert/e73412e2618ca103105cce41f4b228c9.png)

- `一方等待另一方的执行结果`举例 :
- 举例, 线程1等待线程2下载的结果,并获取该结果

```
@Slf4j(topic = "guizy.GuardeObjectTest")
public class GuardeObjectTest {
    public static void main(String[] args) {
        // 线程1等待线程2的下载结果
        GuardeObject guardeObject = new GuardeObject();
        new Thread(() -> {
            log.debug("等待结果");
            List<String> list = (List<String>) guardeObject.get();
            log.debug("结果大小:{}", list.size());
        }, "t1").start();

        new Thread(() -> {
            log.debug("执行下载");
            try {
                List<String> list = Downloader.download();
                guardeObject.complete(list);
            } catch (IOException e) {
                e.printStackTrace();
            }

        }, "t2").start();
    }
}

class GuardeObject {
    // 结果
    private Object response;

    // 获取结果
    public Object get() {
        synchronized (this) {
            // 防止虚假唤醒
            // 没有结果
            while (response == null) {
                try {
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            return response;
        }
    }

    // 产生结果
    public void complete(Object response) {
        synchronized (this) {
            // 给结果变量赋值
            this.response = response;
            this.notifyAll();
        }
    }
}
```

- 关于超时的增强，在`join(long millis) 的源码`中得到了体现：

```
public final synchronized void join(long millis)
throws InterruptedException {
    long base = System.currentTimeMillis();
    long now = 0;

    if (millis < 0) {
        throw new IllegalArgumentException("timeout value is negative");
    }

    if (millis == 0) {
        while (isAlive()) {
            wait(0);
        }
    } else {
    // join一个指定的时间
        while (isAlive()) {
            long delay = millis - now;
            if (delay <= 0) {
                break;
            }
            wait(delay);
            now = System.currentTimeMillis() - base;
        }
    }
}
```

- 多任务版GuardedObject图中 Futures 就好比居民楼一层的信箱（每个信箱有房间编号），左侧的 t0，t2，t4 就好比等待邮件的居民，右侧的 t1，t3，t5 就好比邮递员如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类。
- 不仅能够`解耦`【结果等待者】和【结果生产者】，还能够同时支持`多个任务的管理`。和生产者消费者模式的区别就是：**这个`产生结果的线程`和`使用结果的线程`是`一一对应`的关系，但是生产者消费者模式并不是。**
- rpc框架的调用中就使用到了这种模式。

![img](https://img-blog.csdnimg.cn/img_convert/8af156fb943083720b551f6e52ddd03c.png)

```
@Slf4j(topic = "guizy.GuardedObjectTest")
public class GuardedObjectTest {
    public static void main(String[] args) {
        for (int i = 0; i < 3; i++) {
            new People().start();
        }
        Sleeper.sleep(1);
        for (Integer id : Mailboxes.getIds()) {
            new Postman(id, "内容" + id).start();
        }
    }
}

@Slf4j(topic = "guizy.People")
class People extends Thread {
    @Override
    public void run() {
        // 收信
        GuardedObject guardedObject = Mailboxes.createGuardedObject();
        log.debug("开始收信 id:{}", guardedObject.getId());
        Object mail = guardedObject.get(5000);
        log.debug("收到信 id:{}, 内容:{}", guardedObject.getId(), mail);
    }
}

@Slf4j(topic = "guizy.Postman")
// 邮寄员类
class Postman extends Thread {
    private int id;
    private String mail;

    public Postman(int id, String mail) {
        this.id = id;
        this.mail = mail;
    }

    @Override
    public void run() {
        GuardedObject guardedObject = Mailboxes.getGuardedObject(id);
        log.debug("送信 id:{}, 内容:{}", id, mail);
        guardedObject.complete(mail);
    }
}

// 信箱类
class Mailboxes {
    private static Map<Integer, GuardedObject> boxes = new Hashtable<>();

    private static int id = 1;

    // 产生唯一 id
    private static synchronized int generateId() {
        return id++;
    }

    public static GuardedObject getGuardedObject(int id) {
        //根据id获取到box并删除对应的key和value,避免堆内存爆了
        return boxes.remove(id);
    }

    public static GuardedObject createGuardedObject() {
        GuardedObject go = new GuardedObject(generateId());
        boxes.put(go.getId(), go);
        return go;
    }

    public static Set<Integer> getIds() {
        return boxes.keySet();
    }
}

// 用来传递信息的作用, 当多个类使用GuardedObject,就很不方便,此时需要一个设计一个解耦的中间类
class GuardedObject {
    // 标记GuardedObject
    private int id;
    // 结果
    private Object response;

    public int getId() {
        return id;
    }

    public GuardedObject(int id) {
        this.id = id;
    }

    // 获取结果
    // timeout表示等待多久. 这里假如是2s
    public Object get(long timeout) {
        synchronized (this) {
            // 假如开始时间为 15:00:00
            long begin = System.currentTimeMillis();
            // 经历的时间
            long passedTime = 0;
            while (response == null) {
                // 这一轮循环应该等待的时间
                long waitTime = timeout - passedTime;
                // 经历的时间超过了最大等待时间, 退出循环
                if (waitTime <= 0) {
                    break;
                }
                try {
                    // this.wait(timeout)的问题: 虚假唤醒在15:00:01的时候,此时response还null, 此时经历时间就为1s,
                    // 进入while循环的时候response还是空,此时判断1s<=timeout 2s,此时再次this.wait(2s)吗,此时已经经历了
                    // 1s,所以只要再等1s就可以了. 所以等待的时间应该是 超时时间(timeout) - 经历的时间(passedTime)
                    this.wait(waitTime);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 经历时间
                passedTime = System.currentTimeMillis() - begin; // 15:00:02
            }
            return response;
        }
    }

    // 产生结果
    public void complete(Object response) {
        synchronized (this) {
            // 给结果变量赋值
            this.response = response;
            this.notifyAll();
        }
    }
}
```

join()：等待线程运行结束

join(long n)：等待线程运行结束，最多等待n毫秒



#### 异步模式之生产者/消费者 (`重点`)

- 与前面的`保护性暂停`中的 `GuardedObject` 不同，**不需要**`产生结果`和`消费结果`的`线程一一对应 (一个生产一个消费)`
- **`消费队列`** 可以用来**平衡生产和消费的线程资源**
- **生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据**
- **消息队列是有`容量限制`的，满时不会再加入数据，空时不会再消耗数据**
- JDK 中各种 [阻塞队列](https://blog.csdn.net/yanpenglei/article/details/79556591)，采用的就是这种模式

![img](https://img-blog.csdnimg.cn/img_convert/82487e714da1c44453d46a61d6dcb27b.png)

```
package com.current.demo;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.LinkedList;
import java.util.concurrent.TimeUnit;

/**
 * @program: threadDemo
 * @description: 异步模式之生产者/消费者
 * @author: mengjianglong@e6yun.com
 * @create: 2021-10-27 14:36
 **/

public class MessageTest {
    private Logger log = LoggerFactory.getLogger(MessageTest.class);

    public static void main(String[] args) {
        MessageQueue messageQueue = new MessageQueue(3);
        for (int i = 0; i < 4; i++) {
            int t = i;
            new Thread(() -> {
                messageQueue.put(new Message(t, "值" + t));
            }, "生产者" + i).start();
        }

        new Thread(() -> {
            while (true){
                messageQueue.task();
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"消费者").start();
    }
}
class MessageQueue {
    private Logger log = LoggerFactory.getLogger(MessageTest.class);

    private LinkedList<Message> messages = new LinkedList<Message>();
    // 队列最大容量
    private int capcity;

    public MessageQueue(int capcity) {
        this.capcity = capcity;
    }

    // 获取消息
    public Message task(){
        synchronized (messages){
            while (messages.isEmpty()){
                try {
                    log.info("队列为空，请等待。。。");
                    messages.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            Message message = messages.removeFirst();
            log.info("以消费消息：{}",message);
            messages.notifyAll();
            return message;
        }
    }
    // 推送消息
    public void put(Message message){
        synchronized (messages){
            while (messages.size() == capcity){
                try {
                    log.info("队列已满，请等待。。。");
                    messages.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            messages.add(message);
            log.info("以生产消息：{}",message);
            messages.notifyAll();
        }

    }
}

final class Message{
    private int id;
    private Object value;

    public Message(int id, Object value) {
        this.id = id;
        this.value = value;
    }

    public int getId() {
        return id;
    }

    public Object getValue() {
        return value;
    }

    @Override
    public String toString() {
        return "Message{" +
                "id=" + id +
                ", value=" + value +
                '}';
    }
}
```

```
15:03:47.280 [消费者] INFO com.current.demo.MessageTest - 队列为空，请等待。。。
15:03:47.282 [生产者0] INFO com.current.demo.MessageTest - 以生产消息：Message{id=0, value=值0}
15:03:47.284 [消费者] INFO com.current.demo.MessageTest - 以消费消息：Message{id=0, value=值0}
15:03:47.284 [生产者1] INFO com.current.demo.MessageTest - 以生产消息：Message{id=1, value=值1}
15:03:47.284 [生产者2] INFO com.current.demo.MessageTest - 以生产消息：Message{id=2, value=值2}
15:03:47.284 [生产者3] INFO com.current.demo.MessageTest - 以生产消息：Message{id=3, value=值3}
15:03:48.285 [消费者] INFO com.current.demo.MessageTest - 以消费消息：Message{id=1, value=值1}
15:03:49.285 [消费者] INFO com.current.demo.MessageTest - 以消费消息：Message{id=2, value=值2}
15:03:50.285 [消费者] INFO com.current.demo.MessageTest - 以消费消息：Message{id=3, value=值3}
15:03:51.285 [消费者] INFO com.current.demo.MessageTest - 队列为空，请等待。。。
```



#### park & unpack `(重要)`

##### 基本使用

- `park/unpark`都是`LockSupport`类中的的方法
- **先调用`unpark`后,再调用park, 此时`park`不会暂停线程**

```
// 暂停当前线程
LockSupport.park();
// 恢复某个线程的运行
LockSupport.unpark(thread);
```

##### 原理

- `每个线程`都有自己的一个 `Parker 对象`，由三部分组成 **`_counter`， `_cond`和 `_mutex`**

- `先调用park的情况`
  - 当前线程调用 **Unsafe.park()** 方法
  - **检查 _counter, 本情况为`0`,** 这时, 获得`_mutex 互斥锁`**(mutex对象有个等待队列 _cond)**
  - 线程进入 _cond 条件变量`阻塞`
  - 设置`_counter = 0` (没干粮了)

![img](https://img-blog.csdnimg.cn/img_convert/090e9cb2aed20d43c147ec0ea6470d5e.png)

- `调用unpark`
  - 调用`Unsafe.unpark(Thread_0)方法`，设置`_counter 为 1`
  - 唤醒 _cond 条件变量中的 Thread_0
  - Thread_0 `恢复运行`
  - **设置 _counter 为 0**

![img](https://img-blog.csdnimg.cn/img_convert/ca03643f837f34098def91bfadc54bd6.png)

- ###### 先调用upark再调用park的过程

- 调用 `Unsafe.unpark(Thread_0)`方法，设置 `_counter 为 1`
- 当前`线程`调用 `Unsafe.park()` 方法
- 检查 `_counter`，本情况为 `1`，这时线程 **`无需阻塞，继续运行`**
- 设置 _counter 为 0

![img](https://img-blog.csdnimg.cn/img_convert/d0d3270088a031c2066af2762e894413.png)

#### 线程状态转换 `(重点)`

![img](https://img-blog.csdnimg.cn/img_convert/64146d2ab235481979b13ec4e9608fc5.png)

- 1、NEW <–> RUNNABLE
  t.start()方法时, NEW --> RUNNABLE

- 2、RUNNABLE <–> WAITING
  线程用synchronized(obj)获取了对象锁后
  调用 obj.wait()方法时，t 线程进入waitSet中, 从RUNNABLE --> WAITING
  调用 obj.notify()，obj.notifyAll()，t.interrupt() 时, 唤醒的线程都到entrySet阻塞队列成为BLOCKED状态, 在阻塞队列,和其他线程再进行 竞争锁
  竞争锁成功，t 线程从 WAITING --> RUNNABLE
  竞争锁失败，t 线程从 WAITING --> BLOCKED

- 3、RUNNABLE <–> WAITING
  当前线程调用 t.join() 方法时，当前线程从 RUNNABLE --> WAITING ,注意是当前线程在t线程对象在waitSet上等待
  t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 WAITING --> RUNNABLE

- 4、RUNNABLE <–> WAITING
  当前线程调用 LockSupport.park() 方法会让当前线程从RUNNABLE --> WAITING
  调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING --> RUNNABLE
  Runnable 和 Timed-Waiting的相互转换

- 5、RUNNABLE <–> TIMED_WAITING (带超时时间的wait)
  t 线程用synchronized(obj) 获取了对象锁后
  调用 obj.wait(long n) 方法时，t 线程从 RUNNABLE --> TIMED_WAITING
  t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时; 唤醒的线程都到entrySet阻塞队列成为BLOCKED状态, 在阻塞队列,和其他线程再进行 竞争锁
  竞争锁成功，t 线程从 TIMED_WAITING --> RUNNABLE
  竞争锁失败，t 线程从 TIMED_WAITING --> BLOCKED

- 6、RUNNABLE <–> TIMED_WAITING
  当前线程调用 t.join(long n) 方法时，当前线程从 RUNNABLE --> TIMED_WAITING 注意是当前线程在t 线程对象的waitSet等待
  当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 TIMED_WAITING --> RUNNABLE

- 7、RUNNABLE <–> TIMED_WAITING
  当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE --> TIMED_WAITING
  当前线程等待时间超过了 n 毫秒或调用了线程的 interrupt() ，当前线程从 TIMED_WAITING --> RUNNABLE

- 8、RUNNABLE <–> TIMED_WAITING
  当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线程从 RUNNABLE --> TIMED_WAITING
  调用LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING--> RUNNABLE

- 9、RUNNABLE <–> BLOCKED
  t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE –> BLOCKED, 持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –> RUNNABLE ，其它失败的线程仍然 BLOCKED

- 10、 RUNNABLE <–> TERMINATED
  当前线程所有代码运行完毕，进入 TERMINATED







## volatile关键字原理



### 关键字特性

#### 保证可见性

#### 禁止重排序

#### 不保证原子性



### java内存模型

- JMM 即 `Java Memory Model` ，它从Java层面定义了 **`主存`、`工作内存`** 抽象概念，底层对应着CPU 寄存器、缓存、硬件内存、CPU 指令优化等。JMM 体现在以下几个方面
- **`原子性`** - 保证指令不会受 **线程上下文切换的影响**
- **`可见性`** - 保证指令不会受 **cpu 缓存的影响 `(JIT对热点代码的缓存优化)`**
- **`有序性`** - 保证指令不会受 **cpu 指令并行优化的影响**

####  可见性

- 先来看一个现象，`main线程`对`run变量`的`修改`对于`t线程不可见`，**导致了 t 线程无法停止**

```
@Slf4j(topic = "guizy.Test1")
public class Test1 {
    // 增加t1线程, 对主线程更改run变量的可见性
    // 一开始一直不结束, 是因为无限循环, run都是true, JIT及时编译器, 会对t1线程所执行的
    // run变量,进行缓存, 缓存到本地工作内存. 不去访问主存中的run. 这样可以提高性能; 也可以说是JVM打到一定阈值之后
    // while(true)变成了一个热点代码, 所以一直访问的都是缓存到本地工作内存(局部)中的run. 当主线程修改主存中的run变量的时候,
    // t1线程一直访问的是自己缓存的, 所以不认为run已经改为false了. 所以一直运行. 我们为主存(成员变量)进行volatile修饰, 增加
    // 变量的可见性, 当主线程修改run为false, t1线程对run的值可见. 这样就可以退出循环
    volatile static boolean run = true;
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            while (run) {
                // 如果打印一句话
                // 此时就可以结束, 因为println方法中, 使用到了synchronized
                // synchronized可以保证原子性、可见性、有序性
                // System.out.println("123");
            }
        });

        t1.start();
        Sleeper.sleep(1);
        run = false;
        System.out.println(run);
    }
}
```

使用`synchronized`解决

```
@Slf4j(topic = "guizy.Test1")
public class Test1 {
    static boolean run = true;
    final static Object obj = new Object();
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            // 1s内,一直都在无限循环获取锁. 1s后主线程抢到锁,修改为false, 此时t1线程抢到锁对象,while循环也退出
            while (run) {
                synchronized (obj) {

                }
            }
        });

        t1.start();
        Sleeper.sleep(1);
        // 当主线程获取到锁的时候, 就修改为false了
        synchronized (obj) {
            run = false;
            System.out.println("false");
        }
    }
}
```

**为什么会出现对run变量的不可见性呢呢？分析一下：**

- `初始状态`， `t线程`刚开始从`主内存(成员变量)`, 因为主线程sleep(1)秒, 这时候t1线程循环了好多次run的值, 超过了一定的阈值, JIT就会将主存中的run值读取到工作内存 (相当于缓存了一份, 不会去主存中读run的值了)。

![img](https://img-blog.csdnimg.cn/img_convert/55a9700c011a4188ffdb8993f88ded28.png)

- 因为t1线程频繁地从主存中读取run的值，JIT即时编译器会将run的值缓存至自己工作内存中的高速缓存中，减少对主存中run的访问以提高效

![1594646562777](https://img-blog.csdnimg.cn/img_convert/e81d86ac7eea71c6f94dab875af787c7.png)

- 1 秒之后，`main线程修改了run的值, 并同步至主存`。而 t线程是从自己工作内存中的高速缓存中读取这个变量的值，**结果永远是旧值**

![img](https://img-blog.csdnimg.cn/img_convert/62f824bbb5595133018b992b326c7913.png)

![img](https://img-blog.csdnimg.cn/20210202183308792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

##### 解决方法

- 使用`volatile`（表示易变关键字的意思），它可以用来修饰`成员变量`和`静态成员变量`，它可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存

volatile 可以认为是一个轻量级的锁，被 volatile 修饰的变量，汇编指令会存在于一个"lock"的前缀。在CPU层面与主内存层面，通过缓存一致性协议，**加锁后能够保证写的值同步到主内存，使其他线程能够获得最新的值。**

- 使用`synchronized关键字`也有相同的效果, 在`Java内存模型`中，synchronized规定，线程在加锁时， `先清空工作内存 → 在主内存中拷贝最新变量的副本到工作内存 → 执行完代码 → 将更改后的共享变量的值刷新到主内存中 → 释放互斥锁。`

```
getstatic run // 线程 t 获取 run true
getstatic run // 线程 t 获取 run true
getstatic run // 线程 t 获取 run true
getstatic run // 线程 t 获取 run true
putstatic run // 线程 main 修改 run 为 false， 仅此一次
getstatic run // 线程 t 获取 run false 
```

- 比较一下之前我们讲线程安全时举的例子：**两个线程一个 i++ 一个 i-- ，只能保证看到最新值(可见性)，不能解决指令交错(原子性)**

```
// 假设i的初始值为0
getstatic i // 线程2-获取静态变量i的值 线程内i=0
getstatic i // 线程1-获取静态变量i的值 线程内i=0
iconst_1 // 线程1-准备常量1
iadd // 线程1-自增 线程内i=1
putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1
iconst_1 // 线程2-准备常量1
isub // 线程2-自减 线程内i=-1
putstatic i // 线程2-将修改后的值存入静态变量i 静态变量i=-1 
```

$$
注意 ：synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是 synchronized 是属于重量级操作，性能相对更低。 如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了，想一想为什么？因为println方法里面有synchronized修饰。还有那个等烟的示例, 为啥没有出现可见性问题?和synchrozized是一个道理。
$$

##### 模式之两阶段终止

$$
当我们在执行线程一时，想要终止线程二，这是就需要使用interrupt方法来优雅的停止线程二。这是我们之前的做法
$$

- 使用volatile关键字来实现两阶段终止模式

```
package com.current.demo;

import lombok.extern.slf4j.Slf4j;

/**
 * @program: threadDemo
 * @description: 两阶段终止模式之volatile
 * @author: mengjianglong@e6yun.com
 * @create: 2021-12-06 18:48
 **/

public class Test1 {
    public static void main(String[] args) {
        Monitor monitor = new Monitor();
        monitor.start();
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        monitor.stop();
    }
}

@Slf4j(topic = "Monitor")
class Monitor {
    private static volatile boolean stop = false;

    public void start() {
        new Thread(() -> {
            while (true) {
                if (stop) {
                    break;
                }
            }
            log.info("jieshu");
        }, "t").start();
    }

    public void stop() {
        stop = true;
    }
}
```



##### 模式之 Balking (了解)

- 定义：`Balking （犹豫）模式`用在 **`一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回`。有点类似于单例。**

```
package com.current.demo;

import lombok.extern.slf4j.Slf4j;

/**
 * @program: threadDemo
 * @description: 模式之 Balking (了解)
 * @author: mengjianglong@e6yun.com
 * @create: 2021-12-07 09:56
 **/

public class Test2 {
    public static void main(String[] args) {
        Monitor1 monitor1 = new Monitor1();
        monitor1.start();
        monitor1.start();
        monitor1.start();
        try {
            Thread.sleep(3500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        monitor1.stop();
    }
}
@Slf4j(topic = "Monitor1")
class Monitor1{
    // 监控器是否退出
    private volatile boolean stop = false;
    // 监视器是否已经在运行
    private boolean it = false;
    Thread t;
    public void start(){
        synchronized (this){
            if (it) {
                log.info("监视器已经在运行中");
                return;
            }
            it = true;
        }
        t = new Thread(() -> {
            while (true) {
                if (stop) {
                    log.info("退出循环");
                    break;
                }
            }
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                log.info("被打断了");
                e.printStackTrace();
            }
        }, "t");
        t.start();
    }
    public void stop(){
        stop = true;
        t.interrupt();
    }
}
```

####  有序性 (`重点`)

$$
是JIT即时编译器的优化, 可能会导致指令重排。为什么要优化? 因为CPU 支持多级指令流水线，例如支持同时执行 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 的处理器。效率快 ~
$$

- **`JVM`会在不影响正确性的前提下**，`可以调整语句的执行顺序`, 是一种优化

![img](https://img-blog.csdnimg.cn/20201224225308100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

- 这种特性称之为`『指令重排』`, **`多线程下『指令重排』会影响正确性。`**

##### 支持流水线的处理器

现代 CPU 支持多级指令流水线，例如支持同时执行 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 的处理器，就可以称之为五级指令流水线。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一 条执行时间长的复杂指令），IPC = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地吞吐率。
![img](https://img-blog.csdnimg.cn/20201224232242688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

**在多线程环境下，指令重排序可能导致出现意料之外的结果**

##### 诡异的结果

```
int num = 0;

// volatile 修饰的变量，可以禁用指令重排 volatile boolean ready = false; 可以防止变量之前的代码被重排序
boolean ready = false; 

// 线程1 执行此方法
public void actor1(I_Result r) {
	 if(ready) {
	 	r.r1 = num + num;
	 } 
	 else {
	 	r.r1 = 1;
	 }
}
// 线程2 执行此方法
public void actor2(I_Result r) {
	 num = 2;
	 ready = true;
}
```

线程1执行actor1方法, 线程2执行actor2方法

- I_Result 是一个对象，有一个属性 r1 用来保存结果，问可能的结果有几种？
  - 情况1：线程1 先执行，这时 ready = false，所以进入 else 分支结果为 `1`
  - 情况2：线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支，结果为`1`
  - 情况3：线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为`4`（因为 num 已经执行过了）
  - 但是结果还有可能是 0 ，这种情况下是：**`线程2 执行 ready = true，切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行 num = 2。`**

- 这种现象叫做指令重排，是JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现，可以使用jcstress工具进行测试。上面仅是从代码层面体现出了有序性问题，下面在讲到 double-checked locking (双重检查锁)问题时还会从java字节码的层面了解有序性的问题

```
@JCStressTest
@Outcome(id = {"1", "4"}, expect = Expect.ACCEPTABLE, desc = "ok")
@Outcome(id = "0", expect = Expect.ACCEPTABLE_INTERESTING, desc = "!!!!")
@State
public class ConcurrencyTest {

    int num = 0;
    //boolean ready = false;
    volatile boolean ready = false; // 不会发生指令重排,也就不会出现结果为0的情况
    @Actor
    public void actor1(I_Result r) {
        if(ready) {
            r.r1 = num + num;
        } else {
            r.r1 = 1;
        }
    }

    @Actor
    public void actor2(I_Result r) {
        num = 2;
        ready = true;
    }
}
```

![img](https://img-blog.csdnimg.cn/20201224234756734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20201224234810568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

##### **重排序也需要遵守一定规则**

- `指令重排序操作`不会对存在`数据依赖关系的操作`进行重排序。比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。
- 重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变。 比如：a=1;b=2;c=a+b这三个操作，第一步（a=1)和第二步(b=2)由于不存在数据依赖关系，所以可能会发生重排序，但是c=a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。

**`指令重排序 在 单线程模式下是一定会保证最终结果的正确性`，** 但是在多线程环境下，问题就出来了。

- **解决方法：`volatile 修饰的变量，可以禁用指令重排`**

$$
注意：

使用synchronized并不能解决有序性问题，但是如果是该变量整个都在synchronized代码块的保护范围内，那么变量就不会被多个线程同时操作，也不用考虑有序性问题！在这种情况下相当于解决了重排序问题！
参考下面double-checked locking 问题里的代码，第一个代码片段中的instance变量都在synchronized代码块中，第二个代码片段中instance不全在synchronized中所以产生了问题。
$$



### volatile 原理 (`重点`)

- volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence）

-   对 volatile 变量的写指令后会加入写屏障。(保证写屏障之前的写操作, 都能同步到主存中)

-   对 volatile 变量的读指令前会加入读屏障。(保证读屏障之后的读操作, 都能读到主存的数据)

### volatile是如何保证可见性 (`重点`)

- **`写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中`**

```
public void actor2(I_Result r) {
     num = 2;
     ready = true; // ready是被volatile修饰的 ，赋值带写屏障
     // 写屏障.(在ready=true写指令之后加的, 
     //在该屏障之前对共享变量的改动, 都同步到主存中. 包括num)
}
```

- **`读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据`**

```
public void actor1(I_Result r) {
	 // 读屏障
	 //  ready是被volatile修饰的 ，读取值带读屏障
	 if(ready) {	// ready, 读取的就是主存中的新值
	 	r.r1 = num + num; // num, 读取的也是主存中的新值
	 } else {
	 	r.r1 = 1;
	 }
}
```



![img](https://img-blog.csdnimg.cn/img_convert/b17feb2d8cc0907ddee8b08949a44d0d.png)



### volatile是如何保证有序性

- `写屏障`会确保**指令重排序**时，**不会将写屏障之前的代码排在写屏障之后**

```
public void actor2(I_Result r) {
 num = 2;
 ready = true; //  ready是被volatile修饰的 ， 赋值带写屏障
 // 写屏障
}
```

- 读屏障会确保指令重排序时，**不会将读屏障之后的代码排在读屏障之前**

```
public void actor1(I_Result r) {
	 // 读屏障
	 //  ready是被volatile修饰的 ，读取值带读屏障
	 if(ready) {
	 	r.r1 = num + num;
	 } else {
	 	r.r1 = 1;
	 }
}
```

![img](https://img-blog.csdnimg.cn/img_convert/98518f6441a448a9a6ef441ef2518c83.png)



volatile不能解决指令交错 (不能解决原子性)：

- `写屏障仅仅是保证之后的读能够读到最新的结果`，但不能保证其它线程的读, 跑到它前面去
- **`有序性的保证也只是保证了本线程内相关代码不被重排序`**
- 下图t2线程, 就先读取了i=0, 此时还是会出现指令交错的现象, 可以使用`synchronized`来解决原子性

![img](https://img-blog.csdnimg.cn/img_convert/1e8fff6923548db93e27ac4a947633e9.png)

### double-checked locking (双重检查锁) 问题 (`重点`)

$$
首先synchronized可以保证它的临界区的资源是 原子性、可见性、有序性的, 有序性的前提是, 在synchronized代码块中的共享变量, 不会在代码块外使用到, 否则有序性不能被保证, 只能使用volatile来保证有序性
下面代码的第二个双重检查单例, 就出现了这个问题(在synchronized外使用到了INSTANCE), 此时synchronized就不能防止指令重排, 确保不了指令的有序性.
$$

- 以著名的`double-checked locking(双重检查锁) 单例模式`为例，这是volatile最常使用的地方。

```
package com.current.demo;

/**
 * @program: threadDemo
 * @description: 测试单例
 * @author: mengjianglong@e6yun.com
 * @create: 2021-12-09 10:55
 **/

public class SingletonTest {
}
final class Singleton1{
    private static Singleton1 INSTANCE = null;
    private static Singleton1 getInstance(){
        /*
        * 由此地可以看出每次调用getInstance（）方法去获取单例对象的时候，需要给每个线程加锁一个就是性能问题。
        * 第二个就是保证不了线程安全问题，如果有两个线程同时去调用getInstance（）方法，有可能会发生两个线程取到的INSTANCE都为null
        * 这样会导致INSTANCE = new Singleton1();执行两次，背离了我们单例的宗旨
        * */
        synchronized (Singleton1.class){
            if (INSTANCE == null) {
                INSTANCE = new Singleton1();
            }
        }
        return INSTANCE;
    }

}
final class Singleton2{
    private static Singleton2 INSTANCE = null;
    private static Singleton2 getInstance(){
        /*
        * 下面代码针对上面做出部分优化，对于上述中说到的每个线程都要获取对象锁，下面就保证了只有当INSTANCE为空的时候才会去获取锁
        * 但是他仍然保证不了线程安全的问题，有可能还会发生指令重排等问题
        * */
        if (INSTANCE == null) {
            synchronized (Singleton2.class){
                INSTANCE = new Singleton2();
            }
        }
        return INSTANCE;
    }
}
```

以上的实现特点是：

- 有隐含的: 但很关键的一点：`第一个 if 使用了 INSTANCE 变量，是在同步块之外`, 这样会导致`synchronized`无法保证指令的`有序性`, 此时可能会导致`指令重排`问题
- 懒汉式单例
- 首次使用 getInstance() 才使用 synchronized 加锁，**后续使用时无需加锁 (也就是上面的第二个单例)**

注意: 但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为

```
0: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
3: ifnonnull 37 // 判断是否为空
// ldc是获得类对象
6: ldc #3 // class cn/itcast/n5/Singleton
// 复制操作数栈栈顶的值放入栈顶, 将类对象的引用地址复制了一份
8: dup
// 操作数栈栈顶的值弹出，即将对象的引用地址存到局部变量表中
// 将类对象的引用地址存储了一份，是为了将来解锁用
9: astore_0
10: monitorenter
11: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
14: ifnonnull 27
// 新建一个实例
17 表示创建对象，将对象引用入栈 // new Singleton
17: new #3 // class cn/itcast/n5/Singleton
// 复制了一个实例的引用
20 表示复制一份对象引用 // 复制了引用地址, 解锁使用
20: dup
// 通过这个复制的引用调用它的构造方法
21 表示利用一个对象引用，调用构造方法 // 根据复制的引用地址调用构造方法
21: invokespecial #4 // Method "<init>":()V
// 最开始的这个引用用来进行赋值操作
24 表示利用一个对象引用，赋值给 static INSTANCE
24: putstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
27: aload_0
28: monitorexit
29: goto 37
32: astore_1
33: aload_0
34: monitorexit
35: aload_1
36: athrow
37: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
40: areturn
```

可能jvm 会优化为：`先执行 24(赋值)，再执行 21(构造方法)`。如果两个线程 t1，t2 按如下时间序列执行：

- 通过上面的字节码发现, 这一步`INSTANCE = new Singleton();`操作不是一个`原子操作`, 它分为`21, 24两个指令`, 此时可能就会发生`指令重排`的问题

![img](https://img-blog.csdnimg.cn/img_convert/702a41b984561f85cab618621b824079.png)

- 注意在 JDK 5 以上的版本的 volatile 才会真正有效
- 关键在于 `0: getstatic` 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取 INSTANCE 变量的值
- 这时 `t1 还未完全将构造方法`执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例 **对 INSTANCE 使用 volatile 修饰**即可，可以`禁用指令重排。`

```
final class Singleton3{
    private static volatile Singleton3 INSTANCE = null;
    private static Singleton3 getInstance(){
        /*
         * volatile修饰后的INSTANCE因为加入了内存屏障
         * 
         * INSTANCE = new Singleton3();
         * */
        if (INSTANCE == null) {
            synchronized (Singleton3.class){
                INSTANCE = new Singleton3();
            }
        }
        return INSTANCE;
    }
}
```

- 如上面的注释内容所示，**`读写 volatile 变量操作（即getstatic操作和putstatic操作）时会加入内存屏障（Memory Barrier（Memory Fence））`**，保证下面两点：

可见性
写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中
读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据
有序性
写屏障 会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后
读屏障 会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前
**更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性**

加上`volatile`之后, 保证了`指令的有序性`, 不会发生指令重排, 21就不会跑到24之后执行了

![img](https://img-blog.csdnimg.cn/img_convert/dd32cd4090a29b5dbd4c6a0bd8945187.png)

- synchronized 既能保证原子性、可见性、有序性，其中有序性是在该共享变量完全被synchronized 所接管（包括共享变量的读写操作），上面的例子中synchronized 外面的 if (INSTANCE == null) 中的INSTANCE读操作没有被synchronized 接管，因此无法保证INSTANCE共享变量的有序性（即不能防止指令重排）。
- 对共享变量加`volatile`关键字可以保证`可见性`和`有序性`，但是**不能保证原子性**（即不能防止指令交错）。

- `volatile`主要用在`一个线程改,多个线程读时的来保证可见性`，和`double-checked locking模式中保证synchronized代码块外的共享变量的`指令重排序`问题`

### balking 模式习题

希望 **Init() 方法仅被调用一次**
$$
双重校验模式解决此练习首先由volatile保证临界区的可见性和有序性，再由synchronzied保证原子性（主要是为了保证多线程下的上下文切换问题）
$$

```
package com.current.demo;

import lombok.extern.slf4j.Slf4j;

/**
 * @program: threadDemo
 * @description: 练习：保证init方法执行一次
 * @author: mengjianglong@e6yun.com
 * @create: 2021-12-10 09:29
 **/
@Slf4j(topic = "BigRoomTest")
public class BigRoomTest {
    private static volatile boolean isNo = false;
    final static Object obj = new Object();
    public static void main(String[] args) {
        new Thread(()->{
            doInit();
        }).start();

        new Thread(()->{
            doInit();
        }).start();
    }
    static void doInit(){
        synchronized (obj){
            if (isNo) {
                return;
            }
            init();
            isNo = true;
        }

    }
    static void init(){
        log.info("执行一次");
    }
}
```

### 线程安全单例模式 (`重点`)

-  单例模式有很多实现方法，`饿汉、懒汉、静态内部类、枚举类`，试分析每种实现下获取单例对象（即调用 getInstance）时的线程安全，并思考注释中的问题
  - `饿汉式`：**类加载就会导致该单实例对象被创建**
  - `懒汉式`：**类加载不会导致该单实例对象被创建，而是`首次使用该对象时才会创建`**

`饿汉式`：

```
package com.current.demo;

import java.io.Serializable;

/**
 * @program: threadDemo
 * @description: 饿汉
 * @author: mengjianglong@e6yun.com
 * @create: 2021-12-10 09:53
 **/
/**
* 使用final防止子类继承后对它进行更改
* 如果实现了序列化接口, 反序列化会破坏单例，如果进行反序列化的时候会生成新的对象，这样跟单例模式生成的对象是不同的。要解决直接加上readResolve()方法就行了，如下所示
* */
public final class Singleton implements Serializable {
    /*
    private防止使用new进行该对象的创建
    * */
    private Singleton() {}

    /**
     * 初始化的时候，由jvm进行初始化该类对象，不存在线程安全问题
     */
    private static final Singleton INSTANCE  = new Singleton();
    /*
    统一的接口获取该单例对象
    */
    public static Singleton getInstance(){
        return INSTANCE;
    }
    public Object readResolve(){
        return INSTANCE;
    }
}
```



`懒汉式`：

```
package com.current.demo;

import java.util.Objects;

/**
 * @program: threadDemo
 * @description: 懒汉方式1:锁的范围太广，导致效率降低
 * @author: mengjianglong@e6yun.com
 * @create: 2021-12-10 10:18
 **/

public class SingletonLH {
    // 防止通过new去创建SingletonLH
    private SingletonLH(){}
    private static SingletonLH INSTANCE = null;
    public static synchronized SingletonLH getInstance(){
        if (Objects.isNull(INSTANCE)) {
            INSTANCE = new SingletonLH();
        }
        return INSTANCE;
    }
}
/**
 * @program: threadDemo
 * @description: 懒汉方式2:双重检验模式
 * @author: mengjianglong@e6yun.com
 * @create: 2021-12-10 10:18
 **/
class SingletonLH2{
    private SingletonLH2(){}
    private static volatile SingletonLH2 INSTANCE = null;
    public static SingletonLH2 getInstance(){
        if (Objects.nonNull(INSTANCE)) {
            return INSTANCE;
        }

        synchronized (SingletonLH2.class){
            if (Objects.isNull(INSTANCE)) {
                INSTANCE = new SingletonLH2();
            }
            return INSTANCE;
        }
    }
}
```











#### CPU多核硬件架构剖析

#### jmm八大同步的规范



### Volatile缓存一致性协议

#### 总线锁

#### MESI协议



### 伪共享的问题

#### 缓存行基本的概念

#### 存行填充方案

### 重排序/内存屏障/双重检验锁为什么需要加上volatile

### synchronized 与volatile存在的区别

### 为什么Volatile不能保证原子性



## synchronized原理



### 锁池/等待池/Monitor监视器锁/对象头原理

#### Java 对象头

java的对象头信息主要包含两部分：

- 运行时元数据

```
1、hashCode 主要是对堆内存中的对象地址进行存储
2、GC的分代计数器 以15为阈值，分为新生代和老年代
3、锁状态的标识 轻量级锁
4、偏向线程ID 偏向锁
5、线程持有锁
6、偏向时间戳
```

- 类型指针

```
类元数据InstanceKlass，确定该对象所属的类型。指向的其实是方法区中存放的类元信息
如果是数组还会记录数组的长度
```

- 以 32 位虚拟机为例,普通对象的对象头结构如下，其中的`Klass Word`为`类型指针`，指向`方法区`对应的`Class对象`；

![img](https://img-blog.csdnimg.cn/img_convert/ac7274e0d0dbe8c8b25f43f2aa1ed1d6.png)

- 数组对象

![img](https://img-blog.csdnimg.cn/img_convert/52c45594819f30fb8a9d6087682be254.png)

- **其中 Mark Word 结构为: `无锁(001)、偏向锁(101)、轻量级锁(00)、重量级锁(10)`**

![img](https://img-blog.csdnimg.cn/img_convert/0ffaeb7ddf7d71801bfd3eeb00754162.png)

- 所以一个对象的结构如下：

![img](https://img-blog.csdnimg.cn/img_convert/1844b5e3159baa3c8fb78478daa1580b.png)

#### Monitor锁

monitor简称监视器或管程。

每个java对象，在执行到Synschronized的时候会关联到操作系统的Monitor对象。也就是使用Synschronized给对象上锁时，对象的mark word会指向Monitor。

```
当Thread1访问到synchronized(obj)中的共享资源的时候
首先会将synchronized中的锁对象中对象头的MarkWord去尝试指向操作系统的Monitor对象. 让锁对象中的MarkWord和Monitor对象相关联. 如果关联成功, 将obj对象头中的MarkWord的对象状态从01改为10。
因为Monitor没有和其他的obj的MarkWord相关联, 所以Thread1就成为了该Monitor的Owner(所有者)。
又来了个Thread1执行synchronized(obj)代码, 它首先会看看能不能执行该临界区的代码; 它会检查obj是否关联了Montior, 此时已经有关联了, 它就会去看看该Montior有没有所有者(Owner), 发现有所有者了(Thread2); Thread1也会和该Monitor关联, 该线程就会进入到它的EntryList(阻塞队列);
当Thread2执行完临界区代码后, Monitor的Owner(所有者)就空出来了. 此时就会通知Monitor中的EntryList阻塞队列中的线程, 这些线程通过竞争, 成为新的所有者
```

![img](https://img-blog.csdnimg.cn/20201219192811839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

- 刚开始时`Monitor`中的`Owner为null`
- **当Thread-2 执行synchronized(obj){}代码时就会将Monitor的所有者Owner 设置为 Thread-2，上锁成功，Monitor中同一时刻只能有一个Owner**
- 当Thread-2 占据锁时，如果线程Thread-3，Thread-4也来执行synchronized(obj){}代码，就会进入`EntryList`中变成`BLOCKED状态`
- **Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，`竞争时是非公平的 (仍然是抢占式)`**
- `图中 WaitSet 中的Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲wait-notify 时会分析`

- 它加锁就是依赖底层操作系统的 `mutex`相关指令实现, 所以会造成`用户态和内核态之间的切换`, 非常耗性能 !

- 在JDK6的时候, 对synchronized进行了优化, 引入了`轻量级锁, 偏向锁`, 它们是在JVM的层面上进行加锁逻辑, 就没有了切换的消耗~



### Synschronized内置锁实现原理

### 站在C++源码如何分析Synchronized原理

### Synchronized锁膨胀过程原理分析



### 偏向锁/轻量锁/自旋锁/重量锁

#### 轻量级锁 (用于优化Monitor这类的重量级锁）

- 场景

```
如果一个对象有很多线程去访问，但多线程访问的时间时错开的，就可以使用轻量级锁优化。语法任然是Synchronized
```

```
static final Object obj = new Object();
public static void method1() {
     synchronized( obj ) {
         // 同步块 A
         method2();
     }
}
public static void method2() {
     synchronized( obj ) {
         // 同步块 B
     }
}
```

 

- 每次指向到`synchronized代码块`时，都会在`栈帧中`创建`锁记录（Lock Record）对象`，**`每个线程都会包括一个锁记录的结构`**，锁记录内部可以储存`对象的MarkWord`和`锁对象引用reference`

![img](https://img-blog.csdnimg.cn/img_convert/4d42844c6ddc19a6f94d954ae5a0cc79.png)

- 让锁记录中的Object reference指向锁对象地址，并且尝试用CAS(compare and sweep)将栈帧中的锁记录的(lock record 地址 00)替换Object对象的Mark Word，将Mark Word 的值(01)存入锁记录(lock record地址)中 ------相互替换
  01 表示 无锁 (看Mark Word结构, 数字的含义)
  00表示 轻量级锁
  ![img](https://img-blog.csdnimg.cn/img_convert/87f63c5373eed35d0bf65e0b510a7660.png)

重点:

- 如果cas替换成功, 获得了轻量级锁，那么对象的对象头储存的就是锁记录的地址和状态00，如下所示
  线程中锁记录, 记录了锁对象的锁状态标志; 锁对象的对象头中存储了锁记录的地址和状态, 标志哪个线程获得了锁
  此时栈帧中存储了对象的对象头中的锁状态标志,年龄计数器,哈希值等; 对象的对象头中就存储了栈帧中锁记录的地址和状态00, 这样的话对象就知道了是哪个线程锁住自己。

![img](https://img-blog.csdnimg.cn/img_convert/68c40cfc17498b1514fe31af8a896eaf.png)



- 如果cas替换失败，有两种情况 : ① 锁膨胀 ② 重入锁失败
  1、如果是其它线程已经持有了该Object的轻量级锁，那么表示有竞争，将进入 锁膨胀阶段
  此时对象Object对象头中已经存储了别的线程的锁记录地址 00,指向了其他线程;
  2、如果是自己的线程已经执行了synchronized进行加锁，那么再添加一条 Lock Record 作为重入锁的计数 – 线程多次加锁, 锁重入
  在上面代码中,临界区中又调用了method2, method2中又进行了一次synchronized加锁操作, 此时就会在虚拟机栈中再开辟一个method2方法对应的栈帧(栈顶), 该栈帧中又会存在一个独立的Lock Record, 此时它发现对象的对象头中指向的就是自己线程中栈帧的锁记录; 加锁也就失败了. 这种现象就叫做锁重入; 线程中有多少个锁记录, 就能表明该线程对这个对象加了几次锁 (锁重入计数)
  ![img](https://img-blog.csdnimg.cn/img_convert/9e36f456637862001c9c58ded2651a3b.png)

#### 锁膨胀

- 在添加轻量级锁的时候，CAS替换操作无法成功。这种情况就是其他线程已经为这个对象加上了轻量级锁，这时有另一个线程再去给对象加锁时会发生锁膨胀，将轻量级锁变为重量级锁。

- 当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁, 此时发生`锁膨胀`

![img](https://img-blog.csdnimg.cn/img_convert/c3e0a92d418c70280fd2a0bb730eea82.png)

- 这时Thread-1加轻量级锁失败，进入锁膨胀流程
  因为Thread-1线程加轻量级锁失败, 轻量级锁没有阻塞队列的概念, 所以此时就要为对象申请Monitor锁(重量级锁)，让Object指向重量级锁地址 10，然后自己进入Monitor 的EntryList 变成BLOCKED状态

![img](https://img-blog.csdnimg.cn/20201219214748700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

- 当Thread-0 线程执行完synchronized同步块时，使用cas将Mark Word的值恢复给对象头, 肯定恢复失败,因为对象的对象头中存储的是重量级锁的地址,状态变为10了之前的是00, 肯定恢复失败。那么会进入重量级锁的解锁过程，即按照Monitor的地址找到Monitor对象，将Owner设置为null，唤醒EntryList中的Thread-1线程

#### 自旋锁优化 (优化重量级锁竞争)

- 当发生重量级锁竞争的时候，还可以使用自旋来进行优化 (不加入Monitor的阻塞队列EntryList中)，如果当前线程自旋成功（即在自旋的时候持锁的线程释放了锁），那么当前线程就可以不用进行上下文切换(持锁线程执行完synchronized同步块后,释放锁,Owner为空,唤醒阻塞队列来竞争,胜出的线程得到cpu执行权的过程) 就获得了锁

- 优化的点: 不用将线程加入到阻塞队列, 减少cpu切换.

1. 自旋重试成功的情况

![img](https://img-blog.csdnimg.cn/img_convert/39ed180b2ab7eae1bc37ebba0a819c4c.png)

1. `旋重试失败的情况`，**自旋了一定次数还是没有等到 持锁的线程释放锁**, 线程2就会加入Monitor的阻塞队列(EntryList)

![img](https://img-blog.csdnimg.cn/img_convert/36162c78749df99fcd83560e3896aef0.png)

- 自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。

- 在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。Java 7 之后不能控制是否开启自旋功能



#### 偏向锁 (biased lock) (用于优化轻量级锁重入)

- 场景

```
没有竞争的时候，一个线程多次使用synchronized需要进行锁重入。因此jvm对其进行了优化，会将mark Work设置为线程的id，这样就避免了多次CAS操作进而节省运行成本。偏向锁是默认开启的, 我们可以通过JVM的配置, 将偏向锁给关闭
```

- 在轻量级的锁中，我们可以发现，如果同一个线程对同一个对象进行重入锁时，也需要执行CAS替换操作，这是有点耗时。

- 那么java6开始引入了偏向锁，将进入临界区的线程的ID, 直接设置给锁对象的Mark word, 下次该线程又获取锁, 发现线程ID是自己, 就不需要CAS了

- 升级为轻量级锁的情况 (会进行偏向锁撤销) : 获取偏向锁的时候, 发现线程ID不是自己的, 此时通过CAS替换操作, 操作成功了, 此时该线程就获得了锁对象。( 此时是交替访问临界区, 撤销偏向锁, 升级为轻量级锁)

- 升级为重量级锁的情况 (会进行偏向锁撤销) : 获取偏向锁的时候, 发现线程ID不是自己的, 此时通过CAS替换操作, 操作失败了, 此时说明发生了锁竞争。( 此时是多线程访问临界区, 撤销偏向锁, 升级为重量级锁)

```
public class Test {
    static final Object obj = new Object();

    public static void m1() {
        synchronized (obj) {
            // 同步块A
            m2();
        }
    }

    public static void m2() {
        synchronized (obj) {
            // 同步块B
            m3();
        }
    }

    public static void m3() {
        synchronized (obj) {
            // 同步块C
        }
    }
}
```

![img](https://img-blog.csdnimg.cn/20201219223917148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20201219223934280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

- 偏向锁的使用

`偏向锁默认是延迟`的，不会在程序启动的时候立刻生效，如果想避免延迟，可以添加虚拟机参数来禁用延迟：**`-XX:BiasedLockingStartupDelay=0`来禁用延迟**

- 禁止偏向锁, 虚拟机参数`-XX:-UseBiasedLocking`; 优先使用`轻量级锁`

- hashCode会撤销偏向锁

- **偏向锁、轻量级锁的使用条件, 都是在于多个线程没有对同一个对象进行`锁竞争`的前提下, 如果有`锁竞争`,此时就使用重量级锁。**
  - **会使对象锁变成重量级锁**，因为`wait/notify方法之后重量级锁才支持`

- 加锁对象被多个线程访问，但无竞争，有可能会重新偏向。撤销偏向超过20次偏向锁会发生重新偏向，偏向的线程id为当前的拥有锁的线程。当超过40次时就会将整个类的对象都改为**不可偏向**的。









### 锁的粗化、与消除及性能优化

#### 锁消除

- 线程同步的代价是相当高的，同步的后果是降低并发性和性能。

- 在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。

- 如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。









## 并发锁的分类

### 悲观锁

### 乐观锁

### 自旋锁

### 重入锁

### 公平锁

### 非公平锁



## aqs源码解读

### AQS 原理

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210202223902808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

**`AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态`。****如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210119105644735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

特点：

- 用 `state` 属性来表示`资源的状态`（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁
  - **`getState - 获取 state 状态`**
  - **`setState - 设置 state 状态`**
  - **`compareAndSetState - cas 机制设置 state 状态`**
  - **`独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源`**
- **提供了基于 FIFO 的等待队列，类似于 `Monitor` 的 `EntryList`**
- **条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 `Monitor` 的 `WaitSet`**

子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）

- **tryAcquire**
- **tryRelease**
- **tryAcquireShared**
- **tryReleaseShared**
- **isHeldExclusively**

```
package com.current.demo;

import lombok.extern.slf4j.Slf4j;
import org.springframework.retry.backoff.Sleeper;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

/**
 * @program: threadDemo
 * @description: 使用AQS实现独占锁和共享锁
 * @author: mengjianglong@e6yun.com
 * @create: 2021-12-15 15:02
 **/
@Slf4j(topic = "TestAqs")
@SuppressWarnings("all")
public class TestAqs {
    public static void main(String[] args){
        MyLock lock = new MyLock();
        new Thread(() -> {
            lock.lock();
            log.debug("locking...");
            // 不可重入锁, 同一线程在锁释放前, 只能加一次锁
//            lock.lock();
//            log.debug("locking...");
            try {
                log.debug("locking...");
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            } finally {
                log.debug("unlocking...");
                lock.unlock();
            }
        }, "t1").start();

        new Thread(() -> {
            lock.lock();
            try {
                log.debug("locking...");
            } finally {
                log.debug("unlocking...");
                lock.unlock();
            }
        }, "t2").start();

    }
}
// 自定义锁不可重入
class MyLock implements Lock{

    // 独占锁  同步器类
    class MySync extends AbstractQueuedSynchronizer{
        @Override
        protected boolean tryAcquire(int arg) {
            if (compareAndSetState(0,1)) {
                // 加上了锁，并设置 owner 为当前线程
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        @Override
        protected boolean tryRelease(int arg) {
            // 这里不需要确定原子性, 因为是持锁者进行释放
            // 在setState(0)上面设置Owner为null, 防止指令重排序带来的问题
            setExclusiveOwnerThread(null);
            // state是volatile修饰的, 在setState(0)前面的属性修改, 对于其他线程也是可见的, 具体见volatile原理(写屏障)
            setState(0);
            return true;
        }

        @Override
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }

        public Condition newCondition() {
            return new ConditionObject();
        }
    }

    private MySync sync = new MySync();
    // 加锁（不成功会进入等待队列）
    @Override
    public void lock() {
        sync.acquire(1);
    }

    // 加锁，可打断
    @Override
    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }

    // 尝试加锁（一次）
    @Override
    public boolean tryLock() {
        return sync.tryAcquire(1);
    }

    // 尝试加锁，带超时
    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireNanos(1,unit.toNanos(time));
    }

    // 解锁
    @Override
    public void unlock() {
        sync.release(1);
    }

    // 创建条件变量
    @Override
    public Condition newCondition() {
        return sync.newCondition();
    }
}
```











### LockSupport源码解读

### AbstractQueuedSynchronizer源码解读

### ReentrantLock/ReentrantReadWriteLock、ReadWriteLock源码解读

## ReentrantReadWriteLock读写锁

$$
让读操作和写操作分开处理 ；我们读操作是不会修改数据的，所以我们提供读操作可以并发，提高效率！
$$

- 读写锁指一个资源能够被**多个读线程访问**，或者被**一个写线程访问**，但是**不能同时存在读写线程**
- ReentrantReadWriteLock中有两个静态内部类：ReadLock读锁和WriteLock写锁，这两个锁实现了Lock接口
- ReentrantReadWriteLock支持可重入，同步功能依赖自定义同步器（AbstractQueuedSynchronizer）实现，读写状态就是其同步器的同步状态

##### 写锁的获取和释放

**写锁WriteLock是支持重进入的排他锁**。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取读锁时，读锁已经被获取或者该线程不是已获取写锁的线程，则当前线程进入等待状态。**读写锁确保写锁的操作对读锁可见**。写锁释放每次减少写状态，当前写状态为0时表示写锁已背释放。

##### 读锁的获取与释放

 读锁ReadLock是支持重进入的共享锁（共享锁为shared节点，对于shared节点会进行一连串的唤醒，知道遇到一个读节点），它能够被多个线程同时获取，在没有其他写线程访问（写状态为0）时，读锁总是能够被成功地获取，而所做的也只是增加读状态（线程安全）。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已经被获取，则进入等待状态

##### 锁降级

- 锁降级指的是写锁降级成为读锁。锁降级是指**当前拥有的写锁的同时，再获取到读锁，随后释放写锁的过程**

- 读读是并发的，支持锁重入
- 读写是互斥的
- 写写是互斥的，但是支持锁重入

```
package com.current.demo;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * @program: threadDemo
 * @description: 读写锁
 * @author: mengjianglong@e6yun.com
 * @create: 2021-12-15 17:03
 **/

public class ReentrantReadWriteLockTest {
    public static void main(String[] args) {
        DataContainer dataContainer = new DataContainer();
        for (int i = 0; i < 3; i++) {
            new Thread(() -> {
                dataContainer.read();   //读
            }).start();


            new Thread(() -> {
                dataContainer.write();   //写
            }).start();
        }

        //t1.start();
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //t2.start();
    }
}
@Slf4j(topic = "DataContainer")
class DataContainer{
    private Object data;
    private ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    private ReentrantReadWriteLock.ReadLock r = readWriteLock.readLock();//读锁
    private ReentrantReadWriteLock.WriteLock w = readWriteLock.writeLock();//写锁

    public Object read(){
        log.debug("正在加读锁");
        r.lock();
        try {
            log.debug("正在读");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return data ;
        } finally {
            log.debug("读锁释放");
            r.unlock();
        }
    }
    public void write(){
        log.debug("正在加写锁");
        w.lock();

        try {
            log.debug("正在写");
        } finally {
            log.debug("写锁释放");
            w.unlock();
        }
    }
}
```

##### 读写锁再缓存上的应用

- 查询操作： 先去缓存查、再去数据库查询
- 修改操作：先清空缓存、在更新数据库数据

![img](https://img-blog.csdnimg.cn/7a9a3512c70d4d0da8df232e063485a6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54iq5rS8aW5n,size_20,color_FFFFFF,t_70,g_se,x_16)

##### 缓存更新策略

###### 如果先清缓存

![img](https://img-blog.csdnimg.cn/a07764777e7349899c58e883d6e38c52.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54iq5rS8aW5n,size_20,color_FFFFFF,t_70,g_se,x_16)

发生问题：线程B先执行修改操作，同时线程A执行查询操作，当线程B将缓存清空后，还未更新数据库，这时线程A去查询数据，先去缓存，发现缓存没有，去数据库查询，查到了并将查到的target = 1放入缓存，接着再次查询target一直就是1了，而此时线程B修改target成功，target = 2 ，线程A查询到的还时旧的数据（查询的很长一段时间都是旧的数据）！

###### 先更新数据库

![img](https://img-blog.csdnimg.cn/74ea02d107c342ca9e7bd7e6d15df8b3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54iq5rS8aW5n,size_20,color_FFFFFF,t_70,g_se,x_16)

这种情况下，线程B先行将数据库中的数据更新，还未来得及啊清空缓存，此时线程A来查询了，查询的还是之前缓存中的数据，但是很快的线程B会清空缓存，线程A再查就会发现缓存中旧数据没了，就得查数据库了，然后更新缓存！

```
为了彻底解决上述数据不一致的问题我们可以通过加锁解决 ；(虽然性能会低一些，但是解决了数据的一致性)
```

但是我们可以通过读写锁ReentrantReadWriteLock，我们可以使得性能不像其他锁一样，性能低那么多！

![、](https://img-blog.csdnimg.cn/01b3f7e5887748548185f7d134c10ec5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54iq5rS8aW5n,size_20,color_FFFFFF,t_70,g_se,x_16)

以上实现体现的是读写锁的应用，保证缓存和数据库的一致性，但有下面的问题没有考虑·

- 适合读多写少，如果写操作比较频繁，以上实现性能低
- 没有考虑缓存容量
- 没有考虑缓存过期·只适合单机
- 并发性还是低，目前只会用一把锁
- 更新方法太过简单粗暴，清空了所有key (考虑按类型分区或重新设计ke y)





### StampedLock

```
我们读写锁的可以读读并发，相对重量级锁已经很快了，但是我们每次读都会通过cas操作增加读状态，导致我们并不能进行写操作！因此我们为了进一步优化读性能，所以从JDK8k开始引入StampedLock 它的特点是在使用读锁、写锁时都必须配合【戳】使用
```

StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次 戳校验 如果校验通过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。StampedLock采取乐观获取锁后，其他线程尝试获取写锁时不会被阻塞（可以解决读写锁，锁饥饿问题）
$$
总结：引入一个戳，这个戳有一个检验的作用，如果检验出当前只有读操作，我们不加锁！
$$

#### Semaphore 信号量

```
[ˈseməfɔː ( r )] ， 设置能同时访问共享资源的线程上限

public class SemaphoreTest {
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(3); // permits : 表示许可多个线程，能同时访问共享资源,
                                                        // bool fair : 表示的是公平、非公平
        //10个线程同时运行
        for (int i = 0; i < 10 ; i++) {
            new Thread(()->{
                try {
                    semaphore.acquire();        //获得许可
                } catch (InterruptedException e) {
                    e.printStackTrace();
                
                try{
                    System.out.println("running..");
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } // sleeper(1)
                    System.out.println("end..");
                }finally {
                    semaphore.release();        //释放许可
                }
            }).start();
        }
    }
} //结论 ： 我们10个线程只有前3个启动，等3个执行结束后，接着再来3个启动
```

- 使用Semaphore限流，在访问高峰期时，让请求线程阻塞，高峰期过去再释放许可，当然它只适合限制单机线程数量，**并且仅是限制线程数，而不是限制资源数**（例如连接数，请对比Tomcat LimitLatch的实现)
- 用Semaphore 实现简单连接池，对比『享元模式』下的实现(用wait notify)，性能和可读性显然更好，注意下面的实现中线程数和数据库连接数是相等的

**场景1**：我们可以使得许可数 == 数据库连接池的大小(poolSize) ，每次获取连接就会获取许可，许可用完就不能获取链接！

一个固定长度的资源池，当池为空时，请求资源会失败。使用 `Semaphore`可以实现当池为空时，请求会阻塞，非空时解除阻塞。也可以使用`Semaphore`将任何一种容器变成有界阻塞容器

```
public class SemaphoreDemo {
    public static void main(String[] args) {
        // 创建一个无界线程池
        ExecutorService exec = Executors.newCachedThreadPool();
        // 配置只能5个线程同时访问
        final Semaphore semaphore = new Semaphore(3);
        // 模拟10个客户端访问
        for (int i = 0; i < 5; i++) {
            int num = i;
            Runnable task = (() ->{
                try {
                    // 获取许可
                    semaphore.acquire();
                    System.out.println("获得许可: " + num);
                    //休眠随机秒(表示正在执行操作)
                    TimeUnit.SECONDS.sleep((int)(Math.random()*10+1));
                    // 访问完后，释放许可
                    semaphore.release();
                    // availablePermits()指还剩多少个许可
                    System.out.println("----------当前还有多少个许可:" + semaphore.availablePermits());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
            exec.execute(task);
        }
        // 退出线程池
        exec.shutdown();
    }
}
```

刚开始，permits (state)为3，这时5个线程来获取资源

![img](https://img-blog.csdnimg.cn/ae1226a078af4d01882276355922420b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54iq5rS8aW5n,size_20,color_FFFFFF,t_70,g_se,x_16)





### CountdownLatch倒计时锁

$$
我们创建一个倒计时锁，初始化一个值，表示等待值，每有一个线程访问，我们值就减去1，减到0后，等待结束
$$

```
public class CountdownLatchTest {
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(3);
        //三个线程启动
        new Thread(()->{
            System.out.println(Thread.currentThread().getName() + "开始执行！");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            countDownLatch.countDown();
            System.out.println(Thread.currentThread().getName()+ "结束执行！");
        }).start();
        new Thread(()->{
            System.out.println(Thread.currentThread().getName() + "开始执行！");
            try {
                Thread.sleep(1500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            countDownLatch.countDown();
            System.out.println(Thread.currentThread().getName()+ "结束执行！");
        }).start();
        new Thread(()->{
            System.out.println(Thread.currentThread().getName() + "开始执行！");
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            countDownLatch.countDown();
            System.out.println(Thread.currentThread().getName()+ "结束执行！");
        }).start();

        countDownLatch.await(); // 一主线程陷入等待，直到count减为0了为止！
        System.out.println("主线程可以运行！");
    }
}
```

- 我们之前学过join，也可以完成，但是join属于底层API使用起来相对繁琐。而且对于使用线程池中的线程，就不能使用join等待线程结束了，程池中的线程一直运行，基本不会结束！所以就永远等不完 hh

#### CycliBarrier

$$
循环栅栏，用来解决CountdownLatch无法解决的重复利用倒计时锁问题！
$$

CyclicBarrier也叫同步屏障，CyclicBarrier可以协同多个线程，让多个线程在这个屏障前等待，直到所有线程都达到了这个屏障时，再一起继续执行后面的动作。构造时设置『计数个数』，每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，等待数+1，当等待的线程数满足『计数个数』时，继续执行
区别：CycliBarrier根CountdownLatch大体相似，但是我们的后者一旦初始化倒计时就不可更改，而我们的的前者可以恢复如初！

- CountDownLatch：一个或者多个线程，**等待其他多个线程完成某件事情之后才能执行**；
- CyclicBarrier：多个线程互相等待，直到到达同一个同步点，再继续**一起执行**。而且可以重用

CountDownLatch是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而CyclicBarrier更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。

```
public class TestCyclicBarrier {

    public static void main(String[] args) {
        ExecutorService service = Executors.newFixedThreadPool(2);
        
        // 注意：线程数和CyclicBarrier的计数相同才会到达预期的效果
        CyclicBarrier barrier = new CyclicBarrier(2, ()-> {
            log.debug("task1, task2 finish...");
        });// 可以重复被使用，当计数变为0之后，会重新恢复为2
        
        for (int i = 0; i < 3; i++) { // task1  task2  task1
            service.submit(() -> {
                log.debug("task1 begin...");
                sleep(1);
                try {
                    barrier.await(); // 2-1=1
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
            });
            service.submit(() -> {
                log.debug("task2 begin...");
                sleep(2);
                try {
                    barrier.await(); // 1-1=0
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
            });
        }  
        service.shutdown();
    }
}
```



### ReentrantLock 

- 支持锁重入

- 可重入锁是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此 有权利再次获取这把锁

- 可中断

- lock.lockInterruptibly() : 可以被其他线程打断的中断锁

- 可以设置超时时间

- lock.tryLock(时间) : 尝试获取锁对象, 如果超过了设置的时间, 还没有获取到锁, 此时就退出阻塞队列, 并释放掉自己拥有的锁

- 可以设置为公平锁

- (先到先得) 默认是非公平, true为公平 new ReentrantLock(true)

- 支持多个条件变量( 有多个waitset)

- (可避免虚假唤醒) - lock.newCondition()创建条件变量对象; 通过条件变量对象调用 await/signal方法, 等待/唤醒
  **基本语法**

```
//获取ReentrantLock对象
private ReentrantLock lock = new ReentrantLock();
//加锁
lock.lock();
try {
	//需要执行的代码
}finally {
	//释放锁
	lock.unlock();
}
```

##### 原理

- ReentrantLock提供了两个同步器，实现`公平锁`和`非公平锁`，默认是非公平锁！

![1595043973690](https://img-blog.csdnimg.cn/img_convert/14f43b7a0fa8b979b9101ab5170398cc.png)

##### 图解流程

- `加锁, 解锁`流程，先从构造器开始看，默认为非公平锁实现

```
/**
     * Creates an instance of {@code ReentrantLock}.
     * This is equivalent to using {@code ReentrantLock(false)}.
     */
    public ReentrantLock() {
        sync = new NonfairSync();
    }
```

从后台发现NonfairSync extends Sync extends AbstractQueuedSynchronizer

没有竞争时

- Thread-0成为锁的持有者

![1595045253140](https://img-blog.csdnimg.cn/img_convert/5ed1f22fcfc9dda5a8b3b1cc737f2bb5.png)

- 第一个竞争出现时，查看源码的`NonfairSync`的`lock`方法

![1595045270516](https://img-blog.csdnimg.cn/img_convert/07d53face5cb7d27d43a9b8dbee38820.png)

```
abstract void lock();

// 非公平锁的lock
final void lock() {
    if (compareAndSetState(0, 1))
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}

public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

Thread-1 执行了

1. **lock方法中CAS 尝试将 state 由 0 改为 1，结果失败 (因为此时CAS操作, 已经state已经为1了)**
2. lock方法中进一步调用`acquire`方法，进入 `tryAcquire` 逻辑，这里我们认为这时 state 已经是1，结果仍然失败
3. 接下来进入 acquire方法的`addWaiter` 逻辑，构造 `Node 队列 (双向链表实现)`
   1. 下图中`黄色三角`表示该 Node 的`waitStatus`状态，其中 0 为默认正常状态
   2. Node 的创建是懒惰的
   3. **其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程**

![1595045451872](https://img-blog.csdnimg.cn/img_convert/be834858592889523943183e15acfa58.png)

当前线程进入 acquire方法的 `acquireQueued` 逻辑

1. acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 `park` 阻塞
2. 如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，我们这里设置这时 state 仍为 1，失败
3. 进入 `shouldParkAfterFailedAcquire` 逻辑，将`前驱 node`，即 head 的 waitStatus 改为 `-1`，这次返回 false

![1595046768331](https://img-blog.csdnimg.cn/img_convert/d66b53fa0c1ecaffa3fae6580c846292.png)4.shouldParkAfterFailedAcquire 执行完毕回到 `acquireQueued` ，再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败

5.当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true

6.进入`parkAndCheckInterrupt`， Thread-1 `park`（灰色表示已经阻塞）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210105234001801.png)

![1595046786213](https://img-blog.csdnimg.cn/img_convert/844a2077a9096fed80b31ae91e8e8c13.png)

- 再次有多个线程经历上述过程竞争失败，变成这个样子

![1595046803755](https://img-blog.csdnimg.cn/img_convert/c673a02e84847dd8e7fbef4944863a5f.png)

Thread-0 调用`unlock方法`里的`release方法`释放锁，进入`tryRelease(使用ctrl+alt+b查看tryRelease方法的具体`ReentrantLock`实现)`流程，如果成功，**设置 exclusiveOwnerThread 为 null，state = 0**

![1595046828330](https://img-blog.csdnimg.cn/img_convert/674d24535dcb379439c6105468bcb72b.png)

unlock方法里的release方法中，如果当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程：

**`unparkSuccessor中会找到队列中离 head 最近的一个 Node（没取消的），unpark 唤醒Thread-1 恢复其运行`**，本例中即为 Thread-1 回到 Thread-1 阻塞的位置继续执行, 会继续执行 acquireQueued 流程

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210105235033126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

![1595046840247](https://img-blog.csdnimg.cn/img_convert/0c4dd83170dbced9979e3c0a5b7cc69c.png)

**如果加锁成功（没有竞争）**，会设置 （acquireQueued 方法中）

1. exclusiveOwnerThread 为 Thread-1，state = 1
2. head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread
3. 原本的 head 因为从链表断开，而可被垃圾回收

**如果这时候有其它线程来竞争（非公平的体现）**，例如这时有 Thread-4 来了

![1595046854757](https://img-blog.csdnimg.cn/img_convert/990731fe3d516c3947623aeba1a356d3.png)

如果不巧又被 Thread-4 占了先

1. Thread-4 被设置为 exclusiveOwnerThread，state = 1
2. `Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞`

##### `加锁`源码

```
// Sync 继承自 AQS
static final class NonfairSync extends Sync {
    private static final long serialVersionUID = 7316153563782823691L;

     // 加锁实现
    final void lock() {
        // 首先用 cas 尝试（仅尝试一次）将 state 从 0 改为 1, 如果成功表示获得了独占锁
        if (compareAndSetState(0, 1))
            setExclusiveOwnerThread(Thread.currentThread());
        else
            // 如果尝试失败，进入 ㈠
            acquire(1);
    }

    // ㈠ AQS 继承过来的方法, 方便阅读, 放在此处
    public final void acquire(int arg) {
        // ㈡ tryAcquire
        if (
                !tryAcquire(arg) &&
            	// 当 tryAcquire 返回为 false 时, 先调用 addWaiter ㈣, 接着 acquireQueued ㈤
                 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)
        ) {
            selfInterrupt();
        }
    }

    // ㈡ 进入 ㈢
    protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);
    }

    // ㈢ Sync 继承过来的方法, 方便阅读, 放在此处
    final boolean nonfairTryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        // 如果还没有获得锁
        if (c == 0) {
            // 尝试用 cas 获得, 这里体现了非公平性: 不去检查 AQS 队列
            if (compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        // 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入
        else if (current == getExclusiveOwnerThread()) {
            // state++
            int nextc = c + acquires;
            if (nextc < 0) // overflow
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        // 获取失败, 回到调用处
        return false;
    }

    // ㈣ AQS 继承过来的方法, 方便阅读, 放在此处
    private Node addWaiter(Node mode) {
// 将当前线程关联到一个 Node 对象上, 模式为独占模式，新建的Node的waitstatus默认为0，因为waitstatus是成员变量，默认被初始化为0
        Node node = new Node(Thread.currentThread(), mode);
        // 如果 tail 不为 null, cas 尝试将 Node 对象加入 AQS 队列尾部
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                // 双向链表
                pred.next = node;
                return node;
            }
        }
        //如果tail为null，尝试将 Node 加入 AQS, 进入 ㈥
        enq(node);
        return node;
    }

    // ㈥ AQS 继承过来的方法, 方便阅读, 放在此处
    private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) {
                // 还没有, 设置 head 为哨兵节点（不对应线程，状态为 0）
                if (compareAndSetHead(new Node())) {
                    tail = head;
                }
            } else {
                // cas 尝试将 Node 对象加入 AQS 队列尾部
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }

    // ㈤ AQS 继承过来的方法, 方便阅读, 放在此处
    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                // 上一个节点是 head, 表示轮到自己（当前线程对应的 node）了, 尝试获取
                if (p == head && tryAcquire(arg)) {
                    // 获取成功, 设置自己（当前线程对应的 node）为 head
                    setHead(node);
                    // 上一个节点 help GC
                    p.next = null;
                    failed = false;
                    // 返回中断标记 false
                    return interrupted;
                }
                if (
                    // 判断是否应当 park, 进入 ㈦
                    shouldParkAfterFailedAcquire(p, node) &&
                    // park 等待, 此时 Node 的状态被置为 Node.SIGNAL ㈧
                    parkAndCheckInterrupt()
                ) {
                    interrupted = true;
                }
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }

    // ㈦ AQS 继承过来的方法, 方便阅读, 放在此处
    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        // 获取上一个节点的状态
        int ws = pred.waitStatus;
        if (ws == Node.SIGNAL) {
            // 上一个节点都在阻塞, 那么自己也阻塞好了
            return true;
        }
        // > 0 表示取消状态
        if (ws > 0) {
            // 上一个节点取消, 那么重构删除前面所有取消的节点, 返回到外层循环重试
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus > 0);
            pred.next = node;
        } else {
            // 这次还没有阻塞
            // 但下次如果重试不成功, 则需要阻塞，这时需要设置上一个节点状态为 Node.SIGNAL
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }

    // ㈧ 阻塞当前线程
    private final boolean parkAndCheckInterrupt() {
        LockSupport.park(this);
        return Thread.interrupted();
    }
}
```

##### `解锁`源码

```
// Sync 继承自 AQS
static final class NonfairSync extends Sync {
    // 解锁实现
    public void unlock() {
        sync.release(1);
    }

    // AQS 继承过来的方法, 方便阅读, 放在此处
    public final boolean release(int arg) {
        // 尝试释放锁, 进入 ㈠
        if (tryRelease(arg)) {
            // 队列头节点 unpark
            Node h = head;
            if (
                // 队列不为 null
                h != null &&
                // waitStatus == Node.SIGNAL 才需要 unpark
                h.waitStatus != 0
            ) {
                // unpark AQS 中等待的线程, 进入 ㈡
                unparkSuccessor(h);
            }
            return true;
        }
        return false;
    }

    // ㈠ Sync 继承过来的方法, 方便阅读, 放在此处
    protected final boolean tryRelease(int releases) {
        // state--
        int c = getState() - releases;
        if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
        boolean free = false;
        // 支持锁重入, 只有 state 减为 0, 才释放成功
        if (c == 0) {
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }

    // ㈡ AQS 继承过来的方法, 方便阅读, 放在此处
    private void unparkSuccessor(Node node) {
        // 如果状态为 Node.SIGNAL 尝试重置状态为 0, 如果线程获取到了锁那么后来头结点会被抛弃掉
        // 不成功也可以
        int ws = node.waitStatus;
        if (ws < 0) {
            compareAndSetWaitStatus(node, ws, 0);
        }
        // 找到需要 unpark 的节点, 但本节点从 AQS 队列中脱离, 是由唤醒节点完成的
        Node s = node.next;
        // 不考虑已取消的节点, 从 AQS 队列从后至前找到队列最前面需要 unpark 的节点
        if (s == null || s.waitStatus > 0) {
            s = null;
            for (Node t = tail; t != null && t != node; t = t.prev)
                if (t.waitStatus <= 0)
                    s = t;
        }
        if (s != null)
            LockSupport.unpark(s.thread);
    }
}
```

##### 可重入原理

$$
同一个线程, 锁重入, 会对state进行自增. 释放锁的时候, state进行自减; 当state自减为0的时候. 此时线程才会将锁释放成功, 才会进一步去唤醒其他线程来竞争锁
$$

```
static final class NonfairSync extends Sync {
    // ...

    // Sync 继承过来的方法, 方便阅读, 放在此处
    final boolean nonfairTryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        // 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入
        else if (current == getExclusiveOwnerThread()) {
            // state++
            int nextc = c + acquires;
            if (nextc < 0) // overflow
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }

    // Sync 继承过来的方法, 方便阅读, 放在此处
    protected final boolean tryRelease(int releases) {
        // state--
        int c = getState() - releases;
        if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
        boolean free = false;
        // 支持锁重入, 只有 state 减为 0, 才释放成功
        if (c == 0) {
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }
}
```

##### 可打断原理

- 不可打断模式：在此模式下，**即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能得知自己被打断了**

```
// Sync 继承自 AQS
static final class NonfairSync extends Sync {
    // ...

    private final boolean parkAndCheckInterrupt() {
        // 如果打断标记已经是 true, 则 park 会失效
        // 被park阻塞的线程, 可以被别的线程调用它的interrupt方法打断该park阻塞
        LockSupport.park(this);
        // interrupted 会清除打断标记; 下次park仍然可以阻塞
        return Thread.interrupted();
    }

    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null;
                    failed = false;
                    // 还是需要获得锁后, 才能返回打断状态
                    return interrupted;
                }
                if (
                        shouldParkAfterFailedAcquire(p, node) &&
                                parkAndCheckInterrupt()
                ) {
                    // 如果是因为 interrupt 被唤醒, 返回打断状态为 true
                    interrupted = true;
                }
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }

    public final void acquire(int arg) {
        if (
                !tryAcquire(arg) &&
                        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)
        ) {
            // 如果打断状态为 true
            selfInterrupt();
        }
    }

    static void selfInterrupt() {
        // 重新产生一次中断，这时候线程是如果正常运行的状态，那么不是出于sleep等状态，interrupt方法就不会报错
        Thread.currentThread().interrupt();
    }
}
}
```

可打断模式

    static final class NonfairSync extends Sync {
        public final void acquireInterruptibly(int arg) throws InterruptedException {
            if (Thread.interrupted())
                throw new InterruptedException();
            // 如果没有获得到锁, 进入 ㈠
            if (!tryAcquire(arg))
                doAcquireInterruptibly(arg);
        }
    
        // ㈠ 可打断的获取锁流程
        private void doAcquireInterruptibly(int arg) throws InterruptedException {
            final Node node = addWaiter(Node.EXCLUSIVE);
            boolean failed = true;
            try {
                for (;;) {
                    final Node p = node.predecessor();
                    if (p == head && tryAcquire(arg)) {
                        setHead(node);
                        p.next = null; // help GC
                        failed = false;
                        return;
                    }
                    if (shouldParkAfterFailedAcquire(p, node) &&
                            parkAndCheckInterrupt()) {
                        // 在 park 过程中如果被 interrupt 会进入此
                        // 这时候抛出异常, 而不会再次进入 for (;;)
                        throw new InterruptedException();
                    }
                }
            } finally {
                if (failed)
                    cancelAcquire(node);
            }
        }
    }
后续涉及比较多参考：https://blog.csdn.net/m0_37989980/article/details/112210173



##### 特点

###### 支持锁重入

- 可重入锁是指`同一个线程如果首次获得了这把锁`，那么因为它是这把`锁的拥有者`，因此 **有权利再次获取这把锁**
- 如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住

```
/**
 * Description: ReentrantLock 可重入锁, 同一个线程可以多次获得锁对象
 *
 * @date 2020/12/23 13:50
 */
@Slf4j(topic = "guizy.ReentrantTest")
public class ReentrantTest {

    private static ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) {
    	// 如果有竞争就进入`阻塞队列`, 一直等待着,不能被打断
        lock.lock();
        try {
            log.debug("entry main...");
            m1();
        } finally {
            lock.unlock();
        }
    }

    private static void m1() {
        lock.lock();
        try {
            log.debug("entry m1...");
            m2();
        } finally {
            lock.unlock();
        }
    }

    private static void m2() {
        log.debug("entry m2....");
    }
}
```

###### 可中断 (针对于lockInterruptibly()方法获得的中断锁) 直接退出阻塞队列, 获取锁失败

$$
synchronized 和 reentrantlock.lock() 的锁, 是不可被打断的; 也就是说别的线程已经获得了锁, 我的线程就需要一直等待下去. 不能中断

可被中断的锁, 通过lock.lockInterruptibly()获取的锁对象, 可以通过调用阻塞线程的interrupt()方法
$$

- 如果`某个线程处于阻塞状态`，可以调用其`interrupt方法`让其`停止阻塞`，**获得锁失败**
- 处于阻塞的线程，被打断后就不会阻塞了，直接停止 运行
- 可中断的锁, 在一定程度上可以`被动`的减少`死锁`的概率, 之所以被动, 是因为我们需要手动调用`阻塞线程的interrupt`方法;

```
@Slf4j(topic = "guizy.ReentrantTest")
public class ReentrantTest {

    private static final ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) {

        Thread t1 = new Thread(() -> {
            log.debug("t1线程启动...");
            try {
                // lockInterruptibly()是一个可打断的锁, 如果有锁竞争在进入阻塞队列后,可以通过interrupt进行打断
                lock.lockInterruptibly();
            } catch (InterruptedException e) {
                e.printStackTrace();
                log.debug("等锁的过程中被打断"); //没有获得锁就被打断跑出的异常
                return;
            }
            try {
                log.debug("t1线程获得了锁");
            } finally {
                lock.unlock();
            }
        }, "t1");

        // 主线程获得锁(此锁不可打断)
        lock.lock();
        log.debug("main线程获得了锁");
        // 启动t1线程
        t1.start();
        try {
            Sleeper.sleep(1);
            t1.interrupt();            //打断t1线程
            log.debug("执行打断");
        } finally {
            lock.unlock();
        }
    }
}
```

```
14:18:09.145 guizy.ReentrantTest [main] - main线程获得了锁
14:18:09.148 guizy.ReentrantTest [t1] - t1线程启动...
14:18:10.149 guizy.ReentrantTest [main] - 执行打断
14:18:10.149 guizy.ReentrantTest [t1] - 等锁的过程中被打断
java.lang.InterruptedException
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:898)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1222)
	at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335)
	at com.guizy.reentrantlock.ReentrantTest.lambda$main$0(ReentrantTest.java:25)
	at java.lang.Thread.run(Thread.java:748)
```



使用`lock.lock()`不可以从阻塞队列中打断, 一直等待别的线程释放锁

```
public class ReentrantLockTest {
    private static ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) {
        Thread t1 = new Thread(()->{
            System.out.println("t1启动");
            lock.lock();
            try {
                System.out.println("t1拿到锁");
            }finally {
                lock.unlock();
            }
        },"t1");

        lock.lock();
        System.out.println("main拿到锁");
        t1.start();
        try {
            TimeUnit.SECONDS.sleep(4);
            t1.interrupt();
            System.out.println("main线程执行打断");
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
}
```

```
15:22:20.210 [main] INFO ReentrantLockTest - main拿到锁
15:22:20.216 [t1] INFO ReentrantLockTest - t1启动
15:22:24.217 [main] INFO ReentrantLockTest - main线程执行打断
15:22:24.217 [t1] INFO ReentrantLockTest - t1拿到锁
```

此时在main线程中调用t1线程的interrupt()方法并没有将t1线程打断，等到主线程锁释放后，t1拿到了这个lock锁。

###### 锁超时 (lock.tryLock()) 直接退出阻塞队列, 获取锁失败

$$
防止无限制等待, 减少死锁
$$

- 使用 **`lock.tryLock()`** 方法会`返回获取锁是否成功`。如果成功则返回true，反之则返回false。
- 并且`tryLock方法`可以设置**指定等待时间**，参数为：**`tryLock(long timeout, TimeUnit unit)`** , 其中timeout为最长等待时间，TimeUnit为时间单位

$$
获取锁的过程中, 如果超过等待时间, 或者被打断, 就直接从阻塞队列移除, 此时获取锁就失败了, 不会一直阻塞着 ! (可以用来实现死锁问题)
$$

```
@Slf4j(topic = "ReentrantLockTest")
public class ReentrantLockTest {
    private static ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) {
        Thread t1 = new Thread(()->{
            log.info("t1取锁");
            if (!lock.tryLock()) {
                log.info("t1没有取到锁，直接返回");
                return;
            }
            try {
                log.info("t1拿到锁");
            }finally {
                lock.unlock();
            }
        },"t1");

        lock.lock();
        log.info("main拿到锁");
        t1.start();
        try {
            TimeUnit.SECONDS.sleep(4);
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            log.info("main释放锁");
            lock.unlock();
        }
    }
}
```

```
15:27:20.668 [main] INFO ReentrantLockTest - main拿到锁
15:27:20.671 [t1] INFO ReentrantLockTest - t1取锁
15:27:20.672 [t1] INFO ReentrantLockTest - t1没有取到锁，直接返回
15:27:24.672 [main] INFO ReentrantLockTest - main释放锁
```

- **设置等待时间, 超过等待时间还没有获得锁, 失败, 从阻塞队列移除该线程**

```
@Slf4j(topic = "ReentrantLockTest")
public class ReentrantLockTest {
    private static ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) {
        Thread t1 = new Thread(()->{
            log.info("t1尝试取锁");

            try {
                if (!lock.tryLock(5,TimeUnit.SECONDS)) {
                    log.info("t1没有取到锁，直接返回");
                    return;
                }
            } catch (InterruptedException e) {
                log.info("t1取锁被打断，直接返回");
                e.printStackTrace();
            }

            try {
                log.info("t1拿到锁");
            }finally {
                lock.unlock();
            }
        },"t1");

        lock.lock();
        log.info("main拿到锁");
        t1.start();
        try {
            TimeUnit.SECONDS.sleep(4);
            t1.interrupt();// 打断
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            log.info("main释放锁");
            lock.unlock();
        }
    }
}
```

```
16:40:46.083 [main] INFO ReentrantLockTest - main拿到锁
16:40:46.086 [t1] INFO ReentrantLockTest - t1尝试取锁
16:40:48.089 [t1] INFO ReentrantLockTest - t1超时没有取到锁，直接返回
16:40:50.088 [main] INFO ReentrantLockTest - main释放锁
```



###### 公平锁 new ReentrantLock(true)

- **`ReentrantLock默认是非公平锁, 可以指定为公平锁。`**
- 在线程获取锁失败，进入阻塞队列时，**先进入**的会在锁被释放后**先获得**锁。这样的获取方式就是**公平**的。一般不设置`ReentrantLock`为公平的, 会降低`并发度`
- `Synchronized`底层的`Monitor锁`就是不公平的, 和谁先进入`阻塞队列`是没有关系的。

```
//默认是不公平锁，需要在创建时指定为公平锁
ReentrantLock lock = new ReentrantLock(true);
```

- 公平锁, 可以把竞争的线程放在一个先进先出的阻塞队列上

- 只要持有锁的线程执行完了, 唤醒阻塞队列中的下一个线程获取锁即可; 此时先进入阻塞队列的线程先获取到锁
- 非公平锁, 当阻塞队列中已经有等待的线程A了, 此时后到的线程B, 先去尝试看能否获得到锁对象. 如果获取成功, 此时就不需要进入阻塞队列了. 这样以来后来的线程B就先活的到锁了

```
所以公平和非公平的区别 : 线程执行同步代码块时, 是否回去尝试获取锁, 如果会尝试获取锁, 那就是非公平的, 如果不会尝试获取锁, 直接进入阻塞队列, 再等待被唤醒, 那就是公平的

如果不进如队列呢? 线程一直尝试获取锁不就行了?
一直尝试获取锁, 在synchronized轻量级锁升级为重量级锁时, 做的一个优化, 叫做自旋锁, 一般很消耗资源, cpu一直空转, 最后获取锁也失败, 所以不推荐使用。在jdk6对于自旋锁有一个机制, 在重试获得锁指定次数就失败等等
```



###### 条件变量 (可避免虚假唤醒) - lock.newCondition()创建条件变量对象; 通过条件变量对象调用`await/signal`方法, 等待/唤醒

- **`Synchronized`** 中也有`条件变量`，就是`Monitor监视器`中的 `waitSet等待集合`，当条件不满足时进入`waitSet 等待`

- **`ReentrantLock`** 的条件变量比 synchronized 强大之处在于,它是 **`支持多个条件变量`。**
- 这就好比synchronized 是那些不满足条件的线程都在`一间休息室`等通知; **`(此时会造成虚假唤醒)`**, 而 ReentrantLock 支持`多间休息室`，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒; **`(可以避免虚假唤醒)`**

使用要点：

- await 前需要 **获得锁**

- await 执行后，会释放锁，进入 `conditionObject` (条件变量)中等待

- await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁

  - 竞争 lock 锁成功后，从 await 后继续执行
- signal 方法用来唤醒`条件变量(等待室)`汇总的某一个等待的线程
- signalAll方法, 唤醒`条件变量(休息室)`中的所有线程

```
package com.current.demo;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @program: threadDemo
 * @description: ReentrantLock的条件变量之避免虚假唤醒
 * @author: mengjianglong@e6yun.com
 * @create: 2021-11-18 19:31
 **/
@Slf4j(topic = "ConditionVariable")
public class ConditionVariable {
    // 外卖状态
    private static boolean wmStatue = false;
    // 烟草状态
    private static boolean ycStatue = false;
    private static final ReentrantLock lock = new ReentrantLock();

    // 外卖等待室
    static Condition wmCondition = lock.newCondition();
    // 烟草等待室
    static Condition ycCondition = lock.newCondition();

    public static void main(String[] args) {
        new Thread(()->{
            lock.lock();
            try {
                log.info("有烟没？{}",ycStatue);
                while (!ycStatue){
                    log.info("没有烟，我不干活");
                    try {
                        // 进入等待
                        ycCondition.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.info("有烟了，干活");
            }finally {
                lock.unlock();
            }
        },"老高").start();
        new Thread(()->{
            lock.lock();
            try {
                log.info("外卖来了没？{}",wmStatue);
                while (!wmStatue){
                    log.info("外卖没来，我不吃");
                    try {
                        // 进入等待
                        wmCondition.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } 
                }
                log.info("外卖来，干饭");
            }finally {
                lock.unlock();
            }
        },"小高").start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()->{
            lock.lock();
            try {
                log.info("外卖来了");
                wmStatue = true;
                wmCondition.signal();
            }finally {
                lock.unlock();
            }
        },"t1").start();

        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(()->{
            lock.lock();
            try {
                log.info("烟来了");
                ycStatue = true;
                ycCondition.signal();
            }finally {
                lock.unlock();
            }
        },"t2").start();
    }
}

```

```
20:07:35.256 [老高] INFO ConditionVariable - 有烟没？false
20:07:35.260 [老高] INFO ConditionVariable - 没有烟，我不干活
20:07:35.260 [小高] INFO ConditionVariable - 外卖来了没？false
20:07:35.261 [小高] INFO ConditionVariable - 外卖没来，我不吃
20:07:36.255 [t1] INFO ConditionVariable - 外卖来了
20:07:36.256 [小高] INFO ConditionVariable - 外卖来，干饭
20:07:38.255 [t2] INFO ConditionVariable - 烟来了
20:07:38.255 [老高] INFO ConditionVariable - 有烟了，干活
```

##### 同步模式之顺序控制 (案例)

- 假如有两个线程, 线程A打印1, 线程B打印2.

- 要求: **程序先打印2, 再打印1**

###### Wait/Notify版本实现

```
/**
 * @program: threadDemo
 * @description: 同步顺序控制
 * @author: mengjianglong@e6yun.com
 * @create: 2021-11-25 16:03
 **/
@Slf4j(topic = "SyncPrintWaitTest")
public class SyncPrintWaitTest {
    private static final Object lock = new Object();
    private static boolean p = false;

    public static void main(String[] args) {
        Thread t1 = new Thread(()->{
            synchronized (lock){
                while (!p){
                    try {
                        log.info("等待。。。。。");
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.info("解除等待");
            }
        },"t1");

        Thread t2 = new Thread(()->{
            synchronized (lock){
                try {
                    TimeUnit.SECONDS.sleep(2);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                p = true;
                lock.notifyAll();
            }

        },"t2");
        t1.start();
        t2.start();
    }
}
```

```
20:15:27.686 [t1] INFO SyncPrintWaitTest - 等待。。。。。
20:15:29.690 [t1] INFO SyncPrintWaitTest - 解除等待
```



###### 使用ReentrantLock的await/signal

```
package com.current.demo;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @program: threadDemo
 * @description: 同步顺序控制
 * @author: mengjianglong@e6yun.com
 * @create: 2021-11-25 16:03
 **/
@Slf4j(topic = "SyncPrintWaitTest")
public class SyncPrintWaitTest {
    private static final ReentrantLock lock = new ReentrantLock();
    static final Condition condition = lock.newCondition();
    static boolean p = false;

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            lock.lock();

            try {
                while (!p) {
                    try {
                        log.info("进入等待。。。");
                        condition.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            } finally {
                lock.unlock();
            }
            log.info("xiaofei.................");
        }, "t1");

        Thread t2 = new Thread(() -> {
            lock.lock();
            try {
                try {
                    TimeUnit.SECONDS.sleep(5);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.info("jihuo.........");
                p = true;
                condition.signal();
            } finally {
                lock.unlock();
            }
        }, "t2");
        t1.start();
        t2.start();
    }
}
```

```
16:05:30.314 [t1] INFO SyncPrintWaitTest - 进入等待。。。
16:05:35.319 [t2] INFO SyncPrintWaitTest - jihuo.........
16:05:35.319 [t1] INFO SyncPrintWaitTest - xiaofei.................
```



###### 使用LockSupport中的park/unpart

```
package com.current.demo;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.locks.LockSupport;


/**
 * @program: threadDemo
 * @description: 同步顺序控制  打印2，1
 * @author: mengjianglong@e6yun.com
 * @create: 2021-11-25 16:03
 **/
@Slf4j(topic = "SyncPrintWaitTest")
public class SyncPrintWaitTest {
    public static void main(String[] args) {
        Thread t1 = new Thread(()->{
            LockSupport.park();
            log.info("1");
        },"t1");
        t1.start();

        Thread t2 = new Thread(()->{
            log.info("2");
            LockSupport.unpark(t1);
        },"t2");
        t2.start();
    }

}
```

```
16:15:42.370 [t2] INFO SyncPrintWaitTest - 2
16:15:42.373 [t1] INFO SyncPrintWaitTest - 1
```



##### 交替输出

abcabcabcabcabc

###### Wait/Notify版本实现

```
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @program: threadDemo
 * @description: 顺序控制
 * @author: mengjianglong@e6yun.com
 * 控制输出abcabcabcabcabc
 * @create: 2021-12-02 16:24
 **/

public class TestWaitNotify {
    private static final int a = 1;
    private static final int b = 2;
    private static final int c = 3;
    public static void main(String[] args) {
        WaitNotify waitNotify = new WaitNotify(a,5);
        new Thread(()->{
            waitNotify.print("a",a,b);
        },"a").start();
        new Thread(()->{
            waitNotify.print("b",b,c);
        },"a").start();
        new Thread(()->{
            waitNotify.print("c",c,a);
        },"a").start();
    
    }
}
class WaitNotify{
    private int flag;
    private int total;
    public void print(String str,int waitFlag,int nextFlag){
        for (int i = 0; i < total; i++) {
            synchronized (this){
                while(waitFlag != this.flag) {
                    try {
                        this.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.print(str);
                this.flag = nextFlag;
                this.notifyAll();
            }
        }
    }

    public WaitNotify(int flag, int total) {
        this.flag = flag;
        this.total = total;
    }
}
```

```
abcabcabcabcabc
```



###### 使用ReentrantLock的await/signal

```
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @program: threadDemo
 * @description: 顺序控制
 * @author: mengjianglong@e6yun.com
 * 控制输出abcabcabcabcabc
 * @create: 2021-12-02 16:24
 **/

public class TestWaitNotify {
    public static void main(String[] args) {
        AwaitSignal awaitSignal = new AwaitSignal(5);
        Condition a_con = awaitSignal.newCondition();
        Condition b_con = awaitSignal.newCondition();
        Condition c_con = awaitSignal.newCondition();
        new Thread(()->{
            awaitSignal.print("a",a_con,b_con);
        },"a").start();
        new Thread(()->{
            awaitSignal.print("b",b_con,c_con);
        },"a").start();
        new Thread(()->{
            awaitSignal.print("c",c_con,a_con);
        },"a").start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        awaitSignal.lock();

        try {
            a_con.signal();
        } finally {
            awaitSignal.unlock();
        }
    }
}
class AwaitSignal extends ReentrantLock {
    private int total;

    public AwaitSignal(int total) {
        this.total = total;
    }

    public void print(String str, Condition current,Condition next){
        for (int i = 0; i < total; i++) {
            lock();
            try {
                System.out.print(str);
                try {
                    current.await();
                    next.signal();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            } finally {
                unlock();
            }

        }
    }
}

```

```
abcabcabcabcabc
```



###### 使用LockSupport中的park/unpart

```
import java.util.concurrent.locks.LockSupport;

/**
 * @program: threadDemo
 * @description: 顺序控制输出abc
 * @author: mengjianglong@e6yun.com
 * @create: 2021-12-02 16:57
 **/

public class TestParkUnpark {
    static Thread a;
    static Thread b;
    static Thread c;
    public static void main(String[] args) {
        ParkUnpark parkUnpark = new ParkUnpark(5);
        a = new Thread(()->{
            parkUnpark.print("a",b);
        },"a");
        b= new Thread(()->{
            parkUnpark.print("b",c);
        },"b");
        c= new Thread(()->{
            parkUnpark.print("c",a);
        },"c");

        a.start();
        b.start();
        c.start();
        LockSupport.unpark(a);
    }
}
class  ParkUnpark{
    private int total;

    public ParkUnpark(int total) {
        this.total = total;
    }
    public void print(String str,Thread next){
        for (int i = 0; i < total; i++) {
            LockSupport.park();
            System.out.print(str);
            LockSupport.unpark(next);
        }
    }
}
```

```
abcabcabcabcabc
```



### Semaphore/CountDownLatch/CyclicBarrie源码解读



## 并发atomic原子操作

### 共享模型之无锁

- 有如下需求，保证`account.withdraw取款方法`的线程安全, 下面使用`synchronized`保证线程安全
- 上面的代码中使用`synchronized加锁`操作来`保证线程安全`，但是 **synchronized加锁操作太耗费资源 (因为底层使用了操作系统mutex指令, 造成内核态和用户态的切换)**，这里我们使用 **`无锁`** 来解决此问题

```
package com.current.demo;

import lombok.extern.slf4j.Slf4j;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 * @program: threadDemo
 * @description:
 * @author: mengjianglong@e6yun.com
 * @create: 2021-10-28 17:37
 **/
@Slf4j(topic = "Test")
public class Test {

    public static void main(String[] args) {
        Account.demo(new AccountUnsafe(10000));
        Account.demo(new AccountCas(10000));
    }
}

class AccountUnsafe implements Account {
    private Integer balance;

    public AccountUnsafe(Integer balance) {
        this.balance = balance;
    }

    @Override
    public Integer getBalance() {
        synchronized (this) {
            return balance;
        }
    }

    @Override
    public void withdraw(Integer amount) {
        // 通过这里加锁就可以实现线程安全，不加就会导致线程安全问题
        synchronized (this) {
            balance -= amount;
        }
    }
}

interface Account {
    // 获取余额
    Integer getBalance();

    // 取款
    void withdraw(Integer amount);

    /**
     * Java8之后接口新特性, 可以添加默认方法
     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作
     * 如果初始余额为 10000 那么正确的结果应当是 0
     */
    static void demo(Account account) {
        List<Thread> ts = new ArrayList<>();
        long start = System.nanoTime();
        for (int i = 0; i < 1000; i++) {
            ts.add(new Thread(() -> {
                account.withdraw(10);
            }));
        }
        ts.forEach(thread -> thread.start());
        ts.forEach(t -> {
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        long end = System.nanoTime();

        System.out.println(account.getBalance()
                + " cost: " + (end - start) / 1000_000 + " ms");
    }
}
class AccountCas implements Account{
    private AtomicInteger balance;
    AccountCas(int balance){
        this.balance = new AtomicInteger(balance);
    }

    @Override
    /**
     * 取原子整数值
     */
    public Integer getBalance() {
        return balance.get();
    }

    @Override
    public void withdraw(Integer amount) {
        while (true){
            /*取值*/
            int pre = balance.get();
            /*计算后的值*/
            int next = pre - amount;
/*
				此时的prev为共享变量的值, 如果prev被别的线程改了.也就是说: 自己读到的共享变量的值 和 共享变量最新值 不匹配,
				就继续where(true),如果匹配上了, 将next值设置给共享变量.

				AtomicInteger中value属性, 被volatile修饰, 就是为了确保线程之间共享变量的可见性.
			*/
            if (balance.compareAndSet(pre,next)) {
                break;
            }
        }
    }
}
```



### Atomic原子类

#### 原子整数 (内部通过CAS来实现-AtomicInteger)

- `java.util.concurrent.atomic并发包`提供了一些并发工具类，这里把它分成五类：
- 使用原子的方式 **(共享数据为基本数据类型原子类)**
  - **`AtomicInteger：整型原子类`**
  - AtomicLong：长整型原子类
  - AtomicBoolean ：布尔型原子类
- 上面三个类提供的方法几乎相同，所以我们将以 `AtomicInteger`为例子来介绍。先讨论`原子整数类`，以 `AtomicInteger` 为例讨论它的api接口：通过观察源码可以发现
- **AtomicInteger 内部都是通过`cas的原理`来实现的**

```
public static void main(String[] args) {
    AtomicInteger i = new AtomicInteger(0);
    
    // 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++
    System.out.println(i.getAndIncrement());
    
    // 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i
    System.out.println(i.incrementAndGet());
    
    // 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i
    System.out.println(i.decrementAndGet());
    
    // 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--
    System.out.println(i.getAndDecrement());
    
    // 获取并加值（i = 0, 结果 i = 5, 返回 0）
    System.out.println(i.getAndAdd(5));
    
    // 加值并获取（i = 5, 结果 i = 0, 返回 0）
    System.out.println(i.addAndGet(-5));
    
    // 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）
    // 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用
    System.out.println(i.getAndUpdate(p -> p - 2));
    
    // 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）
    // 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用
    System.out.println(i.updateAndGet(p -> p + 2));
    
    // 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）
    // 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用
    // getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的
    // getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final
    System.out.println(i.getAndAccumulate(10, (p, x) -> p + x));
    
    // 计算并获取（i = 10, p 为 i 的当前值, x 为参数1值, 结果 i = 0, 返回 0）
    // 函数式编程接口，其中函数中的操作能保证原子，但函数需要无副作用
    System.out.println(i.accumulateAndGet(-10, (p, x) -> p + x));
}
```

#### 举个例子: updateAndGet的实现

```
package com.current.demo;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.IntUnaryOperator;

/**
 * @program: threadDemo
 * @description: updateAndGet的实现
 * @author: mengjianglong@e6yun.com
 * @create: 2021-12-10 15:05
 **/
@Slf4j(topic = "AtomicIntegerDemo")
public class AtomicIntegerDemo {
    public static void main(String[] args) {
        AtomicInteger i = new AtomicInteger(5);
        /**
         * 调用updateAndGet方法，将原子整数和函数IntUnaryOperator对象传入
         * operator.applyAsInt(pref)拿到pref作为applyAsInt方法的形参operand进行计算，计算完成后将值返回
         */
        updateAndGet(i, new IntUnaryOperator() {
            @Override
            public int applyAsInt(int operand) {
                return operand / 2;
            }
        });
        log.info("值："+i.get());
    }
    public static void updateAndGet(AtomicInteger i, IntUnaryOperator operator){
        while (true) {
            int pref = i.get();
            int next = operator.applyAsInt(pref);
            if (i.compareAndSet(pref, next)) {
                break;
            }
        }
    }
}
```



#### 原子引用 (AtomicReference)

$$
原子引用的作用: 保证引用类型的共享变量是线程安全的(确保这个原子引用没有引用过别人)
$$

- 为什么需要原子引用类型 ? (引用数据类型原子类)
  - `AtomicReference`
  - `AtomicMarkableReference`
  - `AtomicStampedReference` **(可以解决ABA问题)**

为什么需要`原子引用类型`？**保证`引用类型的共享变量是线程安全`的（确保这个原子引用没有引用过别人）。**

基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用引用类型原子类。

- **AtomicReference**：引用类型原子类
- **AtomicStampedReference**：原子更新带有`版本号`的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，**`可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。`**
- **AtomicMarkableReference** ：原子更新带有`标记`的引用类型。该类将 boolean 标记与引用关联起来

例子 : 使用原子引用实现BigDecimal存取款的线程安全：

```
package com.current.demo;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;

/**
 * @program: threadDemo
 * @description: 使用原子引用解决取款问题
 * @author: mengjianglong@e6yun.com
 * @create: 2021-12-10 15:55
 **/

public class DecimalReference {
    public static void main(String[] args) {
        DecimalAccount.demo(new DecimalAccountCas(new BigDecimal("10000")));
    }
}

interface DecimalAccount {
    // 获取余额
    BigDecimal getBalance();

    // 取款
    void withdraw(BigDecimal amount);

    /**
     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作
     * 如果初始余额为 10000 那么正确的结果应当是 0
     */
    static void demo(DecimalAccount account) {
        List<Thread> ts = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            ts.add(new Thread(() -> {
                account.withdraw(BigDecimal.TEN);
            }));
        }
        ts.forEach(Thread::start);
        ts.forEach(t -> {
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        System.out.println(account.getBalance());
    }
}

/**
 * 线程不安全的操作
 */
class DecimalAccountUnsafe implements DecimalAccount {

    BigDecimal balance;

    DecimalAccountUnsafe(BigDecimal balance) {
        this.balance = balance;
    }

    @Override
    public BigDecimal getBalance() {
        return this.balance;
    }

    @Override
    public void withdraw(BigDecimal amount) {
        this.balance = getBalance().subtract(amount);
    }
}

/**
 * 使用cas原子引用保证线程安全：AtomicReference (但不能解决ABA问题：中途数据更改前后假如线程b操作共享数据balance先进行了减一然后又进行加一，前后数据实际已经变化了两次，它不会记录数据变化次数，
 * 有些业务上可能需要记录每次数据的变化因此会产生ABA问题)
 */
class DecimalAccountCas implements DecimalAccount {

    private final AtomicReference<BigDecimal> balance;

    DecimalAccountCas(BigDecimal balance) {
        this.balance = new AtomicReference<BigDecimal>(balance);
    }

    @Override
    public BigDecimal getBalance() {
        return balance.get();
    }

    @Override
    public void withdraw(BigDecimal amount) {
        while (true) {
            BigDecimal pref = balance.get();
            BigDecimal next = pref.subtract(amount);

            if (balance.compareAndSet(pref, next)) {
                break;
            }
        }
    }
}
```

#### ABA 问题及解决 (`重点`)

- 如下程序所示，虽然 **在other方法中存在两个线程对共享变量进行了修改，但是修改之后又变成了原值**，**main线程对`修改过共享变量的过程`是不可见的，这种操作这对业务代码并无影响。**

```
public class Test1 {

    static AtomicReference<String> ref = new AtomicReference<>("A");

    public static void main(String[] args) {
        new Thread(() -> {
            String pre = ref.get();
            System.out.println("change");
            try {
                other();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            Sleeper.sleep(1);
            //把ref中的A改为C
            System.out.println("change A->C " + ref.compareAndSet(pre, "C"));
        }).start();
    }

    static void other() throws InterruptedException {
        new Thread(() -> {
        	// 此时ref.get()为A,此时共享变量ref也是A,没有被改过, 此时CAS
        	// 可以修改成功, B
            System.out.println("change A->B " + ref.compareAndSet(ref.get(), "B"));
        }).start();
        Thread.sleep(500);
        new Thread(() -> {
        	// 同上, 修改为A
            System.out.println("change B->A " + ref.compareAndSet(ref.get(), "A"));
        }).start();
    }
}

```

![img](https://img-blog.csdnimg.cn/20201227200916774.png)

- 主线程仅能判断出`共享变量的值`与`最初值 A`是否相同，不能感知到这种从 A 改为 B 又改回 A 的情况，如果主线程希望：**只要有其它线程【动过】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个`版本号`。使用`AtomicStampedReference`来解决。**

```
package com.current.demo;

import java.util.concurrent.atomic.AtomicStampedReference;

/**
 * @program: threadDemo
 * @description: 原子引用ABA问题解决
 * @author: mengjianglong@e6yun.com
 * @create: 2021-12-10 16:47
 **/

public class AtomicStampedReferenceDemo {
    static AtomicStampedReference<String> balance = new AtomicStampedReference<>("A",0);
    public static void main(String[] args) {
        /*
        * 初始化值以及版本号A--0
        * */

        new Thread(()->{
            // 取值
            String pref = balance.getReference();
            // 取版本
            int stamp = balance.getStamp();
            System.out.println("start change......");

            try {
                other();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("change A->C stamp "+stamp+balance.compareAndSet(pref,"C",stamp,stamp+1));
        }).start();
    }

    static void other() throws InterruptedException {
        new Thread(()->{
            // 取值
            String pref = balance.getReference();
            // 取版本
            int stamp = balance.getStamp();
            // 更新值
            System.out.println("change A->B stamp "+stamp+balance.compareAndSet(pref,"B",stamp,stamp+1));
        }).start();
        Thread.sleep(500);
        new Thread(()->{
// 取值
            String pref = balance.getReference();
            // 取版本
            int stamp = balance.getStamp();
                System.out.println("change B->C stamp "+stamp+balance.compareAndSet(pref,"C",stamp,stamp+1));
        }).start();
    }
}
```

结果：

```
start change......
change A->B stamp 0true  前两次匹配成功
change B->C stamp 1true
change A->C stamp 0false  后一次因为版本不一致问题匹配失败
```

#### AtomicMarkableReference (标记cas的共享变量是否被修改过)

- `AtomicStampedReference` 可以给`原子引用`加上`版本号`，**追踪原子引用整个的变化过程**，如：A -> B -> A ->C，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。
- 但是有时候，`并不关心引用变量更改了几次，只是单纯的关心是否更改过`，所以就有了`AtomicMarkableReference`

```
package com.current.demo;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.atomic.AtomicMarkableReference;

/**
 * @program: threadDemo
 * @description: AtomicMarkableReference (标记cas的共享变量是否被修改过)
 * @author: mengjianglong@e6yun.com
 * @create: 2021-12-10 17:10
 **/
@Slf4j(topic = "TestABAAtomicMarkableReference")
public class TestABAAtomicMarkableReference {
    public static void main(String[] args) throws InterruptedException {
        GarbageBag bad = new GarbageBag("垃圾满了");

        AtomicMarkableReference<GarbageBag> balance = new AtomicMarkableReference<>(bad,true);

        GarbageBag pref = balance.getReference();
        log.info(pref.toString());
        new Thread(()->{
            // 处理垃圾：注意主线程休眠期间该线程已将垃圾袋替换掉了
            log.debug("打扫卫生的线程 start...");
            bad.setDesc("空垃圾袋");

            while (true){
                if (!balance.compareAndSet(bad,bad,true,false)) {
                    break;
                }
            }
            log.debug(bad.toString());
        }).start();

        // 主线程休眠1s
        Thread.sleep(1000);
        log.debug("需要换垃圾袋");
        // 主线程再次替换垃圾袋时因为标记不符替换失败
        boolean result = balance.compareAndSet(pref,new GarbageBag("空垃圾袋"),true,false);
        log.debug("换好了吗："+result);
        log.debug(balance.getReference().toString());
    }

}
class GarbageBag {
    String desc;

    public GarbageBag(String desc) {
        this.desc = desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    @Override
    public String toString() {
        return super.toString() + " " + desc;
    }
}
```

```
17:31:24.481 [main] INFO TestABAAtomicMarkableReference - com.current.demo.GarbageBag@4ee285c6 垃圾满了
17:31:24.528 [Thread-0] DEBUG TestABAAtomicMarkableReference - 打扫卫生的线程 start...
17:31:24.528 [Thread-0] DEBUG TestABAAtomicMarkableReference - com.current.demo.GarbageBag@4ee285c6 空垃圾袋
17:31:25.528 [main] DEBUG TestABAAtomicMarkableReference - 需要换垃圾袋
17:31:25.528 [main] DEBUG TestABAAtomicMarkableReference - 换好了吗：false
17:31:25.528 [main] DEBUG TestABAAtomicMarkableReference - com.current.demo.GarbageBag@4ee285c6 空垃圾袋
```

#### AtomicStampedReference和AtomicMarkableReference两者的区别

- **`AtomicStampedReference`** 需要我们传入 **`整型变量`** 作为`版本号`，来判定是否被更改过
- **`AtomicMarkableReference`\**需要我们传入\**`布尔变量`** 作为`标记`，来判断是否被更改过



#### 原子数组 (AtomicIntegerArray)

- 保证数组内的元素的`线程安全`
- 使用原子的方式更新数组里的某个元素
  - `AtomicIntegerArray`：整形数组原子类
  - `AtomicLongArray`：长整形数组原子类
  - `AtomicReferenceArray`：引用类型数组原子类

上面三个类提供的方法几乎相同，所以我们这里以 `AtomicIntegerArray` 为例子来介绍。实例

- 普通数组内元素, 多线程访问造成安全问题

```
public class AtomicArrayTest {
    public static void main(String[] args) {
        demo(
                () -> new int[10],
                array -> array.length,
                (array, index) -> array[index]++,
                array -> System.out.println(Arrays.toString(array))
        );
    }

    /**
     * 参数1，提供数组、可以是线程不安全数组或线程安全数组
     * 参数2，获取数组长度的方法
     * 参数3，自增方法，回传 array, index
     * 参数4，打印数组的方法
     */
    // supplier 提供者 无中生有 ()->结果
    // function 函数 一个参数一个结果 (参数)->结果 , BiFunction (参数1,参数2)->结果
    // consumer 消费者 一个参数没结果 (参数)->void, BiConsumer (参数1,参数2)->void
    private static <T> void demo(Supplier<T> arraySupplier, Function<T, Integer> lengthFun,
                                 BiConsumer<T, Integer> putConsumer, Consumer<T> printConsumer) {
        List<Thread> ts = new ArrayList<>();
        T array = arraySupplier.get();
        int length = lengthFun.apply(array);

        for (int i = 0; i < length; i++) {
            // 创建10个线程, 每个线程对数组作 10000 次操作
            ts.add(new Thread(() -> {
                for (int j = 0; j < 10000; j++) {
                    putConsumer.accept(array, j % length);
                }
            }));
        }

        ts.forEach(t -> t.start()); // 启动所有线程
        ts.forEach(t -> {
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }); // 等所有线程结束

        printConsumer.accept(array);
    }
}
```

- 使用`AtomicIntegerArray`来创建安全数组

```
demo(
        ()-> new AtomicIntegerArray(10),
        (array) -> array.length(),
        (array, index) -> array.getAndIncrement(index),
        array -> System.out.println(array)
);

demo(
        ()-> new AtomicIntegerArray(10),
        AtomicIntegerArray::length,
        AtomicIntegerArray::getAndIncrement,
        System.out::println
);
```



#### 字段更新器

保证`多线程`访问`同一个对象的成员变量`时, `成员变量的线程安全性`。

- `AtomicReferenceFieldUpdater` —引用类型的属性
- AtomicIntegerFieldUpdater —整形的属性
- AtomicLongFieldUpdater —长整形的属性

注意：利用字段更新器，可以针对`对象的某个域（Field）进行原子操作`，只能`配合 volatile 修饰`的字段使用，否则会出现异常。

```
Exception in thread "main" java.lang.IllegalArgumentException: Must be volatile type
```

- 例子

```
package com.current.demo;

import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

/**
 * @program: threadDemo
 * @description: 字段更新器
 * @author: mengjianglong@e6yun.com
 * @create: 2021-12-10 18:06
 **/

public class AtomicFieldTest {
    public static void main(String[] args) {
        Student student = new Student();
        /*
        * newUpdater 三个参数
        * 1.需要更新的类
        * 2.作用字段类型
        * 3.更新字段名称
        * */
        AtomicReferenceFieldUpdater fieldUpdater = AtomicReferenceFieldUpdater.newUpdater(Student.class,String.class,"name");

        fieldUpdater.compareAndSet(student,null,"张三");
        fieldUpdater.compareAndSet(student,student.name,"王五");
        System.out.println(student.toString());
    }
}
class Student {
    volatile String name;

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                '}';
    }
}
```





#### 原子累加器 (LongAddr) (`重要`)

- `LongAddr`
- LongAccumulator
- DoubleAddr
- DoubleAccumulator

##### `累加器性能比较 AtomicLong, LongAddr`

```
@Slf4j(topic = "Test")
public class Test {
    public static void main(String[] args) {
        System.out.println("----AtomicLong----");
        for (int i = 0; i < 5; i++) {
            demo(() -> new AtomicLong(), adder -> adder.getAndIncrement());
        }

        System.out.println("----LongAdder----");
        for (int i = 0; i < 5; i++) {
            demo(() -> new LongAdder(), adder -> adder.increment());
        }
    }

    private static <T> void demo(Supplier<T> adderSupplier, Consumer<T> action) {
        T adder = adderSupplier.get();
        long start = System.nanoTime();
        List<Thread> ts = new ArrayList<>();
        // 4 个线程，每人累加 50 万
        for (int i = 0; i < 40; i++) {
            ts.add(new Thread(() -> {
                for (int j = 0; j < 500000; j++) {
                    action.accept(adder);
                }
            }));
        }
        ts.forEach(t -> t.start());
        ts.forEach(t -> {
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        long end = System.nanoTime();
        System.out.println(adder + " cost:" + (end - start) / 1000_000);
    }
}
```

```
----AtomicLong----
20000000 cost:646
20000000 cost:707
20000000 cost:689
20000000 cost:713
20000000 cost:657
----LongAdder----
20000000 cost:148
20000000 cost:139
20000000 cost:130
20000000 cost:122
20000000 cost:116
```

LongAddr

- **性能提升的原因很简单，就是在有竞争时，设置多个`累加单元`(但不会超过cpu的核心数)，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，`因此减少了 CAS 重试失败`，从而提高性能。**

AtomicLong

- **之前AtomicLong等都是在一个`共享资源变量`上进行竞争, `while(true)`循环进行CAS重试, 性能没有`LongAdder`高**



##### LongAdder原理 (了解)

###### 原理之伪共享

![img](https://img-blog.csdnimg.cn/img_convert/e1c53a0fb41d7d089e5ddcc71f1f2a0d.png)

- 缓存行伪共享得从`缓存`说起
- 缓存与内存的速度比较

![img](https://img-blog.csdnimg.cn/img_convert/9d3df3ad5311a92ecf235ccf78584ca3.png)

![img](https://img-blog.csdnimg.cn/img_convert/b4d95b0315026ad343cda2dd2d2f3c2a.png)

- 因为 `CPU 与 内存的速度差异很大`，需要靠`预读数据`至**缓存**来提升效率。而缓存以**缓存行**为单位，每个缓存行对应着一块内存，一般是 **64 byte**（8 个 long）**缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中**
- CPU 要保证数据的**一致性** (缓存一致性)，如果某个 CPU 核心**更改**了数据，其它 CPU 核心对应的整个缓存行必须**失效**

![img](https://img-blog.csdnimg.cn/img_convert/56de3a77bb6f96ba480f622083864c36.png)

- 因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了：
  - Core-0 要修改 Cell[0]
  - Core-1 要修改 Cell[1]

无论谁修改成功，都会导致对方 Core 的缓存行失效，

- 比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加 Cell[0]=6001, Cell[1]=8000 ，这时会让 Core-1 的缓存行失效
- @sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的**前后各增加 128 字节大小的 padding**（空白），从而让 CPU 将对象预读至缓存时**占用不同的缓存行**，这样，不会造成对方缓存行的失效![img](https://img-blog.csdnimg.cn/img_convert/4f0aefac3f7bfaece8703efa77e342fa.png)

**累加主要调用以下方法**

```
public void add(long x) {
       Cell[] as; long b, v; int m; Cell a;
       if ((as = cells) != null || !casBase(b = base, b + x)) {
           boolean uncontended = true;
           if (as == null || (m = as.length - 1) < 0 ||
               (a = as[getProbe() & m]) == null ||
               !(uncontended = a.cas(v = a.value, v + x)))
               longAccumulate(x, null, uncontended);
       }
   }
```

**累加流程图**

![img](https://img-blog.csdnimg.cn/img_convert/ce399f7bd72da53a22f6fbaba896dcc1.png)



### Unsafe (`重点`)

- Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过`反射`获得
- 可以发现`AtomicInteger`以及其他的原子类, 底层都使用的是`Unsafe`类

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201228125739963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

- 使用底层的`Unsafe`实现原子操作

```
package com.current.demo;

import sun.misc.Unsafe;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

/**
 * @program: threadDemo
 * @description: Unsafe实现控制原子操作
 * @author: mengjianglong@e6yun.com
 * @create: 2021-12-10 18:48
 **/

public class UnsafeTest {
    public static void main(String[] args) throws Exception {
        // 通过反射获得Unsafe对象
        Class<Unsafe> unsafeClass = Unsafe.class;
        // 获得构造函数，Unsafe的构造函数为私有的
        Constructor<Unsafe> declaredConstructor = unsafeClass.getDeclaredConstructor();
        // 设置为允许访问私有内容
        declaredConstructor.setAccessible(true);
        // 创建Unsafe对象
        Unsafe unsafe = declaredConstructor.newInstance();
        // 创建Person对象
        Person person = new Person();
        // 获得其属性 name 的偏移量
        long nameOffset = unsafe.objectFieldOffset(Person.class.getDeclaredField("name"));
        long ageOffset = unsafe.objectFieldOffset(Person.class.getDeclaredField("age"));

        // 通过unsafe的CAS操作改变值
        unsafe.compareAndSwapObject(person, nameOffset, null, "mjl");
        unsafe.compareAndSwapInt(person, ageOffset, 0, 22);
        System.out.println(person);

    }
}
class Person {
    // 配合CAS操作，必须用volatile修饰
    volatile String name;
    volatile int age;

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```

















### CAS（乐观锁）原理

#### CAS 与 volatile `(重点)`

$$
使用原子操作来保证线程访问共享资源的安全性, cas+重试的机制来确保(乐观锁思想), 相对于悲观锁思想的synchronized,reentrantLock来说, cas的方式效率会更好!
$$

#### cas + 重试 的原理

- 前面看到的`AtomicInteger`的解决方法，内部并`没有用锁`来保护`共享变量`的线程安全。那么它是如何实现的呢？
- 其中的关键是 `compareAndSwap（比较并设置值）`，它的简称就是 `CAS` （也有 Compare And Swap 的说法），它必须是`原子操作`。

![1594776811158](https://img-blog.csdnimg.cn/img_convert/436a166f7e783537464879edf14ccc0c.png)

- 当一个线程要去修改`Account对象`中的值时，`先获取值prev（调用get方法）`，然后再将其设置为新的值`next`（调用cas方法）。在调用cas方法时，会将`prev`与`Account中的余额`进行比较。
  - 如果两者`相等`，就说明该值还未被其他线程修改，此时便可以进行修改操作。
  - 如果两者`不相等`，就不设置值，重新获取值prev（调用get方法），然后再将其设置为新的值next（调用cas方法），直到修改成功为止。

**注意 :**

- 其实 `CAS` 的底层是 **lock cmpxchg** 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证`【比较-交换】`的 **`原子性`**。
- 在多核状态下，某个核执行到带 lock 的指令时，**CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。**

![img](https://img-blog.csdnimg.cn/20210202190842397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

#### volatile的作用

- 在上面代码中的`AtomicInteger类`，**保存值的`value属性`使用了`volatile 修饰`**。获取共享变量时，为了`保证该变量的可见性`，需要使用 **volatile 修饰**。
- volatile可以用来修饰 **`成员变量和静态成员变量`**，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。**`即一个线程对 volatile 变量的修改，对另一个线程可见。`**

$$
注意: volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）
$$

- **`CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果`**

#### 为什么CAS+重试(无锁)效率高

- **`使用CAS+重试---无锁`情况下，即使`重试失败`，\**线程始终在高速运行，没有停歇\**，而 `synchronized`会让线程在没有获得锁的时候，`发生上下文切换，进入阻塞`。**
  - 打个比喻：线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大
- 但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。

#### CAS 的特点 (乐观锁和悲观锁的特点)

结合 `CAS 和 volatile` 可以实现`无锁并发`，适用于`线程数少、多核 CPU` 的场景下。

- `CAS` 是基于`乐观锁`的思想：**最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。**
- `synchronized` 是基于`悲观锁`的思想：**最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。**
- CAS 体现的是`无锁并发、无阻塞并发`，请仔细体会这两句话的意思
  - 但如果竞争激烈(写操作多)，可以想到重试必然频繁发生，**反而效率会受影响**
  - 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一







## 不可变类设计 String

$$
如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改

类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性
$$

**不可变**

- 如果一个对象在`不能够修改其内部状态（属性）`，那么它就是`线程安全`的，因为 **`不存在并发修改`**。

#### 日期转换的问题

**问题提出**
下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的

```
package com.current.demo;

import lombok.extern.slf4j.Slf4j;

import java.text.SimpleDateFormat;

/**
 * @program: threadDemo
 * @description: 日期转换中的线程安全问题
 * @author: mengjianglong@e6yun.com
 * @create: 2021-12-13 10:06
 **/
@Slf4j(topic = "SimpleDateFormatTest")
public class SimpleDateFormatTest {
    public static void main(String[] args) {
        SimpleDateFormat sf = new SimpleDateFormat("yyyy-MM-dd");
        for (int i = 0; i < 10; i++) {
            new Thread(()->{
                log.info("{}",sf.parse("2021-12-13"));
            }).start();
        }
    }
}
```

- 有很大几率出现 `java.lang.NumberFormatException`或者出现不正确的日期解析结果，例如：

```
Exception in thread "Thread-3" java.lang.NumberFormatException: multiple points
	at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1890)
	at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110)
	at java.lang.Double.parseDouble(Double.java:538)
	at java.text.DigitList.getDouble(DigitList.java:169)
	at java.text.DecimalFormat.parse(DecimalFormat.java:2089)
	at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1869)
	at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514)
	at java.text.DateFormat.parse(DateFormat.java:364)
	at com.current.demo.SimpleDateFormatTest.lambda$main$0(SimpleDateFormatTest.java:21)
	at java.lang.Thread.run(Thread.java:748)
Exception in thread "Thread-8" java.lang.NumberFormatException: multiple points
	at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1890)
	at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110)
	at java.lang.Double.parseDouble(Double.java:538)
	at java.text.DigitList.getDouble(DigitList.java:169)
	at java.text.DecimalFormat.parse(DecimalFormat.java:2089)
	at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1869)
	at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1514)
	at java.text.DateFormat.parse(DateFormat.java:364)
	at com.current.demo.SimpleDateFormatTest.lambda$main$0(SimpleDateFormatTest.java:21)
	at java.lang.Thread.run(Thread.java:748)
10:10:36.990 [Thread-5] INFO SimpleDateFormatTest - Mon Dec 13 00:00:00 CST 2021
10:10:36.990 [Thread-6] INFO SimpleDateFormatTest - Mon Dec 13 00:00:00 CST 2021
10:10:36.986 [Thread-9] INFO SimpleDateFormatTest - Mon Dec 13 00:00:00 CST 2021
10:10:36.985 [Thread-4] INFO SimpleDateFormatTest - Mon Dec 13 00:00:00 CST 2021
10:10:36.990 [Thread-0] INFO SimpleDateFormatTest - Mon Dec 13 00:00:00 CST 2021
10:10:36.986 [Thread-2] INFO SimpleDateFormatTest - Mon Dec 13 00:00:00 CST 2021
10:10:36.990 [Thread-7] INFO SimpleDateFormatTest - Mon Dec 13 00:00:00 CST 2021
10:10:36.990 [Thread-1] INFO SimpleDateFormatTest - Mon Dec 13 00:00:00 CST 2021
```

- **思路: 使用同步锁**
  这样虽能解决问题，但带来的是`性能`上的损失，并不算很好, 加锁耗性能

```
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                synchronized (sdf) {
                    try {
                        log.debug("{}", sdf.parse("2020-12-29"));
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }
```

- **思路 - 使用JD8中的 `不可变日期格式化类`**
- **`如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改啊`**！这样的对象在Java 中有很多，例如在 Java 8 后，提供了一个新的日期格式化类：

```
public static void main(String[] args) {
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd");
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                TemporalAccessor date = dtf.parse("2020-12-29");
                log.debug("{}", date);
            }).start();
        }
    }
```

可以看 DateTimeFormatter 的文档：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201229214014754.png)

- `不可变对象`，实际是另一种`避免竞争`的方式。

#### final 的使用

- **Integer、Double、String、DateTimeFormatter以及基本类型包装类, 都是使用`final`来修饰的**
- 另一个大家更为熟悉的 `String 类`也是不可变的，以它为例，说明一下不可变类设计的要素
- 发现该类、类中所有属性都是 `final` 的，属性用 final 修饰保证了该属性是`只读`的，不能修改，**`类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性`**。

##### 保护性拷贝

- 使用字符串时，也有一些跟修改相关的方法啊，比如`substring、replace` 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例：

```
public String substring(int beginIndex, int endIndex) {
    if (beginIndex < 0) {
        throw new StringIndexOutOfBoundsException(beginIndex);
    }
    if (endIndex > value.length) {
        throw new StringIndexOutOfBoundsException(endIndex);
    }
    int subLen = endIndex - beginIndex;
    if (subLen < 0) {
        throw new StringIndexOutOfBoundsException(subLen);
    }
    // 上面是一些校验，下面才是真正的创建新的String对象
    return ((beginIndex == 0) && (endIndex == value.length)) ? this
            : new String(value, beginIndex, subLen);
}
```

- 发现其方法最后是调用`String 的构造方法创建了一个新字符串`，**再进入这个构造看看，是否对 final char[] value 做出了修改：结果发现也没有，构造新字符串对象时，会生成新的 char[] value，对内容进行复制。**
- 这种通过创建副本对象来避免共享的手段称之为`【保护性拷贝（defensive copy）】`

```
public String(char value[], int offset, int count) {
    if (offset < 0) {
        throw new StringIndexOutOfBoundsException(offset);
    }
    if (count <= 0) {
        if (count < 0) {
            throw new StringIndexOutOfBoundsException(count);
        }
        if (offset <= value.length) {
            this.value = "".value;
            return;
        }
    }
    // Note: offset or count might be near -1>>>1.
    if (offset > value.length - count) {
        throw new StringIndexOutOfBoundsException(offset + count);
    }
    // 上面是一些安全性的校验，下面是给String对象的value赋值，新创建了一个数组来保存String对象的值
    this.value = Arrays.copyOfRange(value, offset, offset+count);
}
```

##### final原理

- 设置 final 变量的原理
  - 理解了 `volatile 原理 (读写屏障)`，再对比 final 的实现就比较简单了

```
public class TestFinal {
 final int a = 20; 
 }
```

字节码

```
0: aload_0
1: invokespecial #1 // Method java/lang/Object."<init>":()V
4: aload_0
5: bipush 20
7: putfield #2 // Field a:I
 <-- 写屏障
10: retu
```

- 发现 final 变量的赋值也会通过 **putfield** 指令来完成，同样在这条指令之后也会加入`写屏障`，**保证在其它线程读到它的值时不会出现为 0 的情况。**

#### 享元设计模式

- 简介定义英文名称：Flyweight pattern,重用数量有限的同一类对象`。
  - 结构型模式

- 享元模式的体现
  - 1、在JDK中`Boolean，Byte，Short，Integer，Long，Character`等包装类提供了`valueOf`方法，例如 Long 的`valueOf`会缓存`-128~127`之间的 Long 对象，**在这个范围之间会重用对象，大于这个范围，才会新建 Long 对象**

```
public static Long valueOf(long l) {
    final int offset = 128;
    if (l >= -128 && l <= 127) { // will cache
        return LongCache.cache[(int)l + offset];
    }
    return new Long(l);
}
```

注意：

- Byte, Short, Long 缓存的范围都是-128-127
- Character 缓存的范围是 0-127
- Boolean 缓存了 TRUE 和 FALSE
- Integer的默认范围是 -128~127，最小值不能变，但最大值可以通过调整虚拟机参数 "-Djava.lang.Integer.IntegerCache.high "来改变











## 阻塞队列BlockingQueue原理



### 阻塞队列分类

#### ArrayBlockingQueue 数组有界队列

#### ConcurrentLinkedQueue 链表有界队列

#### PriorityBlockingQueue 优先级排序无界队列

#### DelayQueue 延时无界队列



### 框架应用

#### 基于BlockingQueue手写线程池

#### 基于BlockingQueue手写消息中间件

#### 基于BlockingQueue手写日志框架



## Executor线程池详解及核心源码剖析

### 为什么要使用线程池

```
池化技术有很多, 比如线程池、数据库连接池、HTTP连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。
```

线程池提供了一种 **限制和管理资源**（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。

这里借用 **《Java 并发编程的艺术》** 提到的来说一下使用线程池的好处：

- **`降低资源消耗。`通过重复利用已创建的线程降低线程创建和销毁造成的消耗。**(创建的线程,实际最后要和操作系统的线程做映射,很消耗资源)
- **`提高响应速度。`当任务到达时，任务可以不需要等到线程创建就能立即执行。**
- **`提高线程的可管理性。`线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。**

![img](https://img-blog.csdnimg.cn/img_convert/11a58fc2d33881fcdf40e1980ca56cdb.png)

- 线程池类似于**消费者**，得到阻塞队列中已有的任务并执行
- 阻塞队列中维护了由主线程（或者其他线程）所产生的的任务
- 主线程类似于**生产者**，产生任务并放入阻塞队列中

自定义线程池的实现步骤 :

- 步骤1：自定义拒绝策略接口
- 步骤2：自定义任务阻塞队列
- 步骤3：自定义线程池
- 步骤4：测试

```
package com.current.demo;

import lombok.extern.slf4j.Slf4j;

import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @program: threadDemo
 * @description: 自定义线程池
 * @author: mengjianglong@e6yun.com
 * @create: 2021-12-13 11:04
 **/
@Slf4j(topic = "TestPool")
public class TestPool {
    public static void main(String[] args) {
        ThreadPool threadPool = new ThreadPool(1, 1000, TimeUnit.MILLISECONDS, 1, new RejectPolicy<Runnable>() {
            @Override
            public void reject(BlockingQueue<Runnable> queue, Runnable task) {
                // 拒绝策略
                // 1、死等
                // queue.put(task);

                // 2、带超时等待
                queue.offer(task, 2000, TimeUnit.MILLISECONDS);

                // 3、让调用者放弃任务执行
                // log.debug("放弃-{}", task);

                // 4、让调用者抛弃异常
                // throw new RuntimeException("任务执行失败" + task);

                // 5、让调用者自己执行任务
                // task.run();
            }
        });
        // 创建5个任务
        for (int i = 0; i < 4; i++) {
            int j = i;
            threadPool.execute(new Runnable() {
                @Override
                public void run() {
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    log.debug("{}", j);
                }
            });
        }
    }
}

/**
 * 线程池
 */
@Slf4j(topic = "ThreadPool")
class ThreadPool{
    // 核心线程大小
    private Integer coreSize;
    // 获取任务的超时时间
    private long timeout;
    // 时间单位
    private TimeUnit timeUnit;
    // 阻塞队列
    private BlockingQueue<Runnable> queue;
    // 线程集合
    private Set<Worker> workerSet = new HashSet<>();

    // 拒绝策略
    private RejectPolicy<Runnable> rejectPolicy;
    public ThreadPool(int coreSize, long timeout, TimeUnit timeUnit, int queueCapacity, RejectPolicy<Runnable> rejectPolicy) {
        this.coreSize = coreSize;
        this.timeout = timeout;
        this.timeUnit = timeUnit;
        this.queue = new BlockingQueue<>(queueCapacity);
        this.rejectPolicy = rejectPolicy;
    }

    // 执行任务
    public void execute(Runnable task) {
        synchronized (workerSet) {
            // 当任务没有超过线程数, 说明当前worker线程可以消费这些任务, 不用将任务加入到阻塞队列中
            if (workerSet.size() < coreSize) {
                Worker worker = new Worker(task);
                log.debug("新增 worker {}, {}", worker, task);
                workerSet.add(worker);
                worker.start();
            } else {
                // taskQueue.put(task); // 这一种死等
                // 拒绝策略
                // 1、死等
                // 2、带超时等待
                // 3、让调用者放弃任务执行
                // 4、让调用者抛弃异常
                // 5、让调用者自己执行任务
                queue.tryPut(rejectPolicy, task);

            }
        }
    }

    /**
     * 工作线程类
     */
    class Worker extends Thread{
        private Runnable task;

        Worker(Runnable task){
            this.task = task;
        }
        @Override
        public void run() {
            while (task != null || (task = (queue.poll(timeout,timeUnit))) != null){
                try {
                    log.debug("正在执行...{}", task);
                    task.run();
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    task = null;
                }
            }
            // 将线程集合中的线程移除
            synchronized (workerSet) {
                log.debug("worker被移除 {}", this);
                workerSet.remove(this);
            }
        }
    }
}


/**
 * 阻塞队列
 */
@Slf4j(topic = "BlockingQueue")
class BlockingQueue<T>{
    // 1、任务队列
    private Deque<T> deque = new ArrayDeque<>();

    // 2、锁
    private ReentrantLock lock = new ReentrantLock();
    // 3、生产者的条件变量 (当阻塞队列塞满任务的时候, 没有空间, 此时进入条件变量中等待)
    private Condition fullWaitSet = lock.newCondition();
    // 4、消费者的条件变量 (当没有任务可以消费的时候, 进入条件变量中等待)
    private Condition emptyWaitSet = lock.newCondition();
    // 5、阻塞队列的容量
    private int capacity;
    BlockingQueue(int capacity){
        this.capacity = capacity;
    }

    // 从阻塞队列中获取任务, 如果没有任务, 会等待指定的时间
    public T poll(long timeout, TimeUnit unit) {
        lock.lock();

        try {
            // 将timeout统一转换为纳秒
            long nanos = unit.toNanos(timeout);

            while (deque.isEmpty()){
                if (nanos <= 0) {
                    return null;
                }

                // 返回值的时间(剩余时间) = 等待时间 - 经过时间 所以不存在虚假唤醒(时间还没等够就被唤醒,然后又从新等待相同时间)
                try {
                    nanos = emptyWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = deque.removeFirst();
            // 唤醒生产者进行生产, 此时阻塞队列没有满
            fullWaitSet.signal();
            return t;
        } finally {
            lock.unlock();
        }
    }

    // 从阻塞队列中获取任务, 如果没有任务,会一直等待
    public T take() {
        lock.lock();

        try {
            while (deque.isEmpty()){
                try {
                    emptyWaitSet.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T t = deque.removeFirst();
            fullWaitSet.signal();
            return t;
        } finally {
            lock.unlock();
        }
    }

    // 往阻塞队列中添加任务
    public void put(T task){
        lock.lock();

        try {
            while (deque.size() == capacity){
                try {
                    log.debug("等待进入阻塞队列...");
                    fullWaitSet.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            deque.addLast(task);
            log.debug("加入任务阻塞队列 {}", task);
            // 此时阻塞队列中有任务了, 唤醒消费者进行消费任务
            emptyWaitSet.signal();
        } finally {
            lock.unlock();
        }
    }

    // 往阻塞队列中添加任务(带超时)
    public boolean offer(T task, long timeout, TimeUnit timeUnit) {
        lock.lock();

        try {
            long nanos = timeUnit.toNanos(timeout);
            while (deque.size() == capacity){
                try {
                    if (nanos <= 0) {
                        return false;
                    }
                    log.debug("等待进入阻塞队列 {}...", task);
                    nanos = fullWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            log.debug("加入任务阻塞队列 {}", task);
            deque.addLast(task);
            // 此时阻塞队列中有任务了, 唤醒消费者进行消费任务
            emptyWaitSet.signal();
            return true;
        } finally {
            lock.unlock();
        }
    }

    // 获取队列大小
    public int size() {
        lock.lock();
        try {
            return deque.size();
        } finally {
            lock.unlock();
        }
    }

    public void tryPut(RejectPolicy<T> rejectPolicy, T task) {
        lock.lock();
        try {
            // 判断队列是否满
            if (deque.size() == capacity) {
                rejectPolicy.reject(this, task);
            } else {
                // 有空闲
                log.debug("加入任务队列 {}", task);
                deque.addLast(task);
                emptyWaitSet.signal();
            }
        } finally {
            lock.unlock();
        }
    }
}

@FunctionalInterface
interface RejectPolicy<T>{
    void reject(BlockingQueue<T> queue, T task);
}
```

**实现了一个简单的线程池**

- 阻塞队列BlockingQueue用于暂存来不及被线程执行的任务
  - 也可以说是平衡生产者和消费者执行速度上的差异
  - 里面的获取任务和放入任务用到了 **`生产者消费者模式`**
- 线程池中对线程Thread进行了再次的封装，封装为了Worker
  - 在调用 **任务对象 (Runnable、Callable)** 的run方法时，线程会去执行该任务，执行完毕后还会**到阻塞队列中获取新任务来执行**
- 线程池中执行任务的主要方法为`execute`方法
  - 执行时要判断正在执行的线程数是否大于了线程池容量





### 如何基于ThreadPoolExecutor自定义线程池

#### **线程池的继承关系**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210102231106611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

#### **Executor 框架结构 : 主要由三大部分组成**

- **任务类** (`Runnable` /`Callable`)

  - 执行任务需要实现的 **`Runnable 接口` 或 `Callable接口`**。Runnable 接口或 Callable 接口 实现类都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。

- **任务的执行** (`Executor`)

  - 如上图所示，包括任务执行机制的核心接口 Executor ，以及继承自 Executor 接口的 ExecutorService 接口。ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 这两个关键类实现了 ExecutorService 接口。
  - 这里有很多底层的类关系，但是，实际上我们需要更多关注的是 **ThreadPoolExecutor** 这个类，它在我们实际使用线程池的过程中，使用频率非常高。

- **异步计算的结果** (`Future`)

  - **`Future 接口`** 以及 Future接口的 **`实现类 FutureTask 类`** 都可以代表异步计算的结果。

  - 当把 Runnable接口 或 Callable 接口 的实现类提交给 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。（调用 `submit()` 方法时会返回一个 `FutureTask`对象）

    - Futrue和join方法类似, `futrue的get方法`需要等待线程执行完毕,才可以获取的线程的执行结果。也称之为`保护性暂停`

    ![img](https://img-blog.csdnimg.cn/20210102232801152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

#### **Executor 框架的使用示意图**

![Executor 框架的使用示意图](https://imgconvert.csdnimg.cn/aHR0cDovL215LWJsb2ctdG8tdXNlLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8xOC01LTMwLzg0ODIzMzMwLmpwZw?x-oss-process=image/format,png)

1. 主线程首先要创建实现 **Runnable** 或者 **Callable** 接口的任务对象。
2. 把创建完成的实现 **Runnable/Callable接口的对象** 直接交给 **ExecutorService** 执行:
   - `ExecutorService.execute（Runnable command）`）
   - `ExecutorService.submit（Runnable task）`
   - `ExecutorService.submit（Callable <T> task）`
3. 如果执行 ExecutorService.submit（…），ExecutorService 将返回一个`实现Future接口的对象`
4. 最后，**主线程可以执行 FutureTask.get()方法来等待任务执行完成**。主线程也可以执行 FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行



### 线程池状态

- **ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量**

```
// 线程池状态
// runState is stored in the high-order bits
// RUNNING 高3位为111
private static final int RUNNING    = -1 << COUNT_BITS;

// SHUTDOWN 高3位为000
private static final int SHUTDOWN   =  0 << COUNT_BITS;

// 高3位 001
private static final int STOP       =  1 << COUNT_BITS;

// 高3位 010
private static final int TIDYING    =  2 << COUNT_BITS;

// 高3位 011
private static final int TERMINATED =  3 << COUNT_BITS;
```

|  状态名称  | 高3位值 | 描述                                          |
| :--------: | ------- | --------------------------------------------- |
|  RUNNING   | 111     | 接收新任务，同时处理任务队列中的任务          |
|  SHUTDOWN  | 000     | 不接受新任务，但是处理任务队列中的任务        |
|    STOP    | 001     | 中断正在执行的任务，同时抛弃阻塞队列中的任务  |
|  TIDYING   | 010     | 任务执行完毕，活动线程为0时，即将进入终结阶段 |
| TERMINATED | 011     | 终结状态                                      |

- 从数字上比较(第一位是符号位)，`TERMINATED > TIDYING > STOP > SHUTDOWN > RUNNING`

线程池状态和线程池中线程的数量 **由一个原子整型ctl来共同表示**

- 使用一个数来表示两个值的主要原因是：**可以通过一次CAS同时更改两个属性的值**

```
// 原子整数，前3位保存了线程池的状态，剩余位保存的是线程数量
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));

// 并不是所有平台的int都是32位。
// 去掉前三位保存线程状态的位数，剩下的用于保存线程数量
// 高3位为0，剩余位数全为1
private static final int COUNT_BITS = Integer.SIZE - 3;

// 2^COUNT_BITS次方，表示可以保存的最大线程数
// CAPACITY 的高3位为 0
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;
```

获取线程池状态、线程数量以及合并两个值的操作

```
// Packing and unpacking ctl
// 获取运行状态
// 该操作会让除高3位以外的数全部变为0
private static int runStateOf(int c)     { return c & ~CAPACITY; }

// 获取运行线程数
// 该操作会让高3位为0
private static int workerCountOf(int c)  { return c & CAPACITY; }

// 计算ctl新值
private static int ctlOf(int rs, int wc) { return rs | wc; }
```

这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作进行赋值

```
// c 为旧值， ctlOf 返回结果为新值
ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));

// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们
private static int ctlOf(int rs, int wc) { return rs | wc; }
```

### 线程池的属性

![img](https://img-blog.csdnimg.cn/20210102234631532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

#### 构造方法及参数

- **ThreadPoolExecutor最全的构造方法**
- 也是构造自定义线程池的方法

```
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)
```

##### **参数解释**

- **corePoolSize**：核心线程数
- **maximumPoolSize**：最大线程数
  - maximumPoolSize - corePoolSize = 救急线程数
  - `注意 :` 救急线程在**没有空闲的核心线程**和**任务队列满了**的情况才使用救急线程
- **keepAliveTime**：救急线程空闲时的最大生存时间 (核心线程可以一直运行)
- **unit**：时间单位 (针对救急线程)
- **workQueue**：阻塞队列（存放任务）
  - 有界阻塞队列 ArrayBlockingQueue
  - 无界阻塞队列 LinkedBlockingQueue
  - 最多只有一个同步元素的 SynchronousQueue
  - 优先队列 PriorityBlockingQueue
- **threadFactory**：线程工厂（给线程取名字）
- **handler**：拒绝策略

##### 工作方式

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210202214622633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

- 当一个任务传给线程池以后，可能有以下几种可能
  - 将任务分配给一个核心线程来执行
  - 核心线程都在执行任务，将任务放到阻塞队列workQueue中等待被执行
  - 阻塞队列满了，使用救急线程来执行任务
    - 救急线程用完以后，超过生存时间（keepAliveTime）后会被释放
  - 任务总数大于了 最大线程数（maximumPoolSize）与阻塞队列容量的最大值（workQueue.capacity），使用拒接策略

##### 拒绝策略

- 如果线程到达 maximumPoolSize 仍然有新任务这时会执行**拒绝策略**。拒绝策略 jdk 提供了 4 种实现

![img](https://img-blog.csdnimg.cn/img_convert/9c9e1f25573ca20f44ac080a5f6540c5.png)

口诀法：**拒中丢老调**（线程池拒绝策略：中止策略、丢弃策略、弃老策略、调用者运行策略）

- `AbortPolicy 中止策略`：丢弃任务并抛出RejectedExecutionException异常。**这是默认策略**

```
1.这是线程池默认的拒绝策略，在任务不能再提交的时候，抛出异常，及时反馈程序运行状态。如果是比较关键的业务，推荐使用此拒绝策略，这样子在系统不能承载更大的并发量的时候，能够及时的通过异常发现。
2.功能：当触发拒绝策略时，直接抛出拒绝执行的异常，中止策略的意思也就是打断当前执行流程.
3.使用场景：这个就没有特殊的场景了，但是有一点要正确处理抛出的异常。ThreadPoolExecutor中默认的策略就是AbortPolicy，ExecutorService接口的系列ThreadPoolExecutor因为都没有显示的设置拒绝策略，所以默认的都是这个。但是请注意，ExecutorService中的线程池实例队列都是无界的，也就是说把内存撑爆了都不会触发拒绝策略。当自己自定义线程池实例时，使用这个策略一定要处理好触发策略时抛的异常，因为他会打断当前的执行流程。
```

- `DiscardPolicy 丢弃策略`：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。

```
1.使用此策略，可能会使我们无法发现系统的异常状态。建议是一些无关紧要的业务采用此策略。例如，本人的博客网站统计阅读量就是采用的这种拒绝策略。
功能：直接静悄悄的丢弃这个任务，不触发任何动作。
使用场景：如果你提交的任务无关紧要，你就可以使用它 。因为它就是个空实现，会悄无声息的吞噬你的的任务。所以这个策略基本上不用了。
```

- `DiscardOldestPolicy 弃老策略`：丢弃队列最前面的任务，然后重新提交被拒绝的任务。

```
1.此拒绝策略，是一种喜新厌旧的拒绝策略。是否要采用此种拒绝策略，还得根据实际业务是否允许丢弃老任务来认真衡量。
功能：如果线程池未关闭，就弹出队列头部的元素，然后尝试执行
使用场景：这个策略还是会丢弃任务，丢弃时也是毫无声息，但是特点是丢弃的是老的未执行的任务，而且是待执行优先级较高的任务。基于这个特性，想到的场景就是，发布消息和修改消息，当消息发布出去后，还未执行，此时更新的消息又来了，这个时候未执行的消息的版本比现在提交的消息版本要低就可以被丢弃了。因为队列中还有可能存在消息版本更低的消息会排队执行，所以在真正处理消息的时候一定要做好消息的版本比较。
```

- `CallerRunsPolicy 调用者运行策略`：由调用线程处理该任务。

```
功能：当触发拒绝策略时，只要线程池没有关闭，就由提交任务的当前线程处理。
使用场景：一般在不允许失败的、对性能要求不高、并发量较小的场景下使用，因为线程池一般情况下不会关闭，也就是提交的任务一定会被运行，但是由于是调用者线程自己执行的，当多次提交任务时，就会阻塞后续任务执行，性能和效率自然就慢了。
```

```
1.线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。
2.当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排队，直到有空闲的线程。
3.如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急。
4.如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 下面的前4 种实现，其它著名框架也提供了实现
	1.ThreadPoolExecutor.AbortPolicy让调用者抛出 RejectedExecutionException 异常，这是默认策略
	2.ThreadPoolExecutor.CallerRunsPolicy 让调用者运行任务
	3.ThreadPoolExecutor.DiscardPolicy 放弃本次任务
	4.ThreadPoolExecutor.DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之
	5.Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题
	6.Netty 的实现，是创建一个新线程来执行任务
	7.ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略
	8.PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略
5.当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由keepAliveTime 和 unit 来控制。
```

```
package com.current.demo;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.*;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * @program: threadDemo
 * @description: 自定义线程池
 * @author: mengjianglong@e6yun.com
 * @create: 2021-12-13 16:56
 **/
@Slf4j(topic = "ThreadPoolExecutorTest")
public class ThreadPoolExecutorTest {
    private static AtomicInteger threadId = new AtomicInteger(0);
    private static int coreSize = 5;
    private static int maximumPoolSize = 7;
    private static long keepAliveTime = 10;
    public static void main(String[] args) {
        // 阻塞队列存放任务
        ArrayBlockingQueue queue = new ArrayBlockingQueue(10);

        // 线程工厂
        ThreadFactory threadFactory = new ThreadFactory() {
            @Override
            public Thread newThread(Runnable r) {
                return new Thread(r,"work_mjl_"+threadId.getAndIncrement());
            }
        };

        ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(coreSize,maximumPoolSize,keepAliveTime,TimeUnit.SECONDS,queue,threadFactory);

        for (int i = 0; i < 30; i++) {
            int j = i;
            poolExecutor.execute(new Runnable() {
                @Override
                public void run() {
                    log.info("ccccccccccc"+j);
                }
            });
        }
        //RejectedExecutionHandler handler
    }
}
```

```
Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task com.current.demo.ThreadPoolExecutorTest$2@5d6f64b1 rejected from java.util.concurrent.ThreadPoolExecutor@32a1bec0[Running, pool size = 7, active threads = 7, queued tasks = 10, completed tasks = 0]
	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)
	at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)
	at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)
	at com.current.demo.ThreadPoolExecutorTest.main(ThreadPoolExecutorTest.java:37)
17:08:36.130 [work_mjl_5] INFO ThreadPoolExecutorTest - ccccccccccc15
17:08:36.130 [work_mjl_6] INFO ThreadPoolExecutorTest - ccccccccccc16
17:08:36.132 [work_mjl_6] INFO ThreadPoolExecutorTest - ccccccccccc5
17:08:36.130 [work_mjl_1] INFO ThreadPoolExecutorTest - ccccccccccc1
17:08:36.132 [work_mjl_6] INFO ThreadPoolExecutorTest - ccccccccccc6
17:08:36.132 [work_mjl_1] INFO ThreadPoolExecutorTest - ccccccccccc7
17:08:36.132 [work_mjl_1] INFO ThreadPoolExecutorTest - ccccccccccc9
17:08:36.132 [work_mjl_1] INFO ThreadPoolExecutorTest - ccccccccccc10
17:08:36.132 [work_mjl_1] INFO ThreadPoolExecutorTest - ccccccccccc11
17:08:36.132 [work_mjl_1] INFO ThreadPoolExecutorTest - ccccccccccc13
17:08:36.130 [work_mjl_4] INFO ThreadPoolExecutorTest - ccccccccccc4
17:08:36.132 [work_mjl_1] INFO ThreadPoolExecutorTest - ccccccccccc14
17:08:36.130 [work_mjl_3] INFO ThreadPoolExecutorTest - ccccccccccc3
17:08:36.130 [work_mjl_2] INFO ThreadPoolExecutorTest - ccccccccccc2
17:08:36.130 [work_mjl_0] INFO ThreadPoolExecutorTest - ccccccccccc0
17:08:36.132 [work_mjl_6] INFO ThreadPoolExecutorTest - ccccccccccc8
17:08:36.132 [work_mjl_5] INFO ThreadPoolExecutorTest - ccccccccccc12
```

### newFixedThreadPool

- 这个是`Executors类`提供的工厂方法来创建线程池！`Executors` 是Executor 框架的工具类！

```
public class TestFixedThreadPool {
   public static void main(String[] args) {
      // 自定义线程工厂
      ThreadFactory factory = new ThreadFactory() {
         AtomicInteger atomicInteger = new AtomicInteger(1);

         @Override
         public Thread newThread(Runnable r) {
            return new Thread(r, "myThread_" + atomicInteger.getAndIncrement());
         }
      };

      // 创建核心线程数量为2的线程池
      // 通过 ThreadFactory可以给线程添加名字

      ExecutorService executorService = Executors.newFixedThreadPool(2, factory);

      // 任务
      Runnable runnable = new Runnable() {
         @Override
         public void run() {
            System.out.println(Thread.currentThread().getName());
            System.out.println("this is fixedThreadPool");
         }
      };
      
      executorService.execute(runnable);
   }
}
```

**固定大小的线程池可以传入两个参数**

- 核心线程数：**nThreads**
- 线程工厂：**threadFactory**

**内部构造方法**

```
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>(),
                                      threadFactory);
    }
```

**特点**

1. 核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间
2. `阻塞队列是无界的，可以放任意数量的任务`
3. **适用于任务量已知，相对耗时的任务**



### newCachedThreadPool

```
ExecutorService executorService = Executors.newCachedThreadPool();
```

**内部构造方法**

```
public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }
```

**特点**

- **没有核心线程**，最大线程数为`Integer.MAX_VALUE`，**所有创建的线程都是救急线程 (`可以无限创建`)**，空闲时生存时间为60秒
- 阻塞队列使用的是**SynchronousQueue**
  - SynchronousQueue是一种特殊的队列
  - **没有容量**，没有线程来取是放不进去的
  - 只有当线程取任务时，才会将任务放入该阻塞队列中
- **整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程。 适合任务数比较密集，但每个任务执行时间较短的情况**



### newSingleThreadExecutor

**内部构造方法**

```
public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
    }


public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>(),
                                    threadFactory));
    }
```

**使用场景：**

1. **希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。** 任务执行完毕，这唯一的线程也不会被释放。
2. 区别：
   1. `和自己创建单线程执行任务的区别`：**自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而newSingleThreadExecutor线程池还会新建一个线程，保证池的正常工作**
   2. Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改
      1. FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法
   3. 和Executors.newFixedThreadPool(1) 初始时为1时的区别：Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改，对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改



### Executors 返回线程池对象的弊端如下 (`重点`)

```
注意: Executors 返回线程池对象的弊端如下：
1.FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE (无界阻塞队列),可能堆积大量的请求，从而导致 OOM。
2.CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。
3.建议使用ThreadPoolExecutor来创建线程
```

避免上面的措施 : **`使用有界队列，控制线程创建数量。`**

除了避免 OOM 的原因之外，不推荐使用 `Executors`提供的两种快捷的线程池的原因还有：

1. **实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。**
2. 我们应该显示地给我们的线程池命名，这样有助于我们定位问题。



###  执行/提交任务 execute/submit

```
// 执行任务
void execute(Runnable command);

// 提交任务 task，用返回值 Future 获得任务执行结果，Future的原理就是利用我们之前讲到的保护性暂停模式来接受返回结果的，主线程可以执行 FutureTask.get()方法来等待任务执行完成
<T> Future<T> submit(Callable<T> task);

// 提交 tasks 中所有任务
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException;
 
// 提交 tasks 中所有任务，带超时时间
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,long timeout, TimeUnit unit) throws InterruptedException;

// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消
<T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException;

// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间
<T> T invokeAny(Collection<? extends Callable<T>> tasks,long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;
```

#### execute()方法

```
execute(Runnable command)
```

- 传入一个Runnable对象，执行其中的run方法

**源码解析**

```
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();

    // 获取ctl
    int c = ctl.get();
    
    // 判断当前启用的线程数是否小于核心线程数
    if (workerCountOf(c) < corePoolSize) {
        // 为该任务分配线程
        if (addWorker(command, true))
            // 分配成功就返回
            return;
        
        // 分配失败再次获取ctl
        c = ctl.get();
    }
    
    // 分配和信息线程失败以后
    // 如果池状态为RUNNING并且插入到任务队列成功
    if (isRunning(c) && workQueue.offer(command)) {
        
        // 双重检测，可能在添加后线程池状态变为了非RUNNING
        int recheck = ctl.get();
        
        // 如果池状态为非RUNNING，则不会执行新来的任务
        // 将该任务从阻塞队列中移除
        if (! isRunning(recheck) && remove(command))
            // 调用拒绝策略，拒绝该任务的执行
            reject(command);
        
        // 如果没有正在运行的线程
        else if (workerCountOf(recheck) == 0)
            // 就创建新线程来执行该任务
            addWorker(null, false);
    }
    
    // 如果添加失败了（任务队列已满），就调用拒绝策略
    else if (!addWorker(command, false))
        reject(command);
}
```

其中调用了 **addWoker()** 方法，再看看看这个方法

```
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        // 如果池状态为非RUNNING状态、线程池为SHUTDOWN且该任务为空 或者阻塞队列中已经有任务
        if (rs >= SHUTDOWN &&
            ! (rs == SHUTDOWN &&
               firstTask == null &&
               ! workQueue.isEmpty()))
            // 创建新线程失败
            return false;

        for (;;) {
            // 获得当前工作线程数
            int wc = workerCountOf(c);

            // 参数中 core 为true
            // CAPACITY 为 1 << COUNT_BITS-1，一般不会超过
            // 如果工作线程数大于了核心线程数，则创建失败
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            // 通过CAS操作改变c的值
            if (compareAndIncrementWorkerCount(c))
                // 更改成功就跳出多重循环，且不再运行循环
                break retry;
            // 更改失败，重新获取ctl的值
            c = ctl.get();  // Re-read ctl
            if (runStateOf(c) != rs)
                // 跳出多重循环，且重新进入循环
                continue retry;
            // else CAS failed due to workerCount change; retry inner loop
        }
    }

    // 用于标记work中的任务是否成功执行
    boolean workerStarted = false;
    // 用于标记worker是否成功加入了线程池中
    boolean workerAdded = false;
    Worker w = null;
    try {
        // 创建新线程来执行任务
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            // 加锁
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                // 加锁的同时再次检测
                // 避免在释放锁之前调用了shut down
                int rs = runStateOf(ctl.get());

                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    // 将线程添加到线程池中
                    workers.add(w);
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    // 添加成功标志位变为true
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            // 如果worker成功加入了线程池，就执行其中的任务
            if (workerAdded) {
                t.start();
                // 启动成功
                workerStarted = true;
            }
        }
    } finally {
        // 如果执行失败
        if (! workerStarted)
            // 调用添加失败的函数
            addWorkerFailed(w);
    }
    return workerStarted;
}
```

#### submit()方法

```
Future<T> submit(Callable<T> task)
```

- 传入一个Callable对象，用Future来**捕获返回值**

**使用**

```
// 通过submit执行Callable中的call方法
// 通过Future来捕获返回值
Future<String> future = threadPool.submit(new Callable<String>() {
   @Override
   public String call() throws Exception {
      return "hello submit";
   }
});

// 查看捕获的返回值
System.out.println(future.get());
```



### 关闭线程池 shutdown()

#### shutdown()

- **将线程池的状态改为 SHUTDOWN**
- **不再接受新任务，但是会将阻塞队列中的任务执行完**

```
/**
* 将线程池的状态改为 SHUTDOWN
* 不再接受新任务，但是会将阻塞队列中的任务执行完
*/
public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        
        // 修改线程池状态为 SHUTDOWN
        advanceRunState(SHUTDOWN);
        
  		// 中断空闲线程（没有执行任务的线程）
        // Idle：空闲的
        interruptIdleWorkers();
        onShutdown(); // hook for ScheduledThreadPoolExecutor
    } finally {
        mainLock.unlock();
    }
    // 尝试终结，不一定成功
    // 
    tryTerminate();
}

final void tryTerminate() {
    for (;;) {
        int c = ctl.get();
        // 终结失败的条件
        // 线程池状态为RUNNING
        // 线程池状态为 RUNNING SHUTDOWN STOP （状态值大于TIDYING）
        // 线程池状态为SHUTDOWN，但阻塞队列中还有任务等待执行
        if (isRunning(c) ||
            runStateAtLeast(c, TIDYING) ||
            (runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty()))
            return;
        
        // 如果活跃线程数不为0
        if (workerCountOf(c) != 0) { // Eligible to terminate
            // 中断空闲线程
            interruptIdleWorkers(ONLY_ONE);
            return;
        }

        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            // 处于可以终结的状态
            // 通过CAS将线程池状态改为TIDYING
            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                try {
                    terminated();
                } finally {
                    // 通过CAS将线程池状态改为TERMINATED
                    ctl.set(ctlOf(TERMINATED, 0));
                    termination.signalAll();
                }
                return;
            }
        } finally {
            mainLock.unlock();
        }
        // else retry on failed CAS
    }
}
```

#### shutdownNow()

- **将线程池的状态改为 STOP**
- **不再接受新任务，也不会在执行阻塞队列中的任务**
- 会将阻塞队列中未执行的任务返回给调用者
- 并用 interrupt 的方式中断正在执行的任务

```
/**
* 将线程池的状态改为 STOP
* 不再接受新任务，也不会在执行阻塞队列中的任务
* 会将阻塞队列中未执行的任务返回给调用者
* 并用 interrupt 的方式中断正在执行的任务
*/
public List<Runnable> shutdownNow() {
    List<Runnable> tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        
        // 修改状态为STOP，不执行任何任务
        advanceRunState(STOP);
        
        // 中断所有线程
        interruptWorkers();
        
        // 将未执行的任务从队列中移除，然后返回给调用者
        tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }
    // 尝试终结，一定会成功，因为阻塞队列为空了
    tryTerminate();
    return tasks;
}
```

- 其他方法

```
// 不在 RUNNING 状态的线程池，此方法就返回 true
boolean isShutdown();

// 线程池状态是否是 TERMINATED
boolean isTerminated();

// 调用 shutdown 后，由于调用使线程结束线程的方法是异步的并不会等待所有任务运行结束就返回，因此如果它想在线程池 TERMINATED 后做些其它事情，可以利用此方法等待
boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;
```



### 异步模式之工作线程

**定义**

- `让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务`。也可以将其归类为分工模式，它的典型实现就是`线程池`，也体现了经典设计模式中的`享元模式`。
- 例如，海底捞的服务员（线程），轮流处理每位客人的点餐（任务），如果为每位客人都配一名专属的服务员，那么成本就太高了（对比另一种多线程设计模式：Thread-Per-Message）

**`注意:`** **不同任务类型应该使用不同的线程池，这样能够避免饥饿，并能提升效率**

**饥饿**

- 固定大小线程池会有饥饿现象
- 两个工人是同一个线程池中的两个线程
  他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作
  客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待
  后厨做菜：没啥说的，做就是了
  比如工人A 处理了点餐任务，接下来它要等着 工人B 把菜做好，然后上菜，他俩也配合的蛮好; 但现在同时来了两个客人，这个时候工人A 和工人B 都去处理点餐了，这时没人做饭了，饥饿

**解决方法可以增加线程池的大小，不过不是根本解决方案，还是前面提到的，`不同的任务类型，采用不同的线程池`**

```
@Slf4j(topic = "guizy.TestDeadLock")
public class TestStarvation {

    static final List<String> MENU = Arrays.asList("地三鲜", "宫保鸡丁", "辣子鸡丁", "烤鸡翅");
    static Random RANDOM = new Random();
    static String cooking() {
        return MENU.get(RANDOM.nextInt(MENU.size()));
    }
    public static void main(String[] args) {
        ExecutorService waiterPool = Executors.newFixedThreadPool(1);
        ExecutorService cookPool = Executors.newFixedThreadPool(1);

        waiterPool.execute(() -> {
            log.debug("处理点餐...");
            Future<String> f = cookPool.submit(() -> {
                log.debug("做菜");
                return cooking();
            });
            try {
                log.debug("上菜: {}", f.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });
        waiterPool.execute(() -> {
            log.debug("处理点餐...");
            Future<String> f = cookPool.submit(() -> {
                log.debug("做菜");
                return cooking();
            });
            try {
                log.debug("上菜: {}", f.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });

    }
}
```







### 线程池核心原理分析





### 线程池参数如何合理配置

过小会导致程序不能充分地利用系统资源、容易导致饥饿，过大会导致更多的线程上下文切换，占用更多内存

- **CPU 密集型运算**

通常采用 **`cpu 核数 + 1`** 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费

- **I/O 密集型运算**

CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。

经验公式如下：线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间
例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式
4 * 100% * 100% / 50% = 8
例如 4 核 CPU 计算时间是 10% ，其它等待时间是 90%，期望 cpu 被 100% 利用，套用公式
4 * 100% * 100% / 10% = 40

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210202220401865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

### 任务调度线程池 ScheduledExecutorService (`重点`)

- 在『任务调度线程池』功能加入之前，可以使用`java.util.Timer`来实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由`同一个线程`来调度，因此所有任务都是`串行`执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。

```
package com.current.demo;

import lombok.extern.slf4j.Slf4j;
import org.springframework.retry.backoff.Sleeper;

import java.util.Timer;
import java.util.TimerTask;

/**
 * @program: threadDemo
 * @description: Timer定时调度任务
 * @author: mengjianglong@e6yun.com
 * @create: 2021-12-15 14:08
 **/
@Slf4j(topic = "TestTimer")
public class TestTimer {
    public static void main(String[] args) {
        Timer timer = new Timer();

        TimerTask timerTask1 = new TimerTask() {
            @Override
            public void run() {
                log.debug("timerTask 1");
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };

        TimerTask timerTask2 = new TimerTask() {
            @Override
            public void run() {
                log.debug("timerTask 2");
            }
        };

        // 因为Timer只有一个线程执行任务，因此timerTask1执行完成之后才会执行timerTask2，而且在使用Timer时候会提示请使用ScheduledExecutorService代替Timer吧
        timer.schedule(timerTask1,1000);
        timer.schedule(timerTask2,1000);
    }
}
```

使用 ScheduledExecutorService

- ScheduledExecutorService 中schedule方法的使用

```
public class TestTimer {
    public static void main(String[] args) {
        ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);

        executor.schedule(() -> System.out.println("任务1, 执行时间:" + new Date()), 1000, TimeUnit.MILLISECONDS);

        executor.schedule(() -> System.out.println("任务2, 执行时间:" + new Date()), 1000, TimeUnit.MILLISECONDS);
    }
}

任务1, 执行时间:Sun Jan 03 08:53:54 CST 2021
任务2, 执行时间:Sun Jan 03 08:53:54 CST 2021
```

- **ScheduledExecutorService 中 scheduleAtFixedRate方法的使用**//*延迟1s后, 按1s的速率打印running*

```
public class TestTimer {
    public static void main(String[] args) {
        ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
        log.debug("start....");
        // 延迟1s后, 按1s的速率打印running
        executor.scheduleAtFixedRate(() -> log.debug("running"), 1, 1, TimeUnit.SECONDS);
    }
}

08:51:59.930 guizy.TestTimer [main] - start....
08:52:01.050 guizy.TestTimer [pool-1-thread-1] - running
08:52:02.049 guizy.TestTimer [pool-1-thread-1] - running
08:52:03.045 guizy.TestTimer [pool-1-thread-1] - running
08:52:04.046 guizy.TestTimer [pool-1-thread-1] - running
08:52:05.045 guizy.TestTimer [pool-1-thread-1] - running
08:52:06.047 guizy.TestTimer [pool-1-thread-1] - running
```

- ScheduledExecutorService 中scheduleWithFixedDelay方法的使用
  - 睡眠时间 + 速率时间, 为打印的间隔时间

```
public class TestTimer {
    public static void main(String[] args) {
        ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
        log.debug("start....");
        // 延迟1s后, 按1s的速率打印running
        executor.scheduleWithFixedDelay(() -> {
            log.debug("running");
            Sleeper.sleep(2);
        }, 1, 1, TimeUnit.SECONDS);
    }
}

08:56:22.581 guizy.TestTimer [main] - start....
08:56:23.674 guizy.TestTimer [pool-1-thread-1] - running
08:56:26.679 guizy.TestTimer [pool-1-thread-1] - running
08:56:29.680 guizy.TestTimer [pool-1-thread-1] - running
08:56:32.689 guizy.TestTimer [pool-1-thread-1] - running
```

- 整个线程池表现为：线程数固定，任务数多于线程数时，会放入无界队列排队。任务执行完毕，这些线程也不会被释放。用来执行延迟或反复执行的任务。

eg : 如何让每周四 18:00:00 定时执行任务？

```
public class TestSchedule {

    // 如何让每周四 18:00:00 定时执行任务？
    public static void main(String[] args) {
        //  获取当前时间
        LocalDateTime now = LocalDateTime.now();
        System.out.println(now);
        // 获取周四时间
        LocalDateTime time = now.withHour(18).withMinute(0).withSecond(0).withNano(0).with(DayOfWeek.THURSDAY);
        // 如果 当前时间 > 本周周四，必须找到下周周四
        if(now.compareTo(time) > 0) {
            time = time.plusWeeks(1);
        }
        System.out.println(time);
        // initailDelay 代表当前时间和周四的时间差
        // period 一周的间隔时间
        long initailDelay = Duration.between(now, time).toMillis();
        long period = 1000 * 60 * 60 * 24 * 7;
        ScheduledExecutorService pool = Executors.newScheduledThreadPool(1);
        pool.scheduleAtFixedRate(() -> {
            System.out.println("running...");
        }, initailDelay, period, TimeUnit.MILLISECONDS);
    }
}
```



### 正确处理执行任务异常

- 可以发现，如果线程池中的线程执行任务时，**如果任务抛出了异常，默认是中断执行该任务而不是抛出异常或者打印异常信息。**

方法1：**主动捉异常**

```
ExecutorService pool = Executors.newFixedThreadPool(1);
pool.submit(() -> {
	 try {
	 log.debug("task1");
	 int i = 1 / 0;
	 } catch (Exception e) {
	 log.error("error:", e);
	 }
});
```

方法2：**使用 Future，错误信息都被封装进submit方法的返回方法中！**

```
ExecutorService pool = Executors.newFixedThreadPool(1);
Future<Boolean> f = pool.submit(() -> {
	 log.debug("task1");
	 int i = 1 / 0;
	 return true;
});
	log.debug("result:{}", f.get());
```



### Tomcat 线程池

![1594993035182](https://img-blog.csdnimg.cn/img_convert/68b780b8c314dc2ac18b537500b90f03.png)

- LimitLatch 用来限流，可以控制最大连接个数，类似 J.U.C 中的 Semaphore 后面再讲
- Acceptor 只负责【接收新的 socket 连接】
- Poller 只负责监听 socket channel 是否有【可读的 I/O 事件】
- 一旦可读，封装一个任务对象（socketProcessor），提交给 Executor 线程池处理
- Executor 线程池中的工作线程最终负责【处理请求】

Tomcat 线程池扩展了 ThreadPoolExecutor，行为稍有不同

如果总线程数达到 maximumPoolSize，这时不会立刻抛 RejectedExecutionException 异常，而是再次尝试将任务放入队列，如果还失败，才抛出 RejectedExecutionException 异常

```
public void execute(Runnable command, long timeout, TimeUnit unit) {
    submittedCount.incrementAndGet();
    try {
        super.execute(command);
    } catch (RejectedExecutionException rx) {
        if (super.getQueue() instanceof TaskQueue) {
            final TaskQueue queue = (TaskQueue)super.getQueue();
            try {
                // 使任务从新进入阻塞队列
                if (!queue.force(command, timeout, unit)) {
                    submittedCount.decrementAndGet();
                    throw new RejectedExecutionException("Queue capacity is full.");
                }
            } catch (InterruptedException x) {
                submittedCount.decrementAndGet();
                Thread.interrupted();
                throw new RejectedExecutionException(x);
            }
        } else {
            submittedCount.decrementAndGet();
            throw rx;
        }
    }
}
```

TaskQueue.java

```
public boolean force(Runnable o, long timeout, TimeUnit unit) throws InterruptedException {
    if ( parent.isShutdown() )
        throw new RejectedExecutionException(
                "Executor not running, can't force a command into the queue"
        );
    return super.offer(o,timeout,unit); //forces the item onto the queue, to be used if the task is rejected
}
```

Connector 配置

![1594993208807](https://img-blog.csdnimg.cn/img_convert/f5273f7da471b4a4d24a241559f29492.png)

Executor 线程配置

![1594993228313](https://img-blog.csdnimg.cn/img_convert/ebb2634dbf4ec6125b33a038a0564f4d.png)



###  Fork/Join (`熟悉`)

**概念**

1. `Fork/Join` 是 JDK 1.7 加入的`新的线程池`实现，它体现的是一种`分治思想`，适用于能够进行任务拆分的 cpu 密集型运算
2. **所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解**。跟递归相关的一些计算，如归并排序、斐波那契数列、都可以用分治思想进行求解
3. **Fork/Join 在分治的基础上加入了多线程**，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率
4. Fork/Join 默认会创建与 cpu 核心数大小相同的线程池

**使用**

- 提交给 Fork/Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值）

$$
当调用fork, 会重新执行compute方法, 进行递归运算
$$

```
package com.current.demo;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveTask;

/**
 * @program: threadDemo
 * @description: Fork/Join (熟悉)
 * @author: mengjianglong@e6yun.com
 * @create: 2021-12-15 14:43
 **/

public class TestForkJoin2 {
    public static void main(String[] args) {
        ForkJoinPool forkJoinPool = new ForkJoinPool(5);
        forkJoinPool.invoke(new MyTask(5));
    }
}
// 1~n 之间整数的和
@Slf4j(topic = "MyTask")
class MyTask extends RecursiveTask<Integer> {

    private int n;

    public MyTask(int n) {
        this.n = n;
    }

    @Override
    public String toString() {
        return "{" + n + '}';
    }

    @Override
    protected Integer compute() {
        // 如果 n 已经为 1，可以求得结果了
        if (n == 1) {
            log.debug("join() {}", n);
            return n;
        }

        // 将任务进行拆分(fork)
        AddTask1 t1 = new AddTask1(n - 1);
        t1.fork();
        log.debug("fork() {} + {}", n, t1);

        // 合并(join)结果
        int result = n + t1.join();
        log.debug("join() {} + {} = {}", n, t1, result);
        return result;
    }
}
```





### 线程池实现优缺点





## FutureTask源码解读

### 基于LockSupport实现FutureTask

### 基于Wait/Notify实现FutureTask



## ForkJoin源码解读

### 并发编程发展

### 工作窃取机制

### Fork Join原理



## Threadlocal源码解读

### 什么是Threadlocal

### Threadlocal应用场景

### Threadlocal与Synchronized区别

### 如何防御Threadlocal内存泄漏问题





## 并发集合

### ConcurrentHashMap

#### computeIfAbsent方法

$$
首先提以下 Java8关于ConcurrentHashMap引入新的方法computeIfAbsent，为了保证原子性！
$$

```
public V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction)
```

