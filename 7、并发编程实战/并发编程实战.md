**世上无难事，只怕有心人！！！**

# 第七部分：并发编程实战

## 操作系统基础

### 用户态与内核态切换过程

### linux进程模型管理

### linux进程间通信原理

### linux网络通讯原理



## 多线程基础



### 多线程快速入门

#### 什么是进程/线程

#### 多线程应用场景

#### 多线程与单线程之间的区别

#### 如何理解多线程cpu切换概念

#### 多线程真的开的越多越好吗

#### 用户线程与守护线程的区别

#### 如何优雅的停止一个线程

#### 多线程五种状态分析

##### 创建

##### 就绪

##### 运行

##### 阻塞

##### 死亡



#### 创建多线程五种方式

##### 继承Thread类创建线程

##### 实现Runnable接口创建线程

##### 使用Callable和Future创建线程

##### 使用线程池例如用Executor框架

##### 使用@Async异步注解创建线程

#### 线程运行原理

线程使用栈内存，每个线程启动后，虚拟机会给其分配一块栈内存，栈内存又由多个栈帧组成，对应着当前正在执行的方法。同一个线程内活动的栈帧只能有一个。

![image-20210922203343695](image\image-20210922203343695.png)

### 多线程线程安全

#### 什么是线程安全问题

#### Synchronized解决线程安全问题

#### lock与Synchronized锁区别

#### Lock锁解决线程安全问题

#### 多线程死锁线程产生的原因

#### 多线程如何排查死锁的现象

#### lock读写锁的使用



### 多线程之间通讯

#### 生产者与消费者

#### wait和notify

#### join方法的原理



## volatile关键字原理



### 关键字特性

#### 保证可见性

#### 禁止重排序

#### 不保证原子性



### java内存模型

#### CPU多核硬件架构剖析

#### jmm八大同步的规范



### Volatile缓存一致性协议

#### 总线锁

#### MESI协议



### 伪共享的问题

#### 缓存行基本的概念

#### 存行填充方案

### 重排序/内存屏障/双重检验锁为什么需要加上volatile

### synchronized 与volatile存在的区别

### 为什么Volatile不能保证原子性



## synchronized原理

### Synchronized内置锁实现原理

### 站在C++源码如何分析Synchronized原理

### 锁池/等待池/Monitor监视器锁/对象头原理

### Synchronized锁膨胀过程原理分析

### 偏向锁/轻量锁/自旋锁/重量锁

### 锁的粗化、与消除及性能优化



## 并发锁的分类

### 悲观锁

### 乐观锁

### 自旋锁

### 重入锁

### 公平锁

### 非公平锁



## aqs源码解读

### LockSupport源码解读

### AbstractQueuedSynchronizer源码解读

### ReentrantLock/ReentrantReadWriteLock、ReadWriteLock源码解读

### Semaphore/CountDownLatch/CyclicBarrie源码解读



## 并发atomic原子操作

### Atomic原子类

### CAS（乐观锁）原理

### Unsafe魔法类详解



## 阻塞队列BlockingQueue原理



### 阻塞队列分类

#### ArrayBlockingQueue 数组有界队列

#### ConcurrentLinkedQueue 链表有界队列

#### PriorityBlockingQueue 优先级排序无界队列

#### DelayQueue 延时无界队列



### 框架应用

#### 基于BlockingQueue手写线程池

#### 基于BlockingQueue手写消息中间件

#### 基于BlockingQueue手写日志框架



## Executor线程池详解及核心源码剖析

### 为什么要使用线程池

### 线程池核心原理分析

### 为什么阿里不建议使用Executors

### 线程池参数如何合理配置

### 线程池实现优缺点

### 如何基于ThreadPoolExecutor自定义线程池



## FutureTask源码解读

### 基于LockSupport实现FutureTask

### 基于Wait/Notify实现FutureTask



## ForkJoin源码解读

### 并发编程发展

### 工作窃取机制

### Fork Join原理



## Threadlocal源码解读

### 什么是Threadlocal

### Threadlocal应用场景

### Threadlocal与Synchronized区别

### 如何防御Threadlocal内存泄漏问题