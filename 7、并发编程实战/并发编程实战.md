世上无难事，只怕有心人！！！**

# 第七部分：并发编程实战

## 操作系统基础

### 用户态与内核态切换过程

- 用户态和内核态的区别

```
当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称该进程处于内核态，此时处理器处于特权级最高的（0级）内核代码。当进程处于内核状态时，执行内核代码会使用当前的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户态。即此时处理器在特权级最低的用户代码中运行。当正在执行用户程序突然中断时，此时用户程序也可以象征性的处于进程的内核态。因为中断处理程序将使用当前进程的内核态。
```

```
a. 系统调用

​    这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。

b. 异常

​    当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

c. 外围设备的中断

​    当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。
```



### linux进程模型管理

### linux进程间通信原理

### linux网络通讯原理



## 多线程基础



### 查看进程线程的方法

#### windowns

- 任务管理器
- tasklist 查看进程
- taskkill 杀死进程

#### linux

- ps -fe 查看所有进程
- ps -ft -p 查看某个进程的所有线程
- kill 杀死进程
- top 按大写H切换是否显示线程
- top -H -p 擦好看某个进程的所有线程

#### java

- jps 查看所有java进程
- jstack查看某个java进程所有线程状态
- jconsole 查看某个java进程中线程的运行情况



### 多线程快速入门

#### 什么是进程/线程

##### 进程：

$$
进程实际就是程序运行的实体，类似可执行的.exe文件或.jar。一个进程中可以有多个线程执行。
$$

##### 线程：

```
线程是计算机的最小执行单位，一个线程都是一个单一顺序的控制流
```



#### 多线程应用场景

```
异步调用：用过多线程使某个方法可以异步执行，从而不影响主业务的执行。

多文件操作：多文件下载，FTP等操作，文件解码。都可使用多线程去调用执行。

任务调度：定时任务，同一时间可以操作多个任务调度。

高并发操作：对于一些并发量比较高的业务
```

。



#### 多线程与单线程之间的区别

#### 如何理解多线程cpu切换概念

```
因为一些原因导致cpu不再执行当前线程，转为执行另一个线程代码

线程cpu时间片用完
垃圾回收
有更高优先级的线程执行
线程自己调用了sleep、yield、wait、join、synchronized、lock等方法

发生Context Switch发生时，需要操作系统保存当前线程状态，用于恢复执行，java中由jvm的程序计数器来保存线程状态。
频繁的上下文切换是很耗资源的。
```



#### 多线程真的开的越多越好吗

#### 用户线程与守护线程的区别

#### 如何优雅的停止一个线程

#### 多线程五种状态分析

- 操作系统层面：

![image-20211005114500504](image\image-20211005114500504.png)

##### 创建：

初始创建线程

##### 就绪：

等待cpu调度的线程

##### 运行：

被cpu调度执行的线程

##### 阻塞：

##### 死亡：

- javaApi

![image-20211005142221711](image\image-20211005142221711.png)

- NEW：新建状态
- RUNNABLE：涵盖运行，阻塞，可运行三种状态

- TERMINATED：终止状态
- BLOCKED：根据源码注释，由于调用wait、join及LockSupport.park方法，使线程处于等待状态
- WAITING：

![image-20211005163529149](image\image-20211005163529149.png)

- TIMED WAITING：

```
Thread state for a terminated thread. The thread has completed execution.--终止线程的线程状态。线程已完成执行。
```



#### 创建多线程五种方式

##### 继承Thread类创建线程

```
Thread t1 = new Thread(){
	public void run(){
		//方法体
	}
}
t1.setName("线程名称");
t1.start();
```



##### 实现Runnable接口创建线程（推荐）

将线程和任务分离，Runnable为可运行的任务，Thread代表线程

```
Runnable r = () -> log.debug("running");
        new Thread(r, "t1").start();
```

Runnable更容易和线程池等高级API配合，让任务脱离了Thread继承体系，更灵活。



##### 使用Callable和Future创建线程

FutureTask通过接收Callable类型的参数（Callable源码如下），来处理带有返回结果的情况，FutureTask实现RunnableFuture。

![image-20210927234450226](image\image-20210927234450226.png)

![image-20210927234518930](image\image-20210927234518930.png)

```
FutureTask futureTask = new FutureTask(new Callable() {
            @Override
            public Object call() throws Exception {
                System.out.println("renwu");
                Thread.sleep(1000);
                return 110;
            }
        });
        new Thread(futureTask,"t3").start();
        System.out.println("zhuxiancheng");
        futureTask.get();// 获取结果
```

![image-20210927234115545](image\image-20210927234115545.png)

Future 就是对于具体的 Runnable 或者 Callable 任务的执行结果进行取消、查询是否完成、获取结果。

```
package java.util.concurrent;
public interface Future<V> {
取消任务执行，视具体情况而定，如果传为true并且任务正在运行，则会被取消，如果为false并且任务正在运行，则不会取消。如果该线程存在某些原因不可取消时将会返回false
    boolean cancel(boolean mayInterruptIfRunning);

判断当前task是否被取消。
    boolean isCancelled();

判断当前Future是否执行完成。
    boolean isDone();

用户返回计算结果，如果计算还没有完成，则在get的时候会进行阻塞，直到获取到结果为止
    V get() throws InterruptedException, ExecutionException;

如果在指定时间内没有完成计算，则会抛出TimeoutException
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```



##### 使用线程池例如用Executor框架

```
package com.current.demo;

import java.util.concurrent.*;

/**
 * @program: threadDemo
 * @description:
 * @author: mengjianglong@e6yun.com
 * @create: 2021-10-18 13:44
 **/

public class CreateThreadDemo {
    public static void main(String[] args) {
        /*1、提供线程池运行的基本参数*/
        ExecutorService service = Executors.newFixedThreadPool(10,Executors.defaultThreadFactory());
        ThreadPoolExecutor poolExecutor = (ThreadPoolExecutor) service;
        // 核心池大小
        //poolExecutor.setCorePoolSize(10);
        //最大线程数
        //poolExecutor.setMaximumPoolSize(9);
        //线程没有任务时最多保持多长时间后会终止
        //poolExecutor.setKeepAliveTime(2, TimeUnit.SECONDS);

        /*创建加入线程*/
        service.execute(new NumberThread());
        service.execute(new NumberThread1());

        /*停止线程*/
        service.shutdown();
    }
}

class NumberThread implements Runnable{

    public void run() {
        for(int i = 0;i <= 100;i++){
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ": " + i);
            }
        }
    }
}

class NumberThread1 implements Runnable{

    public void run() {
        for(int i = 0;i <= 100;i++){
            if(i % 2 != 0){
                System.out.println(Thread.currentThread().getName() + ": " + i);
            }
        }
    }
}

```



##### 使用@Async异步注解创建线程

```

```



#### 线程运行原理

```
线程使用栈内存，每个线程启动后，虚拟机会给其分配一块栈内存，栈内存中会根据方法执行的前后顺序创建每一个栈帧用于存储局部变量表，动态链接，操作数栈，方法出口等信息。每次会将执行的栈帧（方法）从栈顶弹出，执行完成后再将返回值交给下一个方法继续执行。
```

![image-20210922203343695](image\image-20210922203343695.png)



### 线程中常见的方法

```
sleep：
线程由runing-->TimedWaiting
其他线程可以使用interrupt方法打断正在睡眠的线程，这时sleep会抛出异常
睡眠结束后线程未必会立刻执行
建议用TimeUnit休眠   TimeUnit.SECOUND.sleep（1）
```

```
yield：
线程从Running-->Runable就绪状态
```

```
join、join(long n):
等待线程运行结束(等待n秒后没结果继续往后运行)
```

```
interrupt：
打断阻塞状态的线程
sleep、wait、join被打断后会抛出异常

打断执行中的线程
通过打断标记结束运行isInterrupt()
```

```
park线程：
/**
 * @author 25283
 * @version 1.0
 * @description: TODO park线程
 * @date 2021/10/5 11:23
 */
public class ParkThread {
    public static void main(String[] args) {
        Thread t1 = new Thread(()->{
            System.out.println("park....");
            LockSupport.park();
            System.out.println("unPark...");
            // 将打断状态置为
            Thread.currentThread().interrupted();
            LockSupport.park();
            System.out.println("unpark..");
        },"t1");
        t1.start();

        //打断park
        t1.interrupt();
    }
}
park线程是属于LockSupport工具类中的一个打断线程的方法，该方法收到isInterrupt的影响，如果为true会导致park打断失效。因此在使用时需要注意及时将当前线程的打断状态调整为false，及利用interrupted回归为false；
```



### 两阶段终止模式（设计模式）

在线程T1中如何优雅的终止线程T2

实际上就是利用interrupt去打断一个线程，打断完成后则利用isInterrupt去判断线程是否被打断，若被打断则正常结束当前线程也就是这里的正常跳出循环，结束该方法体的执行。一般情况下我们不可以直接使用java自带的stop去结束一个线程，而且jdk1.8已经不推荐使用，盲目使用stop去终止一个线程，有可能会导致该线程所占用的共享资源锁不被释放，从而造成程序的错误。而System.exit()会直接结束运行当前程序。

```
/**
 * @author 25283
 * @version 1.0
 * @description: 两阶段终止模式
 * @date 2021/10/5 10:54
 */
public class TwoStageTerminationMode {
    public static void main(String[] args) {
        TwoThread twoThread = new TwoThread();
        twoThread.start();

        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        twoThread.stop();
    }
}
class TwoThread{
    public Thread mode;

    public void start(){
        mode = new Thread(()->{
            while (true){
                Thread currentThread = Thread.currentThread();
                if (currentThread.isInterrupted()) {
                    System.out.println("我正常离职了");
          break;
                }

                try {
                    TimeUnit.SECONDS.sleep(1);
                    System.out.println("我在履职");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    currentThread.interrupt();
                }
            }
        });
        mode.start();
    }
    public void stop(){
        mode.interrupt();
    }
}
```



### 线程优先级

不是所有优先级高的线程会先执行，所有的调度都去决于CPU，在cpu比较繁忙的时候，优先级高的有可能先执行。



### 主线程和守护线程

- 守护线程：等其他非守护线程结束了，即使守护线程代码没执行完他也会停止运行。
- 应用：垃圾回收器就是一种守护线程，tomcat中的Acceptor和poller



### 多线程线程安全

#### 什么是线程安全问题

线程安全图解：

![img](https://img-blog.csdnimg.cn/20201219094936132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20201219095022810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

- 根本原因

```
共享资源操作，线程上线文操作导致一个线程指令没有完全的执行完毕就去执行另一个线程指令，导致共享资源拿到的结果不一致，失去原子性。
```

- java字节码

```
以count++和count--为例：
getstatic i // 获取静态变量i的值
iconst_1 // 准备常量1
iadd // 自增
putstatic i // 将修改后的值存入静态变量i
    
getstatic i // 获取静态变量i的值
iconst_1 // 准备常量1
isub // 自减
putstatic i // 将修改后的值存入静态变量i
```



#### 共享资源问题

##### 临界区

```
一段代码中如果对共享资源有读写操作，称这段代码块为临界区
```

##### 竞态条件

```
多个线程操作临界区，导致代码执行序列不同而导致结果无法预测，称为竞态条件
```



#### Synchronized解决线程安全问题

为避免临界区中的竞态条件发生

```
阻塞式解决方案：synchronized,Lock
非阻塞式解决方案：原子变量CAS
```

synchronized俗称对象锁，采用互斥的方式让多线程在同一时间只能有一个线程持有对象所，其他线程被阻塞等待，这样就能保证临界区的代码顺序，也不用担心上下文切换。

```
java中的互斥和同步：
互斥：保证临界区的竞态条件发生，并且当前只能有一个线程去操作临界区的代码。
同步：由于线程执行的先后不一样，一个线程要等待其他线程运行到某个点，如一个消费者需要等生产者将产品生产出来才可进行消费。
```



```
static int counter = 0;
static final Object room = new Object();
public static void main(String[] args) throws InterruptedException {
     Thread t1 = new Thread(() -> {
         for (int i = 0; i < 5000; i++) {
         	 // 对临界资源(共享资源的操作) 进行 加锁
             synchronized (room) {
             counter++;
        	}
 		}
 	}, "t1");
     Thread t2 = new Thread(() -> {
         for (int i = 0; i < 5000; i++) {
             synchronized (room) {
             counter--;
         }
     }
     }, "t2");
     t1.start();
     t2.start();
     t1.join();
     t2.join();
     log.debug("{}",counter);
}

09:56:24.210 guizy.ThreadLocalDemo [main] - count的值是0
```

#### synchronized原理

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201219110609489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20201219110651392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/img_convert/e7dda8af005cdee39d206896de899745.png)

```
如果把synchronized(obj)放在for循环的外面, 如何理解?
for循环也是一个原子操作, 表现出原子性

如果t1 synchronized(obj1) 而 t2 synchronized(obj2)会怎么运行?
因为t1, t2拿到不是同一把对象锁, 所以他们仍然会发现安全问题 – 必须要是同一把对象锁

如果t1 synchronized(obj) 而 t2 没有加会怎么样 ?
因为t2没有加锁, 所以t2, 不需要获取t1的锁, 直接就可以执行下面的代码, 仍然会出现安全问题
```

#### synchronized 加在方法上

- 加在`实例方法`上, 锁对象就是对象实例

```
public class Demo{
//在方法上加上synchronized关键字
	public synchronized void test() {
	
	}
	
	public void test() {
		synchronized(this){
	
		}
	}
}
```

- 加在`静态方法`上, 锁对象就是当前类的Class实例

```
public class Demo{
//在方法上加上synchronized关键字
	public synchronized static void test() {
	
	}
	
	public void test() {
		synchronized(Demo.class){
	
		}
	}
}
```

#### 成员变量和静态变量的线程安全分析 (`重要`)

- `如果变量没有在线程间共享，那么变量是安全的`
- 如果变量在线程间共享
  - 如果只有`读操作`，则`线程安全`
  - 如果有`读写操作`，则这段代码是`临界区`，`需要考虑线程安全`

#### 局部变量线程安全分析 (`重要`)

- 局部变量`【局部变量被初始化为基本数据类型】是安全的`
- 但局部变量引用的对象则未必 （要看该对象是否被共享且被执行了读写操作）
  - 如果`该对象没有逃离方法的作用范围`，它是`线程安全的`
  - 如果`该对象逃离方法的作用范围`，需要`考虑线程安全`

#### 常见线程安全类

- String
- Integer
- StringBuffer
- Random
- Vector
- Hashtable
- java.util.concurrent 包下的类 JUC

**`重点:`**

- 这里`说它们是线程安全`的是指，**`多个线程调用它们同一个实例的某个方法时，是线程安全的`** , 也可以理解为 **`它们的每个方法是原子的`**
- 它们的每个方法是原子的`（方法都被加上了synchronized）`
- 但注意它们`多个方法的组合不是原子的`，所以可能**会出现线程安全问题**

- String和Integer类都是不可变的类，因为其类内部状态是不可改变的，因此它们的方法都是线程安全的, 都被final修饰, 不能被继承.
  肯定有些人他们知道String 有 replace，substring 等方法【可以】改变值啊，其实调用这些方法返回的已经是一个新创建的对象了！ (在字符串常量池中当修改了String的值,它不会再原有的基础上修改, 而是会重新开辟一个空间来存储)

#### lock与Synchronized锁区别

![img](https://img-blog.csdnimg.cn/20210202223437264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

#### 多锁机制

- 小故事

- 一间大屋子有两个功能：`睡觉、学习，互不相干`。

- 现在小南要学习，小女要睡觉，但如果只用一间屋子（一个对象锁）的话，那么

  ```
  并发度很低
  ```

  - 小南获得锁之后, 学完习之后, 小女才能进来睡觉。

- **解决方法是准备多个房间`（多个对象锁）`**

```
@Slf4j(topic = "guizy.BigRoomTest")
public class BigRoomTest {
    public static void main(String[] args) {
        BigRoom bigRoom = new BigRoom();
        new Thread(() -> bigRoom.sleep(), "小南").start();
        new Thread(() -> bigRoom.study(), "小女").start();
    }
}

@Slf4j(topic = "guizy.BigRoom")
class BigRoom {
    public void sleep() {
        synchronized (this) {
            log.debug("sleeping 2 小时");
            Sleeper.sleep(2);
        }
    }

    public void study() {
        synchronized (this) {
            log.debug("study 1 小时");
            Sleeper.sleep(1);
        }
    }
}
```

- 改进让`小南, 小女`获取不同的锁即可

```
@Slf4j(topic = "guizy.BigRoomTest")
public class BigRoomTest {
    private static final BigRoom sleepRoom = new BigRoom();
    private static final BigRoom studyRoom = new BigRoom();

    public static void main(String[] args) {
    	// 不同对象调用
        new Thread(() -> sleepRoom.sleep(), "小南").start();
        new Thread(() -> studyRoom.study(), "小女").start();
    }
}
```

- 将锁的粒度细分
  - 好处，是可以`增强并发度`
  - 坏处，如果一个线程需要同时获得多把锁，就`容易发生死锁`

##### 活跃性

- 因为某种原因，使得代码一直无法执行完毕，这样的现象叫做 **活跃性**
- 活跃性相关的一系列问题都可以用 **`ReentrantLock`** 进行解决。



#### Lock锁解决线程安全问题

#### 多线程死锁线程产生的原因

- 实际就是线程1拥有A对象的锁单它同时也需要B对象的锁，恰好线程2拥有B对象的锁但它又要获取A对象的锁，此时形成一个循环链路，两者都不肯释放自己锁占的锁，导致两者都阻塞等待，形成死锁。

```
public static void main(String[] args) {
	final Object A = new Object();
	final Object B = new Object();
	
	new Thread(()->{
		synchronized (A) {
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			synchronized (B) {

			}
		}
	}).start();

	new Thread(()->{
		synchronized (B) {
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			synchronized (A) {

			}
		}
	}).start();
}
```

- 发生死锁的必要条件
  - 互斥条件：一段时间内，一种资源只能被一个线程使用
  - 请求和保持条件：自己所占有的资源在没有执行完时，不会主动释放。
  - 不可抢占条件：对以获得资源没有使用完成前不能被强占。
  - 循环等待条件：发生死锁时回形成进程-资源的循环链。





#### 多线程如何排查死锁的现象

- 方法一：利用java的控制台

在Java控制台中的`Terminal`中输入 **`jps`** 指令可以查看`正在运行中的进程ID`，使用 **`jstack 进程ID`** 可以查看进程状态。

![img](https://img-blog.csdnimg.cn/20201223123336643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20201223123406253.png)

![img](https://img-blog.csdnimg.cn/20201223123554788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

- 方法二：利用jconsole检测死锁

![img](https://img-blog.csdnimg.cn/img_convert/359638cf867dbe8d03da37c3e19fefe3.png)

![img](https://img-blog.csdnimg.cn/img_convert/e9f23bd07142b38d856fef84e6ded641.png)

##### 死锁举例 - 哲学家就餐问题 (`重点`)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201223123802724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

有五位哲学家，围坐在圆桌旁。

他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。
吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。
如果筷子被身边的人拿着，自己就得等待
当每个哲学家即线程持有一根筷子时，他们都在等待另一个线程释放锁，因此造成了死锁。

```
@Slf4j(topic = "guizy.PhilosopherEat")
public class PhilosopherEat {
    public static void main(String[] args) {
        Chopstick c1 = new Chopstick("1");
        Chopstick c2 = new Chopstick("2");
        Chopstick c3 = new Chopstick("3");
        Chopstick c4 = new Chopstick("4");
        Chopstick c5 = new Chopstick("5");
        new Philosopher("苏格拉底", c1, c2).start();
        new Philosopher("柏拉图", c2, c3).start();
        new Philosopher("亚里士多德", c3, c4).start();
        new Philosopher("赫拉克利特", c4, c5).start();
        new Philosopher("阿基米德", c5, c1).start();
    }
}

@Slf4j(topic = "guizy.Philosopher")
class Philosopher extends Thread {
    final Chopstick left;
    final Chopstick right;

    public Philosopher(String name, Chopstick left, Chopstick right) {
        super(name);
        this.left = left;
        this.right = right;
    }

    @Override
    public void run() {
        while (true) {
            // 尝试获取左手筷子
            synchronized (left) {
                // 尝试获取右手筷子
                synchronized (right) {
                    eat();
                }
            }
        }
    }

    private void eat() {
        log.debug("eating...");
        Sleeper.sleep(0.5);
    }
}

class Chopstick{
    String name;

    public Chopstick(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "筷子{" + name + '}';
    }
}
```

通过`jps, jstack 进程id`查看死锁原因
`Found one Java-level deadlock:` 发现了一个Java级别的死锁

```
Found one Java-level deadlock:
=============================
"阿基米德":
  waiting to lock monitor 0x000000001ae2a358 (object 0x00000000d6ea7420, a com.guizy.reentrantlock.Chopstick),
  which is held by "苏格拉底"
"苏格拉底":
  waiting to lock monitor 0x0000000017fb3518 (object 0x00000000d6ea7430, a com.guizy.reentrantlock.Chopstick),
  which is held by "柏拉图"
"柏???图":
  waiting to lock monitor 0x0000000017fb3468 (object 0x00000000d6ea7440, a com.guizy.reentrantlock.Chopstick),
  which is held by "亚里士多德"
"亚里士多德":
  waiting to lock monitor 0x0000000017fb0bd8 (object 0x00000000d6ea7450, a com.guizy.reentrantlock.Chopstick),
  which is held by "赫拉克利特"
"赫拉克利特":
  waiting to lock monitor 0x0000000017fb0c88 (object 0x00000000d6ea7460, a com.guizy.reentrantlock.Chopstick),
  which is held by "阿基米德"

Java stack information for the threads listed above:
===================================================
"阿基米德":
        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:47)
        - waiting to lock <0x00000000d6ea7420> (a com.guizy.reentrantlock.Chopstick)
        - locked <0x00000000d6ea7460> (a com.guizy.reentrantlock.Chopstick)
"苏格拉底":
        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:47)
        - waiting to lock <0x00000000d6ea7430> (a com.guizy.reentrantlock.Chopstick)
        - locked <0x00000000d6ea7420> (a com.guizy.reentrantlock.Chopstick)
"柏拉图":
        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:47)
        - waiting to lock <0x00000000d6ea7440> (a com.guizy.reentrantlock.Chopstick)
        - locked <0x00000000d6ea7430> (a com.guizy.reentrantlock.Chopstick)
"亚里士多德":
        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:47)
        - waiting to lock <0x00000000d6ea7450> (a com.guizy.reentrantlock.Chopstick)
        - locked <0x00000000d6ea7440> (a com.guizy.reentrantlock.Chopstick)
"赫拉克利特":
        at com.guizy.reentrantlock.Philosopher.run(PhilosopherEat.java:47)
        - waiting to lock <0x00000000d6ea7460> (a com.guizy.reentrantlock.Chopstick)
        - locked <0x00000000d6ea7450> (a com.guizy.reentrantlock.Chopstick)

Found 1 deadlock.
```





#### 避免死锁的方法

- 在线程使用锁对象时, 采用**固定加锁的顺序**, 可以使用Hash值的大小来确定加锁的先后

- 尽可能缩减加锁的范围, 等到操作共享变量的时候才加锁

- 使用可释放的定时锁 (一段时间申请不到锁的权限了, 直接释放掉)

![img](https://img-blog.csdnimg.cn/img_convert/b8a0466afe78fa85b406d66813c15c9b.png)

#### 活锁

- `活锁`出现在两个线程 **`互相改变对方的结束条件`**，谁也无法结束。

##### 避免活锁的方法

- 在线程执行时，中途给予 **`不同的间隔时间`**, 让某个线程先结束即可。





#### lock读写锁的使用



### 多线程之间通讯

#### 生产者与消费者

#### wait和notify

![img](https://img-blog.csdnimg.cn/20201220084049915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20201220084213239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

##### wait、notify介绍 (必须要获取到锁对象, 才能调用这些方法)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201220084652893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

- **当`线程0`获得到了`锁`, 成为`Monitor`的`Owner`, 但是此时它发现自己想要执行`synchroized代码块`的条件不满足; 此时它就调用`obj.wait`方法, 进入到Monitor中的`WaitSet`集合, 此时`线程0`的状态就变为`WAITING`**

- 处于BLOCKED和WAITING状态的线程都为阻塞状态，CPU都不会分给他们时间片。但是有所区别：
  - BLOCKED状态的线程是在竞争锁对象时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于BLOCKED状态
  - WAITING状态的线程是获得了对象的锁，但是自身的原因无法执行synchroized的临界区资源需要进入阻塞状态时，锁对象调用了wait方法而进入了WaitSet中，处于WAITING状态
- **`处于BLOCKED状态的线程会在锁被释放的时候被唤醒`**
- **`处于WAITING状态的线程只有被锁对象调用了notify方法(obj.notify/obj.notifyAll)，才会被唤醒。然后它会进入到EntryList, 重新竞争锁`** (此时就将锁升级为`重量级锁`)



##### API

下面的三个方法都是Object中的方法; 通过锁对象来调用

- wait(): 让获得对象锁的线程到waitSet中一直等待

- wait(long n) : 当该等待线程没有被notify, 等待时间到了之后, 也会自动唤醒

- notify(): 让获得对象锁的线程, 使用锁对象调用notify去waitSet的等待线程中挑一个唤醒

- notifyAll() : 让获得对象锁的线程, 使用锁对象调用notifyAll去唤醒waitSet中所有的等待线程

它们都是线程之间进行协作的手段, 都属于Object对象的方法, 必须获得此对象的锁, 才能调用这些方法

注：只有当对象被锁以后(成为Owner)，才能调用wait和notify方法

```
public class Test1 {
	final static Object LOCK = new Object();
	public static void main(String[] args) throws InterruptedException {
        //只有在对象被锁住后才能调用wait方法
		synchronized (LOCK) {
			LOCK.wait();
		}
	}
	}
```

- 演示`wait和notify`方法

```
@Slf4j(topic = "guizy.WaitNotifyTest")
public class WaitNotifyTest {
    static final Object obj = new Object();

    public static void main(String[] args) throws Exception {

        new Thread(() -> {
            synchronized (obj) {
                log.debug("执行...");
                try {
                    // 只有获得锁对象之后, 才能调用wait/notify
                    obj.wait(); // 此时t1线程进入WaitSet等待
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("其它代码...");
            }
        }, "t1").start();

        new Thread(() -> {
            synchronized (obj) {
                log.debug("执行...");
                try {
                    obj.wait(); // 此时t2线程进入WaitSet等待
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("其它代码...");
            }
        }, "t2").start();

        // 让主线程等两秒在执行,为了`唤醒`,不睡的话,那两个线程还没进入waitSet,主线程就开始唤醒了
        Thread.sleep(1000);
        log.debug("唤醒waitSet中的线程!");
        // 只有获得锁对象之后, 才能调用wait/notify
        synchronized (obj) {
            // obj.notify(); // 唤醒waitset中的一个线程
             obj.notifyAll(); // 唤醒waitset中的全部等待线程
        }
    }
}

13:01:36.176 guizy.WaitNotifyTest [t1] - 执行...
13:01:36.178 guizy.WaitNotifyTest [t2] - 执行...
13:01:37.175 guizy.WaitNotifyTest [main] - 唤醒waitSet中的线程!
13:01:37.175 guizy.WaitNotifyTest [t2] - 其它代码...
13:01:37.175 guizy.WaitNotifyTest [t1] - 其它代码...
```

##### Sleep(long n) 和 Wait(long n)的区别 `(重点)`

不同点

Sleep是Thread类的静态方法，Wait是Object的方法，Object又是所有类的父类，所以所有类都有Wait方法。
Sleep在阻塞的时候不会释放锁，而Wait在阻塞的时候会释放锁 (不释放锁的话, 其他线程就无法唤醒该线程了)
Sleep方法不需要与synchronized一起使用，而Wait方法需要与synchronized一起使用（wait/notify等方法, 必须要使用对象锁来调用）
相同点

阻塞状态都为TIMED_WAITING (限时等待)
sleep方法 / wait方法 测试

```
@Slf4j(topic = "guizy.SleepTest")
public class SleepTest {

    public static final Object lock = new Object();

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (lock) {
                log.debug("获得锁了");
                try {
                    // Thread.sleep(5000); // 主线程需要等5s才能获得到锁.所以所在sleep期间, 是不会释放锁的
                    lock.wait(5000); // 调用wait方法会立刻释放锁, 不然主线程就拿不到lock锁了, 当等待5s后程序才结束
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "t1").start();

        // 主线程睡一秒
        Sleeper.sleep(1);
        synchronized (lock) {
            log.debug("获得锁了");
        }
}
```

sleep打印结果 : 表明在sleep期间, 锁是不会被释放的

![img](https://img-blog.csdnimg.cn/20201220094013513.png)

wait打印结果 : 当调用wait方法后, 锁就会被立刻释放

![img](https://img-blog.csdnimg.cn/20201220094129242.png)

##### wait/notify的正确使用

```
@Slf4j(topic = "guizy.WaitNotifyTest")
public class WaitNotifyTest {
    static final Object room = new Object();
    static boolean hasCigarette = false;
    static boolean hasTakeout = false;

    public static void main(String[] args) {
        //思考下面的解决方案好不好，为什么？
        new Thread(() -> {
            synchronized (room) {
                log.debug("有烟没？[{}]", hasCigarette);
                if (!hasCigarette) {
                    log.debug("没烟，先歇会！");
                    Sleeper.sleep(2);   // 会阻塞2s, 不会释放锁
                }
                log.debug("有烟没？[{}]", hasCigarette);
                if (hasCigarette) {
                    log.debug("可以开始干活了");
                }
            }
        }, "小南").start();

        for (int i = 0; i < 5; i++) {
            new Thread(() -> {
                synchronized (room) {
                    log.debug("可以开始干活了");
                }
            }, "其它人").start();
        }

        Sleeper.sleep(1);
        new Thread(() -> {
            // 此时没有加锁, 所以会优先于其他人先执行
            // 这里能不能加 synchronized (room)？
            //synchronized (room) { // 如果加锁的话, 送烟人也需要等待小南睡2s的时间,此时即使送到了,小南线程也将锁释放了..
                hasCigarette = true;
                log.debug("烟到了噢！");
            //}
        }, "送烟的").start();
    }
}
```

- 不给`送烟线程加synchronized`输出情况

```
10:16:32.311 guizy.WaitNotifyTest [小南] - 有烟没？[false]
10:16:32.318 guizy.WaitNotifyTest [小南] - 没烟，先歇会！
10:16:33.318 guizy.WaitNotifyTest [送烟的] - 烟到了噢！
10:16:34.320 guizy.WaitNotifyTest [小南] - 有烟没？[true]
10:16:34.320 guizy.WaitNotifyTest [小南] - 可以开始干活了
10:16:34.320 guizy.WaitNotifyTest [其它人] - 可以开始干活了
10:16:34.320 guizy.WaitNotifyTest [其它人] - 可以开始干活了
10:16:34.320 guizy.WaitNotifyTest [其它人] - 可以开始干活了
10:16:34.321 guizy.WaitNotifyTest [其它人] - 可以开始干活了
10:16:34.321 guizy.WaitNotifyTest [其它人] - 可以开始干活了
```

- 给`送烟线程加synchronized`输出情况

```
10:16:57.565 guizy.WaitNotifyTest [小南] - 有烟没？[false]
10:16:57.570 guizy.WaitNotifyTest [小南] - 没烟，先歇会！
10:16:59.574 guizy.WaitNotifyTest [小南] - 有烟没？[false]
10:16:59.574 guizy.WaitNotifyTest [送烟的] - 烟到了噢！
10:16:59.575 guizy.WaitNotifyTest [其它人] - 可以开始干活了
10:16:59.575 guizy.WaitNotifyTest [其它人] - 可以开始干活了
10:16:59.575 guizy.WaitNotifyTest [其它人] - 可以开始干活了
10:16:59.575 guizy.WaitNotifyTest [其它人] - 可以开始干活了
10:16:59.576 guizy.WaitNotifyTest [其它人] - 可以开始干活了
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201220101906421.png)

- 使用`while循环`来解决`虚假唤醒`

```
@Slf4j(topic = "guizy.WaitNotifyTest")
public class Main {
    static final Object room = new Object();
    static boolean hasCigarette = false;
    static boolean hasTakeout = false;

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (room) {
                log.debug("有烟没？[{}]", hasCigarette);
                while (!hasCigarette) {
                    log.debug("没烟，先歇会！");
                    try {
                        room.wait(); // 此时进入到waitset等待集合, 同时会释放锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.debug("有烟没？[{}]", hasCigarette);
                if (hasCigarette) {
                    log.debug("可以开始干活了");
                }
            }
        }, "小南").start();

        new Thread(() -> {
            synchronized (room) {
                log.debug("外卖送到没？[{}]", hasTakeout);
                while (!hasTakeout) {
                    log.debug("没外卖，先歇会！");
                    try {
                        room.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.debug("外卖送到没？[{}]", hasTakeout);
                if (hasTakeout) {
                    log.debug("可以开始干活了");
                } else {
                    log.debug("没干成活...");
                }
            }
        }, "小女").start();

        Sleeper.sleep(1);
        new Thread(() -> {
            synchronized (room) {
                hasTakeout = true;
                log.debug("外卖到了噢！");
                room.notifyAll();
            }
        }, "送外卖的").start();
    }
}
```

```
11:19:25.275 guizy.WaitNotifyTest [小南] - 有烟没？[false]
11:19:25.282 guizy.WaitNotifyTest [小南] - 没烟，先歇会！
11:19:25.282 guizy.WaitNotifyTest [小女] - 外卖送到没？[false]
11:19:25.283 guizy.WaitNotifyTest [小女] - 没外卖，先歇会！
11:19:26.287 guizy.WaitNotifyTest [送外卖的] - 外卖到了噢！
11:19:26.287 guizy.WaitNotifyTest [小女] - 外卖送到没？[true]
11:19:26.287 guizy.WaitNotifyTest [小女] - 可以开始干活了
11:19:26.288 guizy.WaitNotifyTest [小南] - 没烟，先歇会！
```

因为改为`while`如果唤醒之后, 就在while循环中执行了, 不会跑到while外面去执行"有烟没…", 此时小南就不需要每次notify, 就去看是不是送来的烟, 如果是烟, while就为false了.



#### join方法的原理

##### 同步模式之保护性暂停 (`join、Future的实现`)

- 即Guarded Suspension，用在一个线程等待另一个线程的执行结果

- 有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject
  如果有结果不断从一个线程到另一个线程 那么可以使用消息队列（见生产者/消费者）
  JDK 中，join 的实现、Future 的实现，采用的就是此模式
  因为要等待另一方的结果，因此归类到同步模式

![img](https://img-blog.csdnimg.cn/img_convert/e73412e2618ca103105cce41f4b228c9.png)

- `一方等待另一方的执行结果`举例 :
- 举例, 线程1等待线程2下载的结果,并获取该结果

```
@Slf4j(topic = "guizy.GuardeObjectTest")
public class GuardeObjectTest {
    public static void main(String[] args) {
        // 线程1等待线程2的下载结果
        GuardeObject guardeObject = new GuardeObject();
        new Thread(() -> {
            log.debug("等待结果");
            List<String> list = (List<String>) guardeObject.get();
            log.debug("结果大小:{}", list.size());
        }, "t1").start();

        new Thread(() -> {
            log.debug("执行下载");
            try {
                List<String> list = Downloader.download();
                guardeObject.complete(list);
            } catch (IOException e) {
                e.printStackTrace();
            }

        }, "t2").start();
    }
}

class GuardeObject {
    // 结果
    private Object response;

    // 获取结果
    public Object get() {
        synchronized (this) {
            // 防止虚假唤醒
            // 没有结果
            while (response == null) {
                try {
                    this.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            return response;
        }
    }

    // 产生结果
    public void complete(Object response) {
        synchronized (this) {
            // 给结果变量赋值
            this.response = response;
            this.notifyAll();
        }
    }
}
```

- 关于超时的增强，在`join(long millis) 的源码`中得到了体现：

```
public final synchronized void join(long millis)
throws InterruptedException {
    long base = System.currentTimeMillis();
    long now = 0;

    if (millis < 0) {
        throw new IllegalArgumentException("timeout value is negative");
    }

    if (millis == 0) {
        while (isAlive()) {
            wait(0);
        }
    } else {
    // join一个指定的时间
        while (isAlive()) {
            long delay = millis - now;
            if (delay <= 0) {
                break;
            }
            wait(delay);
            now = System.currentTimeMillis() - base;
        }
    }
}
```

- 多任务版GuardedObject图中 Futures 就好比居民楼一层的信箱（每个信箱有房间编号），左侧的 t0，t2，t4 就好比等待邮件的居民，右侧的 t1，t3，t5 就好比邮递员如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类。
- 不仅能够`解耦`【结果等待者】和【结果生产者】，还能够同时支持`多个任务的管理`。和生产者消费者模式的区别就是：**这个`产生结果的线程`和`使用结果的线程`是`一一对应`的关系，但是生产者消费者模式并不是。**
- rpc框架的调用中就使用到了这种模式。

![img](https://img-blog.csdnimg.cn/img_convert/8af156fb943083720b551f6e52ddd03c.png)

```
@Slf4j(topic = "guizy.GuardedObjectTest")
public class GuardedObjectTest {
    public static void main(String[] args) {
        for (int i = 0; i < 3; i++) {
            new People().start();
        }
        Sleeper.sleep(1);
        for (Integer id : Mailboxes.getIds()) {
            new Postman(id, "内容" + id).start();
        }
    }
}

@Slf4j(topic = "guizy.People")
class People extends Thread {
    @Override
    public void run() {
        // 收信
        GuardedObject guardedObject = Mailboxes.createGuardedObject();
        log.debug("开始收信 id:{}", guardedObject.getId());
        Object mail = guardedObject.get(5000);
        log.debug("收到信 id:{}, 内容:{}", guardedObject.getId(), mail);
    }
}

@Slf4j(topic = "guizy.Postman")
// 邮寄员类
class Postman extends Thread {
    private int id;
    private String mail;

    public Postman(int id, String mail) {
        this.id = id;
        this.mail = mail;
    }

    @Override
    public void run() {
        GuardedObject guardedObject = Mailboxes.getGuardedObject(id);
        log.debug("送信 id:{}, 内容:{}", id, mail);
        guardedObject.complete(mail);
    }
}

// 信箱类
class Mailboxes {
    private static Map<Integer, GuardedObject> boxes = new Hashtable<>();

    private static int id = 1;

    // 产生唯一 id
    private static synchronized int generateId() {
        return id++;
    }

    public static GuardedObject getGuardedObject(int id) {
        //根据id获取到box并删除对应的key和value,避免堆内存爆了
        return boxes.remove(id);
    }

    public static GuardedObject createGuardedObject() {
        GuardedObject go = new GuardedObject(generateId());
        boxes.put(go.getId(), go);
        return go;
    }

    public static Set<Integer> getIds() {
        return boxes.keySet();
    }
}

// 用来传递信息的作用, 当多个类使用GuardedObject,就很不方便,此时需要一个设计一个解耦的中间类
class GuardedObject {
    // 标记GuardedObject
    private int id;
    // 结果
    private Object response;

    public int getId() {
        return id;
    }

    public GuardedObject(int id) {
        this.id = id;
    }

    // 获取结果
    // timeout表示等待多久. 这里假如是2s
    public Object get(long timeout) {
        synchronized (this) {
            // 假如开始时间为 15:00:00
            long begin = System.currentTimeMillis();
            // 经历的时间
            long passedTime = 0;
            while (response == null) {
                // 这一轮循环应该等待的时间
                long waitTime = timeout - passedTime;
                // 经历的时间超过了最大等待时间, 退出循环
                if (waitTime <= 0) {
                    break;
                }
                try {
                    // this.wait(timeout)的问题: 虚假唤醒在15:00:01的时候,此时response还null, 此时经历时间就为1s,
                    // 进入while循环的时候response还是空,此时判断1s<=timeout 2s,此时再次this.wait(2s)吗,此时已经经历了
                    // 1s,所以只要再等1s就可以了. 所以等待的时间应该是 超时时间(timeout) - 经历的时间(passedTime)
                    this.wait(waitTime);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 经历时间
                passedTime = System.currentTimeMillis() - begin; // 15:00:02
            }
            return response;
        }
    }

    // 产生结果
    public void complete(Object response) {
        synchronized (this) {
            // 给结果变量赋值
            this.response = response;
            this.notifyAll();
        }
    }
}
```

join()：等待线程运行结束

join(long n)：等待线程运行结束，最多等待n毫秒



#### 异步模式之生产者/消费者 (`重点`)

- 与前面的`保护性暂停`中的 `GuardedObject` 不同，**不需要**`产生结果`和`消费结果`的`线程一一对应 (一个生产一个消费)`
- **`消费队列`** 可以用来**平衡生产和消费的线程资源**
- **生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据**
- **消息队列是有`容量限制`的，满时不会再加入数据，空时不会再消耗数据**
- JDK 中各种 [阻塞队列](https://blog.csdn.net/yanpenglei/article/details/79556591)，采用的就是这种模式

![img](https://img-blog.csdnimg.cn/img_convert/82487e714da1c44453d46a61d6dcb27b.png)

```
package com.current.demo;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.LinkedList;
import java.util.concurrent.TimeUnit;

/**
 * @program: threadDemo
 * @description: 异步模式之生产者/消费者
 * @author: mengjianglong@e6yun.com
 * @create: 2021-10-27 14:36
 **/

public class MessageTest {
    private Logger log = LoggerFactory.getLogger(MessageTest.class);

    public static void main(String[] args) {
        MessageQueue messageQueue = new MessageQueue(3);
        for (int i = 0; i < 4; i++) {
            int t = i;
            new Thread(() -> {
                messageQueue.put(new Message(t, "值" + t));
            }, "生产者" + i).start();
        }

        new Thread(() -> {
            while (true){
                messageQueue.task();
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },"消费者").start();
    }
}
class MessageQueue {
    private Logger log = LoggerFactory.getLogger(MessageTest.class);

    private LinkedList<Message> messages = new LinkedList<Message>();
    // 队列最大容量
    private int capcity;

    public MessageQueue(int capcity) {
        this.capcity = capcity;
    }

    // 获取消息
    public Message task(){
        synchronized (messages){
            while (messages.isEmpty()){
                try {
                    log.info("队列为空，请等待。。。");
                    messages.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            Message message = messages.removeFirst();
            log.info("以消费消息：{}",message);
            messages.notifyAll();
            return message;
        }
    }
    // 推送消息
    public void put(Message message){
        synchronized (messages){
            while (messages.size() == capcity){
                try {
                    log.info("队列已满，请等待。。。");
                    messages.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            messages.add(message);
            log.info("以生产消息：{}",message);
            messages.notifyAll();
        }

    }
}

final class Message{
    private int id;
    private Object value;

    public Message(int id, Object value) {
        this.id = id;
        this.value = value;
    }

    public int getId() {
        return id;
    }

    public Object getValue() {
        return value;
    }

    @Override
    public String toString() {
        return "Message{" +
                "id=" + id +
                ", value=" + value +
                '}';
    }
}
```

```
15:03:47.280 [消费者] INFO com.current.demo.MessageTest - 队列为空，请等待。。。
15:03:47.282 [生产者0] INFO com.current.demo.MessageTest - 以生产消息：Message{id=0, value=值0}
15:03:47.284 [消费者] INFO com.current.demo.MessageTest - 以消费消息：Message{id=0, value=值0}
15:03:47.284 [生产者1] INFO com.current.demo.MessageTest - 以生产消息：Message{id=1, value=值1}
15:03:47.284 [生产者2] INFO com.current.demo.MessageTest - 以生产消息：Message{id=2, value=值2}
15:03:47.284 [生产者3] INFO com.current.demo.MessageTest - 以生产消息：Message{id=3, value=值3}
15:03:48.285 [消费者] INFO com.current.demo.MessageTest - 以消费消息：Message{id=1, value=值1}
15:03:49.285 [消费者] INFO com.current.demo.MessageTest - 以消费消息：Message{id=2, value=值2}
15:03:50.285 [消费者] INFO com.current.demo.MessageTest - 以消费消息：Message{id=3, value=值3}
15:03:51.285 [消费者] INFO com.current.demo.MessageTest - 队列为空，请等待。。。
```



#### park & unpack `(重要)`

##### 基本使用

- `park/unpark`都是`LockSupport`类中的的方法
- **先调用`unpark`后,再调用park, 此时`park`不会暂停线程**

```
// 暂停当前线程
LockSupport.park();
// 恢复某个线程的运行
LockSupport.unpark(thread);
```

##### 原理

- `每个线程`都有自己的一个 `Parker 对象`，由三部分组成 **`_counter`， `_cond`和 `_mutex`**

- `先调用park的情况`
  - 当前线程调用 **Unsafe.park()** 方法
  - **检查 _counter, 本情况为`0`,** 这时, 获得`_mutex 互斥锁`**(mutex对象有个等待队列 _cond)**
  - 线程进入 _cond 条件变量`阻塞`
  - 设置`_counter = 0` (没干粮了)

![img](https://img-blog.csdnimg.cn/img_convert/090e9cb2aed20d43c147ec0ea6470d5e.png)

- `调用unpark`
  - 调用`Unsafe.unpark(Thread_0)方法`，设置`_counter 为 1`
  - 唤醒 _cond 条件变量中的 Thread_0
  - Thread_0 `恢复运行`
  - **设置 _counter 为 0**

![img](https://img-blog.csdnimg.cn/img_convert/ca03643f837f34098def91bfadc54bd6.png)

- ###### 先调用upark再调用park的过程

- 调用 `Unsafe.unpark(Thread_0)`方法，设置 `_counter 为 1`
- 当前`线程`调用 `Unsafe.park()` 方法
- 检查 `_counter`，本情况为 `1`，这时线程 **`无需阻塞，继续运行`**
- 设置 _counter 为 0

![img](https://img-blog.csdnimg.cn/img_convert/d0d3270088a031c2066af2762e894413.png)

#### 线程状态转换 `(重点)`

![img](https://img-blog.csdnimg.cn/img_convert/64146d2ab235481979b13ec4e9608fc5.png)

- 1、NEW <–> RUNNABLE
  t.start()方法时, NEW --> RUNNABLE

- 2、RUNNABLE <–> WAITING
  线程用synchronized(obj)获取了对象锁后
  调用 obj.wait()方法时，t 线程进入waitSet中, 从RUNNABLE --> WAITING
  调用 obj.notify()，obj.notifyAll()，t.interrupt() 时, 唤醒的线程都到entrySet阻塞队列成为BLOCKED状态, 在阻塞队列,和其他线程再进行 竞争锁
  竞争锁成功，t 线程从 WAITING --> RUNNABLE
  竞争锁失败，t 线程从 WAITING --> BLOCKED

- 3、RUNNABLE <–> WAITING
  当前线程调用 t.join() 方法时，当前线程从 RUNNABLE --> WAITING ,注意是当前线程在t线程对象在waitSet上等待
  t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 WAITING --> RUNNABLE

- 4、RUNNABLE <–> WAITING
  当前线程调用 LockSupport.park() 方法会让当前线程从RUNNABLE --> WAITING
  调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING --> RUNNABLE
  Runnable 和 Timed-Waiting的相互转换

- 5、RUNNABLE <–> TIMED_WAITING (带超时时间的wait)
  t 线程用synchronized(obj) 获取了对象锁后
  调用 obj.wait(long n) 方法时，t 线程从 RUNNABLE --> TIMED_WAITING
  t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时; 唤醒的线程都到entrySet阻塞队列成为BLOCKED状态, 在阻塞队列,和其他线程再进行 竞争锁
  竞争锁成功，t 线程从 TIMED_WAITING --> RUNNABLE
  竞争锁失败，t 线程从 TIMED_WAITING --> BLOCKED

- 6、RUNNABLE <–> TIMED_WAITING
  当前线程调用 t.join(long n) 方法时，当前线程从 RUNNABLE --> TIMED_WAITING 注意是当前线程在t 线程对象的waitSet等待
  当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 TIMED_WAITING --> RUNNABLE

- 7、RUNNABLE <–> TIMED_WAITING
  当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE --> TIMED_WAITING
  当前线程等待时间超过了 n 毫秒或调用了线程的 interrupt() ，当前线程从 TIMED_WAITING --> RUNNABLE

- 8、RUNNABLE <–> TIMED_WAITING
  当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线程从 RUNNABLE --> TIMED_WAITING
  调用LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING--> RUNNABLE

- 9、RUNNABLE <–> BLOCKED
  t 线程用 synchronized(obj) 获取了对象锁时如果竞争失败，从 RUNNABLE –> BLOCKED, 持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –> RUNNABLE ，其它失败的线程仍然 BLOCKED

- 10、 RUNNABLE <–> TERMINATED
  当前线程所有代码运行完毕，进入 TERMINATED







## volatile关键字原理



### 关键字特性

#### 保证可见性

#### 禁止重排序

#### 不保证原子性



### java内存模型

- JMM 即 `Java Memory Model` ，它从Java层面定义了 **`主存`、`工作内存`** 抽象概念，底层对应着CPU 寄存器、缓存、硬件内存、CPU 指令优化等。JMM 体现在以下几个方面
- **`原子性`** - 保证指令不会受 **线程上下文切换的影响**
- **`可见性`** - 保证指令不会受 **cpu 缓存的影响 `(JIT对热点代码的缓存优化)`**
- **`有序性`** - 保证指令不会受 **cpu 指令并行优化的影响**

####  可见性

- 先来看一个现象，`main线程`对`run变量`的`修改`对于`t线程不可见`，**导致了 t 线程无法停止**

```
@Slf4j(topic = "guizy.Test1")
public class Test1 {
    // 增加t1线程, 对主线程更改run变量的可见性
    // 一开始一直不结束, 是因为无限循环, run都是true, JIT及时编译器, 会对t1线程所执行的
    // run变量,进行缓存, 缓存到本地工作内存. 不去访问主存中的run. 这样可以提高性能; 也可以说是JVM打到一定阈值之后
    // while(true)变成了一个热点代码, 所以一直访问的都是缓存到本地工作内存(局部)中的run. 当主线程修改主存中的run变量的时候,
    // t1线程一直访问的是自己缓存的, 所以不认为run已经改为false了. 所以一直运行. 我们为主存(成员变量)进行volatile修饰, 增加
    // 变量的可见性, 当主线程修改run为false, t1线程对run的值可见. 这样就可以退出循环
    volatile static boolean run = true;
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            while (run) {
                // 如果打印一句话
                // 此时就可以结束, 因为println方法中, 使用到了synchronized
                // synchronized可以保证原子性、可见性、有序性
                // System.out.println("123");
            }
        });

        t1.start();
        Sleeper.sleep(1);
        run = false;
        System.out.println(run);
    }
}
```

使用`synchronized`解决

```
@Slf4j(topic = "guizy.Test1")
public class Test1 {
    static boolean run = true;
    final static Object obj = new Object();
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            // 1s内,一直都在无限循环获取锁. 1s后主线程抢到锁,修改为false, 此时t1线程抢到锁对象,while循环也退出
            while (run) {
                synchronized (obj) {

                }
            }
        });

        t1.start();
        Sleeper.sleep(1);
        // 当主线程获取到锁的时候, 就修改为false了
        synchronized (obj) {
            run = false;
            System.out.println("false");
        }
    }
}
```

**为什么会出现对run变量的不可见性呢呢？分析一下：**

- `初始状态`， `t线程`刚开始从`主内存(成员变量)`, 因为主线程sleep(1)秒, 这时候t1线程循环了好多次run的值, 超过了一定的阈值, JIT就会将主存中的run值读取到工作内存 (相当于缓存了一份, 不会去主存中读run的值了)。

![img](https://img-blog.csdnimg.cn/img_convert/55a9700c011a4188ffdb8993f88ded28.png)

- 因为t1线程频繁地从主存中读取run的值，JIT即时编译器会将run的值缓存至自己工作内存中的高速缓存中，减少对主存中run的访问以提高效

![1594646562777](https://img-blog.csdnimg.cn/img_convert/e81d86ac7eea71c6f94dab875af787c7.png)

- 1 秒之后，`main线程修改了run的值, 并同步至主存`。而 t线程是从自己工作内存中的高速缓存中读取这个变量的值，**结果永远是旧值**

![img](https://img-blog.csdnimg.cn/img_convert/62f824bbb5595133018b992b326c7913.png)

![img](https://img-blog.csdnimg.cn/20210202183308792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)





#### CPU多核硬件架构剖析

#### jmm八大同步的规范



### Volatile缓存一致性协议

#### 总线锁

#### MESI协议



### 伪共享的问题

#### 缓存行基本的概念

#### 存行填充方案

### 重排序/内存屏障/双重检验锁为什么需要加上volatile

### synchronized 与volatile存在的区别

### 为什么Volatile不能保证原子性



## synchronized原理



### 锁池/等待池/Monitor监视器锁/对象头原理

#### Java 对象头

java的对象头信息主要包含两部分：

- 运行时元数据

```
1、hashCode 主要是对堆内存中的对象地址进行存储
2、GC的分代计数器 以15为阈值，分为新生代和老年代
3、锁状态的标识 轻量级锁
4、偏向线程ID 偏向锁
5、线程持有锁
6、偏向时间戳
```

- 类型指针

```
类元数据InstanceKlass，确定该对象所属的类型。指向的其实是方法区中存放的类元信息
如果是数组还会记录数组的长度
```

- 以 32 位虚拟机为例,普通对象的对象头结构如下，其中的`Klass Word`为`类型指针`，指向`方法区`对应的`Class对象`；

![img](https://img-blog.csdnimg.cn/img_convert/ac7274e0d0dbe8c8b25f43f2aa1ed1d6.png)

- 数组对象

![img](https://img-blog.csdnimg.cn/img_convert/52c45594819f30fb8a9d6087682be254.png)

- **其中 Mark Word 结构为: `无锁(001)、偏向锁(101)、轻量级锁(00)、重量级锁(10)`**

![img](https://img-blog.csdnimg.cn/img_convert/0ffaeb7ddf7d71801bfd3eeb00754162.png)

- 所以一个对象的结构如下：

![img](https://img-blog.csdnimg.cn/img_convert/1844b5e3159baa3c8fb78478daa1580b.png)

#### Monitor锁

monitor简称监视器或管程。

每个java对象，在执行到Synschronized的时候会关联到操作系统的Monitor对象。也就是使用Synschronized给对象上锁时，对象的mark word会指向Monitor。

```
当Thread1访问到synchronized(obj)中的共享资源的时候
首先会将synchronized中的锁对象中对象头的MarkWord去尝试指向操作系统的Monitor对象. 让锁对象中的MarkWord和Monitor对象相关联. 如果关联成功, 将obj对象头中的MarkWord的对象状态从01改为10。
因为Monitor没有和其他的obj的MarkWord相关联, 所以Thread1就成为了该Monitor的Owner(所有者)。
又来了个Thread1执行synchronized(obj)代码, 它首先会看看能不能执行该临界区的代码; 它会检查obj是否关联了Montior, 此时已经有关联了, 它就会去看看该Montior有没有所有者(Owner), 发现有所有者了(Thread2); Thread1也会和该Monitor关联, 该线程就会进入到它的EntryList(阻塞队列);
当Thread2执行完临界区代码后, Monitor的Owner(所有者)就空出来了. 此时就会通知Monitor中的EntryList阻塞队列中的线程, 这些线程通过竞争, 成为新的所有者
```

![img](https://img-blog.csdnimg.cn/20201219192811839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

- 刚开始时`Monitor`中的`Owner为null`
- **当Thread-2 执行synchronized(obj){}代码时就会将Monitor的所有者Owner 设置为 Thread-2，上锁成功，Monitor中同一时刻只能有一个Owner**
- 当Thread-2 占据锁时，如果线程Thread-3，Thread-4也来执行synchronized(obj){}代码，就会进入`EntryList`中变成`BLOCKED状态`
- **Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，`竞争时是非公平的 (仍然是抢占式)`**
- `图中 WaitSet 中的Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲wait-notify 时会分析`

- 它加锁就是依赖底层操作系统的 `mutex`相关指令实现, 所以会造成`用户态和内核态之间的切换`, 非常耗性能 !

- 在JDK6的时候, 对synchronized进行了优化, 引入了`轻量级锁, 偏向锁`, 它们是在JVM的层面上进行加锁逻辑, 就没有了切换的消耗~



### Synschronized内置锁实现原理

### 站在C++源码如何分析Synchronized原理

### Synchronized锁膨胀过程原理分析



### 偏向锁/轻量锁/自旋锁/重量锁

#### 轻量级锁 (用于优化Monitor这类的重量级锁）

- 场景

```
如果一个对象有很多线程去访问，但多线程访问的时间时错开的，就可以使用轻量级锁优化。语法任然是Synchronized
```

```
static final Object obj = new Object();
public static void method1() {
     synchronized( obj ) {
         // 同步块 A
         method2();
     }
}
public static void method2() {
     synchronized( obj ) {
         // 同步块 B
     }
}
```

 

- 每次指向到`synchronized代码块`时，都会在`栈帧中`创建`锁记录（Lock Record）对象`，**`每个线程都会包括一个锁记录的结构`**，锁记录内部可以储存`对象的MarkWord`和`锁对象引用reference`

![img](https://img-blog.csdnimg.cn/img_convert/4d42844c6ddc19a6f94d954ae5a0cc79.png)

- 让锁记录中的Object reference指向锁对象地址，并且尝试用CAS(compare and sweep)将栈帧中的锁记录的(lock record 地址 00)替换Object对象的Mark Word，将Mark Word 的值(01)存入锁记录(lock record地址)中 ------相互替换
  01 表示 无锁 (看Mark Word结构, 数字的含义)
  00表示 轻量级锁
  ![img](https://img-blog.csdnimg.cn/img_convert/87f63c5373eed35d0bf65e0b510a7660.png)

重点:

- 如果cas替换成功, 获得了轻量级锁，那么对象的对象头储存的就是锁记录的地址和状态00，如下所示
  线程中锁记录, 记录了锁对象的锁状态标志; 锁对象的对象头中存储了锁记录的地址和状态, 标志哪个线程获得了锁
  此时栈帧中存储了对象的对象头中的锁状态标志,年龄计数器,哈希值等; 对象的对象头中就存储了栈帧中锁记录的地址和状态00, 这样的话对象就知道了是哪个线程锁住自己。

![img](https://img-blog.csdnimg.cn/img_convert/68c40cfc17498b1514fe31af8a896eaf.png)



- 如果cas替换失败，有两种情况 : ① 锁膨胀 ② 重入锁失败
  1、如果是其它线程已经持有了该Object的轻量级锁，那么表示有竞争，将进入 锁膨胀阶段
  此时对象Object对象头中已经存储了别的线程的锁记录地址 00,指向了其他线程;
  2、如果是自己的线程已经执行了synchronized进行加锁，那么再添加一条 Lock Record 作为重入锁的计数 – 线程多次加锁, 锁重入
  在上面代码中,临界区中又调用了method2, method2中又进行了一次synchronized加锁操作, 此时就会在虚拟机栈中再开辟一个method2方法对应的栈帧(栈顶), 该栈帧中又会存在一个独立的Lock Record, 此时它发现对象的对象头中指向的就是自己线程中栈帧的锁记录; 加锁也就失败了. 这种现象就叫做锁重入; 线程中有多少个锁记录, 就能表明该线程对这个对象加了几次锁 (锁重入计数)
  ![img](https://img-blog.csdnimg.cn/img_convert/9e36f456637862001c9c58ded2651a3b.png)

#### 锁膨胀

- 在添加轻量级锁的时候，CAS替换操作无法成功。这种情况就是其他线程已经为这个对象加上了轻量级锁，这时有另一个线程再去给对象加锁时会发生锁膨胀，将轻量级锁变为重量级锁。

- 当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁, 此时发生`锁膨胀`

![img](https://img-blog.csdnimg.cn/img_convert/c3e0a92d418c70280fd2a0bb730eea82.png)

- 这时Thread-1加轻量级锁失败，进入锁膨胀流程
  因为Thread-1线程加轻量级锁失败, 轻量级锁没有阻塞队列的概念, 所以此时就要为对象申请Monitor锁(重量级锁)，让Object指向重量级锁地址 10，然后自己进入Monitor 的EntryList 变成BLOCKED状态

![img](https://img-blog.csdnimg.cn/20201219214748700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

- 当Thread-0 线程执行完synchronized同步块时，使用cas将Mark Word的值恢复给对象头, 肯定恢复失败,因为对象的对象头中存储的是重量级锁的地址,状态变为10了之前的是00, 肯定恢复失败。那么会进入重量级锁的解锁过程，即按照Monitor的地址找到Monitor对象，将Owner设置为null，唤醒EntryList中的Thread-1线程

#### 自旋锁优化 (优化重量级锁竞争)

- 当发生重量级锁竞争的时候，还可以使用自旋来进行优化 (不加入Monitor的阻塞队列EntryList中)，如果当前线程自旋成功（即在自旋的时候持锁的线程释放了锁），那么当前线程就可以不用进行上下文切换(持锁线程执行完synchronized同步块后,释放锁,Owner为空,唤醒阻塞队列来竞争,胜出的线程得到cpu执行权的过程) 就获得了锁

- 优化的点: 不用将线程加入到阻塞队列, 减少cpu切换.

1. 自旋重试成功的情况

![img](https://img-blog.csdnimg.cn/img_convert/39ed180b2ab7eae1bc37ebba0a819c4c.png)

1. `旋重试失败的情况`，**自旋了一定次数还是没有等到 持锁的线程释放锁**, 线程2就会加入Monitor的阻塞队列(EntryList)

![img](https://img-blog.csdnimg.cn/img_convert/36162c78749df99fcd83560e3896aef0.png)

- 自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。

- 在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。Java 7 之后不能控制是否开启自旋功能



#### 偏向锁 (biased lock) (用于优化轻量级锁重入)

- 场景

```
没有竞争的时候，一个线程多次使用synchronized需要进行锁重入。因此jvm对其进行了优化，会将mark Work设置为线程的id，这样就避免了多次CAS操作进而节省运行成本。偏向锁是默认开启的, 我们可以通过JVM的配置, 将偏向锁给关闭
```

- 在轻量级的锁中，我们可以发现，如果同一个线程对同一个对象进行重入锁时，也需要执行CAS替换操作，这是有点耗时。

- 那么java6开始引入了偏向锁，将进入临界区的线程的ID, 直接设置给锁对象的Mark word, 下次该线程又获取锁, 发现线程ID是自己, 就不需要CAS了

- 升级为轻量级锁的情况 (会进行偏向锁撤销) : 获取偏向锁的时候, 发现线程ID不是自己的, 此时通过CAS替换操作, 操作成功了, 此时该线程就获得了锁对象。( 此时是交替访问临界区, 撤销偏向锁, 升级为轻量级锁)

- 升级为重量级锁的情况 (会进行偏向锁撤销) : 获取偏向锁的时候, 发现线程ID不是自己的, 此时通过CAS替换操作, 操作失败了, 此时说明发生了锁竞争。( 此时是多线程访问临界区, 撤销偏向锁, 升级为重量级锁)

```
public class Test {
    static final Object obj = new Object();

    public static void m1() {
        synchronized (obj) {
            // 同步块A
            m2();
        }
    }

    public static void m2() {
        synchronized (obj) {
            // 同步块B
            m3();
        }
    }

    public static void m3() {
        synchronized (obj) {
            // 同步块C
        }
    }
}
```

![img](https://img-blog.csdnimg.cn/20201219223917148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20201219223934280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70)

- 偏向锁的使用

`偏向锁默认是延迟`的，不会在程序启动的时候立刻生效，如果想避免延迟，可以添加虚拟机参数来禁用延迟：**`-XX:BiasedLockingStartupDelay=0`来禁用延迟**

- 禁止偏向锁, 虚拟机参数`-XX:-UseBiasedLocking`; 优先使用`轻量级锁`

- hashCode会撤销偏向锁

- **偏向锁、轻量级锁的使用条件, 都是在于多个线程没有对同一个对象进行`锁竞争`的前提下, 如果有`锁竞争`,此时就使用重量级锁。**
  - **会使对象锁变成重量级锁**，因为`wait/notify方法之后重量级锁才支持`

- 加锁对象被多个线程访问，但无竞争，有可能会重新偏向。撤销偏向超过20次偏向锁会发生重新偏向，偏向的线程id为当前的拥有锁的线程。当超过40次时就会将整个类的对象都改为**不可偏向**的。









### 锁的粗化、与消除及性能优化

#### 锁消除

- 线程同步的代价是相当高的，同步的后果是降低并发性和性能。

- 在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。

- 如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。









## 并发锁的分类

### 悲观锁

### 乐观锁

### 自旋锁

### 重入锁

### 公平锁

### 非公平锁



## aqs源码解读

### LockSupport源码解读

### AbstractQueuedSynchronizer源码解读

### ReentrantLock/ReentrantReadWriteLock、ReadWriteLock源码解读

#### ReentrantLock 

- 支持锁重入

- 可重入锁是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此 有权利再次获取这把锁

- 可中断

- lock.lockInterruptibly() : 可以被其他线程打断的中断锁

- 可以设置超时时间

- lock.tryLock(时间) : 尝试获取锁对象, 如果超过了设置的时间, 还没有获取到锁, 此时就退出阻塞队列, 并释放掉自己拥有的锁

- 可以设置为公平锁

- (先到先得) 默认是非公平, true为公平 new ReentrantLock(true)

- 支持多个条件变量( 有多个waitset)

- (可避免虚假唤醒) - lock.newCondition()创建条件变量对象; 通过条件变量对象调用 await/signal方法, 等待/唤醒
  **基本语法**

```
//获取ReentrantLock对象
private ReentrantLock lock = new ReentrantLock();
//加锁
lock.lock();
try {
	//需要执行的代码
}finally {
	//释放锁
	lock.unlock();
}
```

##### 特点

###### 支持锁重入

- 可重入锁是指`同一个线程如果首次获得了这把锁`，那么因为它是这把`锁的拥有者`，因此 **有权利再次获取这把锁**
- 如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住

```
/**
 * Description: ReentrantLock 可重入锁, 同一个线程可以多次获得锁对象
 *
 * @date 2020/12/23 13:50
 */
@Slf4j(topic = "guizy.ReentrantTest")
public class ReentrantTest {

    private static ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) {
    	// 如果有竞争就进入`阻塞队列`, 一直等待着,不能被打断
        lock.lock();
        try {
            log.debug("entry main...");
            m1();
        } finally {
            lock.unlock();
        }
    }

    private static void m1() {
        lock.lock();
        try {
            log.debug("entry m1...");
            m2();
        } finally {
            lock.unlock();
        }
    }

    private static void m2() {
        log.debug("entry m2....");
    }
}
```

###### 可中断 (针对于lockInterruptibly()方法获得的中断锁) 直接退出阻塞队列, 获取锁失败

$$
synchronized 和 reentrantlock.lock() 的锁, 是不可被打断的; 也就是说别的线程已经获得了锁, 我的线程就需要一直等待下去. 不能中断

可被中断的锁, 通过lock.lockInterruptibly()获取的锁对象, 可以通过调用阻塞线程的interrupt()方法
$$

- 如果`某个线程处于阻塞状态`，可以调用其`interrupt方法`让其`停止阻塞`，**获得锁失败**
- 处于阻塞的线程，被打断后就不会阻塞了，直接停止 运行
- 可中断的锁, 在一定程度上可以`被动`的减少`死锁`的概率, 之所以被动, 是因为我们需要手动调用`阻塞线程的interrupt`方法;

```
@Slf4j(topic = "guizy.ReentrantTest")
public class ReentrantTest {

    private static final ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) {

        Thread t1 = new Thread(() -> {
            log.debug("t1线程启动...");
            try {
                // lockInterruptibly()是一个可打断的锁, 如果有锁竞争在进入阻塞队列后,可以通过interrupt进行打断
                lock.lockInterruptibly();
            } catch (InterruptedException e) {
                e.printStackTrace();
                log.debug("等锁的过程中被打断"); //没有获得锁就被打断跑出的异常
                return;
            }
            try {
                log.debug("t1线程获得了锁");
            } finally {
                lock.unlock();
            }
        }, "t1");

        // 主线程获得锁(此锁不可打断)
        lock.lock();
        log.debug("main线程获得了锁");
        // 启动t1线程
        t1.start();
        try {
            Sleeper.sleep(1);
            t1.interrupt();            //打断t1线程
            log.debug("执行打断");
        } finally {
            lock.unlock();
        }
    }
}
```

```
14:18:09.145 guizy.ReentrantTest [main] - main线程获得了锁
14:18:09.148 guizy.ReentrantTest [t1] - t1线程启动...
14:18:10.149 guizy.ReentrantTest [main] - 执行打断
14:18:10.149 guizy.ReentrantTest [t1] - 等锁的过程中被打断
java.lang.InterruptedException
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:898)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1222)
	at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335)
	at com.guizy.reentrantlock.ReentrantTest.lambda$main$0(ReentrantTest.java:25)
	at java.lang.Thread.run(Thread.java:748)
```



使用`lock.lock()`不可以从阻塞队列中打断, 一直等待别的线程释放锁

```
public class ReentrantLockTest {
    private static ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) {
        Thread t1 = new Thread(()->{
            System.out.println("t1启动");
            lock.lock();
            try {
                System.out.println("t1拿到锁");
            }finally {
                lock.unlock();
            }
        },"t1");

        lock.lock();
        System.out.println("main拿到锁");
        t1.start();
        try {
            TimeUnit.SECONDS.sleep(4);
            t1.interrupt();
            System.out.println("main线程执行打断");
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
}
```

```
15:22:20.210 [main] INFO ReentrantLockTest - main拿到锁
15:22:20.216 [t1] INFO ReentrantLockTest - t1启动
15:22:24.217 [main] INFO ReentrantLockTest - main线程执行打断
15:22:24.217 [t1] INFO ReentrantLockTest - t1拿到锁
```

此时在main线程中调用t1线程的interrupt()方法并没有将t1线程打断，等到主线程锁释放后，t1拿到了这个lock锁。

###### 锁超时 (lock.tryLock()) 直接退出阻塞队列, 获取锁失败

$$
防止无限制等待, 减少死锁
$$

- 使用 **`lock.tryLock()`** 方法会`返回获取锁是否成功`。如果成功则返回true，反之则返回false。
- 并且`tryLock方法`可以设置**指定等待时间**，参数为：**`tryLock(long timeout, TimeUnit unit)`** , 其中timeout为最长等待时间，TimeUnit为时间单位

$$
获取锁的过程中, 如果超过等待时间, 或者被打断, 就直接从阻塞队列移除, 此时获取锁就失败了, 不会一直阻塞着 ! (可以用来实现死锁问题)
$$

```
@Slf4j(topic = "ReentrantLockTest")
public class ReentrantLockTest {
    private static ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) {
        Thread t1 = new Thread(()->{
            log.info("t1取锁");
            if (!lock.tryLock()) {
                log.info("t1没有取到锁，直接返回");
                return;
            }
            try {
                log.info("t1拿到锁");
            }finally {
                lock.unlock();
            }
        },"t1");

        lock.lock();
        log.info("main拿到锁");
        t1.start();
        try {
            TimeUnit.SECONDS.sleep(4);
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            log.info("main释放锁");
            lock.unlock();
        }
    }
}
```

```
15:27:20.668 [main] INFO ReentrantLockTest - main拿到锁
15:27:20.671 [t1] INFO ReentrantLockTest - t1取锁
15:27:20.672 [t1] INFO ReentrantLockTest - t1没有取到锁，直接返回
15:27:24.672 [main] INFO ReentrantLockTest - main释放锁
```

- **设置等待时间, 超过等待时间还没有获得锁, 失败, 从阻塞队列移除该线程**

```
@Slf4j(topic = "ReentrantLockTest")
public class ReentrantLockTest {
    private static ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) {
        Thread t1 = new Thread(()->{
            log.info("t1尝试取锁");

            try {
                if (!lock.tryLock(5,TimeUnit.SECONDS)) {
                    log.info("t1没有取到锁，直接返回");
                    return;
                }
            } catch (InterruptedException e) {
                log.info("t1取锁被打断，直接返回");
                e.printStackTrace();
            }

            try {
                log.info("t1拿到锁");
            }finally {
                lock.unlock();
            }
        },"t1");

        lock.lock();
        log.info("main拿到锁");
        t1.start();
        try {
            TimeUnit.SECONDS.sleep(4);
            t1.interrupt();// 打断
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            log.info("main释放锁");
            lock.unlock();
        }
    }
}
```

```
16:40:46.083 [main] INFO ReentrantLockTest - main拿到锁
16:40:46.086 [t1] INFO ReentrantLockTest - t1尝试取锁
16:40:48.089 [t1] INFO ReentrantLockTest - t1超时没有取到锁，直接返回
16:40:50.088 [main] INFO ReentrantLockTest - main释放锁
```



###### 公平锁 new ReentrantLock(true)

- **`ReentrantLock默认是非公平锁, 可以指定为公平锁。`**
- 在线程获取锁失败，进入阻塞队列时，**先进入**的会在锁被释放后**先获得**锁。这样的获取方式就是**公平**的。一般不设置`ReentrantLock`为公平的, 会降低`并发度`
- `Synchronized`底层的`Monitor锁`就是不公平的, 和谁先进入`阻塞队列`是没有关系的。

```
//默认是不公平锁，需要在创建时指定为公平锁
ReentrantLock lock = new ReentrantLock(true);
```

- 公平锁, 可以把竞争的线程放在一个先进先出的阻塞队列上

- 只要持有锁的线程执行完了, 唤醒阻塞队列中的下一个线程获取锁即可; 此时先进入阻塞队列的线程先获取到锁
- 非公平锁, 当阻塞队列中已经有等待的线程A了, 此时后到的线程B, 先去尝试看能否获得到锁对象. 如果获取成功, 此时就不需要进入阻塞队列了. 这样以来后来的线程B就先活的到锁了

```
所以公平和非公平的区别 : 线程执行同步代码块时, 是否回去尝试获取锁, 如果会尝试获取锁, 那就是非公平的, 如果不会尝试获取锁, 直接进入阻塞队列, 再等待被唤醒, 那就是公平的

如果不进如队列呢? 线程一直尝试获取锁不就行了?
一直尝试获取锁, 在synchronized轻量级锁升级为重量级锁时, 做的一个优化, 叫做自旋锁, 一般很消耗资源, cpu一直空转, 最后获取锁也失败, 所以不推荐使用。在jdk6对于自旋锁有一个机制, 在重试获得锁指定次数就失败等等
```



###### 条件变量 (可避免虚假唤醒) - lock.newCondition()创建条件变量对象; 通过条件变量对象调用`await/signal`方法, 等待/唤醒

- **`Synchronized`** 中也有`条件变量`，就是`Monitor监视器`中的 `waitSet等待集合`，当条件不满足时进入`waitSet 等待`

- **`ReentrantLock`** 的条件变量比 synchronized 强大之处在于,它是 **`支持多个条件变量`。**
- 这就好比synchronized 是那些不满足条件的线程都在`一间休息室`等通知; **`(此时会造成虚假唤醒)`**, 而 ReentrantLock 支持`多间休息室`，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒; **`(可以避免虚假唤醒)`**

使用要点：

- await 前需要 **获得锁**

- await 执行后，会释放锁，进入 `conditionObject` (条件变量)中等待

- await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁

  - 竞争 lock 锁成功后，从 await 后继续执行
- signal 方法用来唤醒`条件变量(等待室)`汇总的某一个等待的线程
- signalAll方法, 唤醒`条件变量(休息室)`中的所有线程

```
package com.current.demo;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @program: threadDemo
 * @description: ReentrantLock的条件变量之避免虚假唤醒
 * @author: mengjianglong@e6yun.com
 * @create: 2021-11-18 19:31
 **/
@Slf4j(topic = "ConditionVariable")
public class ConditionVariable {
    // 外卖状态
    private static boolean wmStatue = false;
    // 烟草状态
    private static boolean ycStatue = false;
    private static final ReentrantLock lock = new ReentrantLock();

    // 外卖等待室
    static Condition wmCondition = lock.newCondition();
    // 烟草等待室
    static Condition ycCondition = lock.newCondition();

    public static void main(String[] args) {
        new Thread(()->{
            lock.lock();
            try {
                log.info("有烟没？{}",ycStatue);
                while (!ycStatue){
                    log.info("没有烟，我不干活");
                    try {
                        // 进入等待
                        ycCondition.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.info("有烟了，干活");
            }finally {
                lock.unlock();
            }
        },"老高").start();
        new Thread(()->{
            lock.lock();
            try {
                log.info("外卖来了没？{}",wmStatue);
                while (!wmStatue){
                    log.info("外卖没来，我不吃");
                    try {
                        // 进入等待
                        wmCondition.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } 
                }
                log.info("外卖来，干饭");
            }finally {
                lock.unlock();
            }
        },"小高").start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()->{
            lock.lock();
            try {
                log.info("外卖来了");
                wmStatue = true;
                wmCondition.signal();
            }finally {
                lock.unlock();
            }
        },"t1").start();

        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(()->{
            lock.lock();
            try {
                log.info("烟来了");
                ycStatue = true;
                ycCondition.signal();
            }finally {
                lock.unlock();
            }
        },"t2").start();
    }
}

```

```
20:07:35.256 [老高] INFO ConditionVariable - 有烟没？false
20:07:35.260 [老高] INFO ConditionVariable - 没有烟，我不干活
20:07:35.260 [小高] INFO ConditionVariable - 外卖来了没？false
20:07:35.261 [小高] INFO ConditionVariable - 外卖没来，我不吃
20:07:36.255 [t1] INFO ConditionVariable - 外卖来了
20:07:36.256 [小高] INFO ConditionVariable - 外卖来，干饭
20:07:38.255 [t2] INFO ConditionVariable - 烟来了
20:07:38.255 [老高] INFO ConditionVariable - 有烟了，干活
```

##### 同步模式之顺序控制 (案例)

- 假如有两个线程, 线程A打印1, 线程B打印2.

- 要求: **程序先打印2, 再打印1**

###### Wait/Notify版本实现

```
/**
 * @program: threadDemo
 * @description: 同步顺序控制
 * @author: mengjianglong@e6yun.com
 * @create: 2021-11-25 16:03
 **/
@Slf4j(topic = "SyncPrintWaitTest")
public class SyncPrintWaitTest {
    private static final Object lock = new Object();
    private static boolean p = false;

    public static void main(String[] args) {
        Thread t1 = new Thread(()->{
            synchronized (lock){
                while (!p){
                    try {
                        log.info("等待。。。。。");
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                log.info("解除等待");
            }
        },"t1");

        Thread t2 = new Thread(()->{
            synchronized (lock){
                try {
                    TimeUnit.SECONDS.sleep(2);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                p = true;
                lock.notifyAll();
            }

        },"t2");
        t1.start();
        t2.start();
    }
}
```

```
20:15:27.686 [t1] INFO SyncPrintWaitTest - 等待。。。。。
20:15:29.690 [t1] INFO SyncPrintWaitTest - 解除等待
```



###### 使用ReentrantLock的await/signal

```
package com.current.demo;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @program: threadDemo
 * @description: 同步顺序控制
 * @author: mengjianglong@e6yun.com
 * @create: 2021-11-25 16:03
 **/
@Slf4j(topic = "SyncPrintWaitTest")
public class SyncPrintWaitTest {
    private static final ReentrantLock lock = new ReentrantLock();
    static final Condition condition = lock.newCondition();
    static boolean p = false;

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            lock.lock();

            try {
                while (!p) {
                    try {
                        log.info("进入等待。。。");
                        condition.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            } finally {
                lock.unlock();
            }
            log.info("xiaofei.................");
        }, "t1");

        Thread t2 = new Thread(() -> {
            lock.lock();
            try {
                try {
                    TimeUnit.SECONDS.sleep(5);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.info("jihuo.........");
                p = true;
                condition.signal();
            } finally {
                lock.unlock();
            }
        }, "t2");
        t1.start();
        t2.start();
    }
}
```

```
16:05:30.314 [t1] INFO SyncPrintWaitTest - 进入等待。。。
16:05:35.319 [t2] INFO SyncPrintWaitTest - jihuo.........
16:05:35.319 [t1] INFO SyncPrintWaitTest - xiaofei.................
```



###### 使用LockSupport中的park/unpart

```
package com.current.demo;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.locks.LockSupport;


/**
 * @program: threadDemo
 * @description: 同步顺序控制  打印2，1
 * @author: mengjianglong@e6yun.com
 * @create: 2021-11-25 16:03
 **/
@Slf4j(topic = "SyncPrintWaitTest")
public class SyncPrintWaitTest {
    public static void main(String[] args) {
        Thread t1 = new Thread(()->{
            LockSupport.park();
            log.info("1");
        },"t1");
        t1.start();

        Thread t2 = new Thread(()->{
            log.info("2");
            LockSupport.unpark(t1);
        },"t2");
        t2.start();
    }

}
```

```
16:15:42.370 [t2] INFO SyncPrintWaitTest - 2
16:15:42.373 [t1] INFO SyncPrintWaitTest - 1
```



##### 交替输出

abcabcabcabcabc

###### Wait/Notify版本实现

```
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @program: threadDemo
 * @description: 顺序控制
 * @author: mengjianglong@e6yun.com
 * 控制输出abcabcabcabcabc
 * @create: 2021-12-02 16:24
 **/

public class TestWaitNotify {
    private static final int a = 1;
    private static final int b = 2;
    private static final int c = 3;
    public static void main(String[] args) {
        WaitNotify waitNotify = new WaitNotify(a,5);
        new Thread(()->{
            waitNotify.print("a",a,b);
        },"a").start();
        new Thread(()->{
            waitNotify.print("b",b,c);
        },"a").start();
        new Thread(()->{
            waitNotify.print("c",c,a);
        },"a").start();
    
    }
}
class WaitNotify{
    private int flag;
    private int total;
    public void print(String str,int waitFlag,int nextFlag){
        for (int i = 0; i < total; i++) {
            synchronized (this){
                while(waitFlag != this.flag) {
                    try {
                        this.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.print(str);
                this.flag = nextFlag;
                this.notifyAll();
            }
        }
    }

    public WaitNotify(int flag, int total) {
        this.flag = flag;
        this.total = total;
    }
}
```

```
abcabcabcabcabc
```



###### 使用ReentrantLock的await/signal

```
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @program: threadDemo
 * @description: 顺序控制
 * @author: mengjianglong@e6yun.com
 * 控制输出abcabcabcabcabc
 * @create: 2021-12-02 16:24
 **/

public class TestWaitNotify {
    public static void main(String[] args) {
        AwaitSignal awaitSignal = new AwaitSignal(5);
        Condition a_con = awaitSignal.newCondition();
        Condition b_con = awaitSignal.newCondition();
        Condition c_con = awaitSignal.newCondition();
        new Thread(()->{
            awaitSignal.print("a",a_con,b_con);
        },"a").start();
        new Thread(()->{
            awaitSignal.print("b",b_con,c_con);
        },"a").start();
        new Thread(()->{
            awaitSignal.print("c",c_con,a_con);
        },"a").start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        awaitSignal.lock();

        try {
            a_con.signal();
        } finally {
            awaitSignal.unlock();
        }
    }
}
class AwaitSignal extends ReentrantLock {
    private int total;

    public AwaitSignal(int total) {
        this.total = total;
    }

    public void print(String str, Condition current,Condition next){
        for (int i = 0; i < total; i++) {
            lock();
            try {
                System.out.print(str);
                try {
                    current.await();
                    next.signal();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            } finally {
                unlock();
            }

        }
    }
}

```

```
abcabcabcabcabc
```



###### 使用LockSupport中的park/unpart

```
import java.util.concurrent.locks.LockSupport;

/**
 * @program: threadDemo
 * @description: 顺序控制输出abc
 * @author: mengjianglong@e6yun.com
 * @create: 2021-12-02 16:57
 **/

public class TestParkUnpark {
    static Thread a;
    static Thread b;
    static Thread c;
    public static void main(String[] args) {
        ParkUnpark parkUnpark = new ParkUnpark(5);
        a = new Thread(()->{
            parkUnpark.print("a",b);
        },"a");
        b= new Thread(()->{
            parkUnpark.print("b",c);
        },"b");
        c= new Thread(()->{
            parkUnpark.print("c",a);
        },"c");

        a.start();
        b.start();
        c.start();
        LockSupport.unpark(a);
    }
}
class  ParkUnpark{
    private int total;

    public ParkUnpark(int total) {
        this.total = total;
    }
    public void print(String str,Thread next){
        for (int i = 0; i < total; i++) {
            LockSupport.park();
            System.out.print(str);
            LockSupport.unpark(next);
        }
    }
}
```

```
abcabcabcabcabc
```



### Semaphore/CountDownLatch/CyclicBarrie源码解读



## 并发atomic原子操作

### Atomic原子类

### CAS（乐观锁）原理

### Unsafe魔法类详解



## 阻塞队列BlockingQueue原理



### 阻塞队列分类

#### ArrayBlockingQueue 数组有界队列

#### ConcurrentLinkedQueue 链表有界队列

#### PriorityBlockingQueue 优先级排序无界队列

#### DelayQueue 延时无界队列



### 框架应用

#### 基于BlockingQueue手写线程池

#### 基于BlockingQueue手写消息中间件

#### 基于BlockingQueue手写日志框架



## Executor线程池详解及核心源码剖析

### 为什么要使用线程池

### 线程池核心原理分析

### 为什么阿里不建议使用Executors

### 线程池参数如何合理配置

### 线程池实现优缺点

### 如何基于ThreadPoolExecutor自定义线程池



## FutureTask源码解读

### 基于LockSupport实现FutureTask

### 基于Wait/Notify实现FutureTask



## ForkJoin源码解读

### 并发编程发展

### 工作窃取机制

### Fork Join原理



## Threadlocal源码解读

### 什么是Threadlocal

### Threadlocal应用场景

### Threadlocal与Synchronized区别

### 如何防御Threadlocal内存泄漏问题