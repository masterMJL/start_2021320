**世上无难事，只怕有心人！！！**

# 第七部分：并发编程实战

## 操作系统基础

### 用户态与内核态切换过程

### linux进程模型管理

### linux进程间通信原理

### linux网络通讯原理



## 多线程基础



### 查看进程线程的方法

#### windowns

- 任务管理器
- tasklist 查看进程
- taskkill 杀死进程

#### linux

- ps -fe 查看所有进程
- ps -ft -p 查看某个进程的所有线程
- kill 杀死进程
- top 按大写H切换是否显示线程
- top -H -p 擦好看某个进程的所有线程

#### java

- jps 查看所有java进程
- jstack查看某个java进程所有线程状态
- jconsole 查看某个java进程中线程的运行情况



### 多线程快速入门

#### 什么是进程/线程

##### 进程：

$$
进程实际就是程序运行的实体，类似可执行的.exe文件或.jar。一个进程中可以有多个线程执行。
$$

##### 线程：

```
线程是计算机的最小执行单位，一个线程都是一个单一顺序的控制流
```



#### 多线程应用场景

```
异步调用：用过多线程使某个方法可以异步执行，从而不影响主业务的执行。

多文件操作：多文件下载，FTP等操作，文件解码。都可使用多线程去调用执行。

任务调度：定时任务，同一时间可以操作多个任务调度。

高并发操作：对于一些并发量比较高的业务
```

。



#### 多线程与单线程之间的区别

#### 如何理解多线程cpu切换概念

```
因为一些原因导致cpu不再执行当前线程，转为执行另一个线程代码

线程cpu时间片用完
垃圾回收
有更高优先级的线程执行
线程自己调用了sleep、yield、wait、join、synchronized、lock等方法

发生Context Switch发生时，需要操作系统保存当前线程状态，用于恢复执行，java中由jvm的程序计数器来保存线程状态。
频繁的上下文切换是很耗资源的。
```



#### 多线程真的开的越多越好吗

#### 用户线程与守护线程的区别

#### 如何优雅的停止一个线程

#### 多线程五种状态分析

- 操作系统层面：

![image-20211005114500504](image\image-20211005114500504.png)

##### 创建：

初始创建线程

##### 就绪：

等待cpu调度的线程

##### 运行：

被cpu调度执行的线程

##### 阻塞：

##### 死亡：

- javaApi

![image-20211005142221711](image\image-20211005142221711.png)

- NEW：新建状态
- RUNNABLE：涵盖运行，阻塞，可运行三种状态

- TERMINATED：终止状态
- BLOCKED：根据源码注释，由于调用wait、join及LockSupport.park方法，使线程处于等待状态
- WAITING：

![image-20211005163529149](image\image-20211005163529149.png)

- TIMED WAITING：

```
Thread state for a terminated thread. The thread has completed execution.--终止线程的线程状态。线程已完成执行。
```



#### 创建多线程五种方式

##### 继承Thread类创建线程

```
Thread t1 = new Thread(){
	public void run(){
		//方法体
	}
}
t1.setName("线程名称");
t1.start();
```



##### 实现Runnable接口创建线程（推荐）

将线程和任务分离，Runnable为可运行的任务，Thread代表线程

```
Runnable r = () -> log.debug("running");
        new Thread(r, "t1").start();
```

Runnable更容易和线程池等高级API配合，让任务脱离了Thread继承体系，更灵活。



##### 使用Callable和Future创建线程

FutureTask通过接收Callable类型的参数（Callable源码如下），来处理带有返回结果的情况，FutureTask实现RunnableFuture。

![image-20210927234450226](image\image-20210927234450226.png)

![image-20210927234518930](image\image-20210927234518930.png)

```
FutureTask futureTask = new FutureTask(new Callable() {
            @Override
            public Object call() throws Exception {
                System.out.println("renwu");
                Thread.sleep(1000);
                return 110;
            }
        });
        new Thread(futureTask,"t3").start();
        System.out.println("zhuxiancheng");
        futureTask.get();// 获取结果
```

![image-20210927234115545](image\image-20210927234115545.png)

Future 就是对于具体的 Runnable 或者 Callable 任务的执行结果进行取消、查询是否完成、获取结果。

```
package java.util.concurrent;
public interface Future<V> {
取消任务执行，视具体情况而定，如果传为true并且任务正在运行，则会被取消，如果为false并且任务正在运行，则不会取消。如果该线程存在某些原因不可取消时将会返回false
    boolean cancel(boolean mayInterruptIfRunning);

判断当前task是否被取消。
    boolean isCancelled();

判断当前Future是否执行完成。
    boolean isDone();

用户返回计算结果，如果计算还没有完成，则在get的时候会进行阻塞，直到获取到结果为止
    V get() throws InterruptedException, ExecutionException;

如果在指定时间内没有完成计算，则会抛出TimeoutException
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```




##### 使用线程池例如用Executor框架

##### 使用@Async异步注解创建线程

#### 线程运行原理

```
线程使用栈内存，每个线程启动后，虚拟机会给其分配一块栈内存，栈内存又由多个栈帧组成，对应着当前正在执行的方法。同一个线程内活动的栈帧只能有一个。
```

![image-20210922203343695](image\image-20210922203343695.png)



### 线程中常见的方法

```
sleep：
线程由runing-->TimedWaiting
其他线程可以使用interrupt方法打断正在睡眠的线程，这时sleep会抛出异常
睡眠结束后线程未必会立刻执行
建议用TimeUnit休眠   TimeUnit.SECOUND.sleep（1）
```

```
yield：
线程从Running-->Runable就绪状态
```

```
join、join(long n):
等待线程运行结束(等待n秒后没结果继续往后运行)
```

```
interrupt：
打断阻塞状态的线程
sleep、wait、join被打断后会抛出异常

打断执行中的线程
通过打断标记结束运行isInterrupt()
```

```
park线程：
/**
 * @author 25283
 * @version 1.0
 * @description: TODO park线程
 * @date 2021/10/5 11:23
 */
public class ParkThread {
    public static void main(String[] args) {
        Thread t1 = new Thread(()->{
            System.out.println("park....");
            LockSupport.park();
            System.out.println("unPark...");
            // 将打断状态置为
            Thread.currentThread().interrupted();
            LockSupport.park();
            System.out.println("unpark..");
        },"t1");
        t1.start();

        //打断park
        t1.interrupt();
    }
}
park线程是属于LockSupport工具类中的一个打断线程的方法，该方法收到isInterrupt的影响，如果为true会导致park打断失效。因此在使用时需要注意及时将当前线程的打断状态调整为false，及利用interrupted回归为false；
```



### 两阶段终止模式（设计模式）

在线程T1中如何优雅的终止线程T2

实际上就是利用interrupt去打断一个线程，打断完成后则利用isInterrupt去判断线程是否被打断，若被打断则正常结束当前线程也就是这里的正常跳出循环，结束该方法体的执行。一般情况下我们不可以直接使用java自带的stop去结束一个线程，而且jdk1.8已经不推荐使用，盲目使用stop去终止一个线程，有可能会导致该线程所占用的共享资源锁不被释放，从而造成程序的错误。而System.exit()会直接结束运行当前程序。

```
/**
 * @author 25283
 * @version 1.0
 * @description: 两阶段终止模式
 * @date 2021/10/5 10:54
 */
public class TwoStageTerminationMode {
    public static void main(String[] args) {
        TwoThread twoThread = new TwoThread();
        twoThread.start();

        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        twoThread.stop();
    }
}
class TwoThread{
    public Thread mode;

    public void start(){
        mode = new Thread(()->{
            while (true){
                Thread currentThread = Thread.currentThread();
                if (currentThread.isInterrupted()) {
                    System.out.println("我正常离职了");
          break;
                }

                try {
                    TimeUnit.SECONDS.sleep(1);
                    System.out.println("我在履职");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    currentThread.interrupt();
                }
            }
        });
        mode.start();
    }
    public void stop(){
        mode.interrupt();
    }
}
```



### 线程优先级

不是所有优先级高的线程会先执行，所有的调度都去决于CPU，在cpu比较繁忙的时候，优先级高的有可能先执行。



### 主线程和守护线程

- 守护线程：等其他非守护线程结束了，即使守护线程代码没执行完他也会停止运行。
- 应用：垃圾回收器就是一种守护线程，tomcat中的Acceptor和poller



### 多线程线程安全

#### 什么是线程安全问题

#### 共享资源问题

##### 临界区

一段代码中如果对共享资源有读写操作，称这段代码块为临界区

##### 竟态条件

多个线程在临界区内执行，导致代码执行序列不同而导致结果无法预测，称为竞态条件



#### Synchronized解决线程安全问题

阻塞式解决线程安全问题



#### lock与Synchronized锁区别

#### Lock锁解决线程安全问题

#### 多线程死锁线程产生的原因

#### 多线程如何排查死锁的现象

#### lock读写锁的使用



### 多线程之间通讯

#### 生产者与消费者

#### wait和notify

#### join方法的原理

join()：等待线程运行结束

join(long n)：等待线程运行结束，最多等待n毫秒



## volatile关键字原理



### 关键字特性

#### 保证可见性

#### 禁止重排序

#### 不保证原子性



### java内存模型

#### CPU多核硬件架构剖析

#### jmm八大同步的规范



### Volatile缓存一致性协议

#### 总线锁

#### MESI协议



### 伪共享的问题

#### 缓存行基本的概念

#### 存行填充方案

### 重排序/内存屏障/双重检验锁为什么需要加上volatile

### synchronized 与volatile存在的区别

### 为什么Volatile不能保证原子性



## synchronized原理

### Synchronized内置锁实现原理

### 站在C++源码如何分析Synchronized原理

### 锁池/等待池/Monitor监视器锁/对象头原理

### Synchronized锁膨胀过程原理分析

### 偏向锁/轻量锁/自旋锁/重量锁

### 锁的粗化、与消除及性能优化



## 并发锁的分类

### 悲观锁

### 乐观锁

### 自旋锁

### 重入锁

### 公平锁

### 非公平锁



## aqs源码解读

### LockSupport源码解读

### AbstractQueuedSynchronizer源码解读

### ReentrantLock/ReentrantReadWriteLock、ReadWriteLock源码解读

### Semaphore/CountDownLatch/CyclicBarrie源码解读



## 并发atomic原子操作

### Atomic原子类

### CAS（乐观锁）原理

### Unsafe魔法类详解



## 阻塞队列BlockingQueue原理



### 阻塞队列分类

#### ArrayBlockingQueue 数组有界队列

#### ConcurrentLinkedQueue 链表有界队列

#### PriorityBlockingQueue 优先级排序无界队列

#### DelayQueue 延时无界队列



### 框架应用

#### 基于BlockingQueue手写线程池

#### 基于BlockingQueue手写消息中间件

#### 基于BlockingQueue手写日志框架



## Executor线程池详解及核心源码剖析

### 为什么要使用线程池

### 线程池核心原理分析

### 为什么阿里不建议使用Executors

### 线程池参数如何合理配置

### 线程池实现优缺点

### 如何基于ThreadPoolExecutor自定义线程池



## FutureTask源码解读

### 基于LockSupport实现FutureTask

### 基于Wait/Notify实现FutureTask



## ForkJoin源码解读

### 并发编程发展

### 工作窃取机制

### Fork Join原理



## Threadlocal源码解读

### 什么是Threadlocal

### Threadlocal应用场景

### Threadlocal与Synchronized区别

### 如何防御Threadlocal内存泄漏问题