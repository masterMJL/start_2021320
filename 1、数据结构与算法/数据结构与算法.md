



**世上无难事，只怕有心人！**！！

# 第一部分：数据结构与算法实战





## 第一节：数学知识回顾

### 指数

```
指数是幂运算aⁿ(a≠0)中的一个参数，a为底数，n为指数，指数位于底数的右上角，幂运算表示指数个底数相乘。当n是一个正整数，aⁿ表示n个a连乘。当n=0时，aⁿ=1。
y=a^x(a>0且baia≠1)
x就是指数。
```



### 对数

```
在数学中，对数是对求幂的逆运算，正如除法是乘法的倒数，反之亦然。 这意味着一个数字的对数是必须产生另一个固定数字（基数）的指数。 在简单的情况下，乘数中的对数计数因子。更一般来说，乘幂允许将任何正实数提高到任何实际功率，总是产生正的结果，因此可以对于b不等于1的任何两个正实数b和x计算对数。

如果a的x次方等于N（a>0，且a≠1），那么数x叫做以a为底N的对数（logarithm），记作x=loga N。其中，a叫做对数的底数，N叫做真数。
```



### 级数

```
级数是指将数列的项依次用加号连接起来的函数。典型的级数有正项级数、交错级数、幂级数、傅里叶级数等。

级数理论是分析学的一个分支；它与另一个分支微积分学一起作为基础知识和工具出现在其余各分支中。二者共同以极限为基本工具，分别从离散与连续两个方面，结合起来研究分析学的对象，即变量之间的依赖关系──函数。

https://baike.baidu.com/item/%E7%BA%A7%E6%95%B0/2381414?fr=aladdin
```



### 模运算

```

运算规则
模运算与基本四则运算有些相似，但是除法例外。其规则如下：

(a + b) % p = (a % p + b % p) % p （1）

(a – b) % p = (a % p – b % p) % p （2）

(a * b) % p = (a % p * b % p) % p （3）

(a^b) % p = ((a % p)^b) % p （4）

结合律：

((a+b) % p + c) % p = (a + (b+c) % p) % p （5）

((a*b) % p * c)% p = (a * (b*c) % p) % p （6）

交换律：

(a + b) % p = (b+a) % p （7）

(a * b) % p = (b * a) % p （8）

分配律：

((a +b)% p * c) % p = ((a * c) % p + (b * c) % p) % p （9）

重要定理：

若a≡b (% p)，则对于任意的c，都有(a + c) ≡ (b + c) (%p)；（10）

若a≡b (% p)，则对于任意的c，都有(a * c) ≡ (b * c) (%p)；（11）

若a≡b (% p)，c≡d (% p)，则 (a + c) ≡ (b + d) (%p)，(a – c) ≡ (b – d) (%p)，

(a * c) ≡ (b * d) (%p)，(a / c) ≡ (b / d) (%p)； （12）
```



### 复杂度

#### 时间复杂度

```
在计算机科学中，时间复杂性，又称时间复杂度，算法的时间复杂度是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。

定义：如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)，它是n的某一函数 T(n)称为这一算法的“时间复杂性”。

当输入量n逐渐加大时，时间复杂性的极限情形称为算法的“渐近时间复杂性”。

我们常用大O表示法表示时间复杂性，注意它是某一个算法的时间复杂性。大O表示只是说有上界，由定义如果f(n)=O(n)，那显然成立f(n)=O(n^2)，它给你一个上界，但并不是上确界，但人们在表示的时候一般都习惯表示前者。

此外，一个问题本身也有它的复杂性，如果某个算法的复杂性到达了这个问题复杂性的下界，那就称这样的算法是最佳算法。

“大O记法”：在这种描述中使用的基本参数是 n，即问题实例的规模，把复杂性或运行时间表达为n的函数。这里的“O”表示量级 (order)，比如说“二分检索是 O(logn)的”,也就是说它需要“通过logn量级的步骤去检索一个规模为n的数组”记法 O ( f(n) )表示当 n增大时，运行时间至多将以正比于 f(n)的速度增长。

这种渐进估计对算法的理论分析和大致比较是非常有价值的，但在实践中细节也可能造成差异。例如，一个低附加代价的O(n2)算法在n较小的情况下可能比一个高附加代价的 O(nlogn)算法运行得更快。当然，随着n足够大以后，具有较慢上升函数的算法必然工作得更快。

O(1)

Temp=i;i=j;j=temp;                    

以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。


        O(n^2)

2.1. 交换i和j的内容
     sum=0；                 （一次）
     for(i=1;i<=n;i++)       （n次 ）
        for(j=1;j<=n;j++) （n^2次 ）
         sum++；       （n^2次 ）
解：T(n)=2n^2+n+1 =O(n^2)

2.2.   
    for (i=1;i<n;i++)
    {
        y=y+1;         ①   
        for (j=0;j<=(2*n);j++)    
           x++;        ②      
    }         
解： 语句1的频度是n-1
          语句2的频度是(n-1)*(2n+1)=2n^2-n-1
          f(n)=2n^2-n-1+(n-1)=2n^2-2
          该程序的时间复杂度T(n)=O(n^2).         

O(n)      
                                                      
2.3.
    a=0;
    b=1;                      ①
    for (i=1;i<=n;i++) ②
    {  
       s=a+b;　　　　③
       b=a;　　　　　④  
       a=s;　　　　　⑤
    }
解：语句1的频度：2,        
           语句2的频度： n,        
          语句3的频度： n-1,        
          语句4的频度：n-1,    
          语句5的频度：n-1,                                  
          T(n)=2+n+3(n-1)=4n-1=O(n).
                                                                                                 

        O(log2n )

2.4.
     i=1;       ①
    while (i<=n)
       i=i*2; ②
解： 语句1的频度是1,  
          设语句2的频度是f(n),   则：2^f(n)<=n;f(n)<=log2n    
          取最大值f(n)= log2n,
          T(n)=O(log2n )

O(n^3)

2.5.
    for(i=0;i<n;i++)
    {  
       for(j=0;j<i;j++)  
       {
          for(k=0;k<j;k++)
             x=x+2;  
       }
    }
解：当i=m, j=k的时候,内层循环的次数为k当i=m时, j 可以取 0,1,...,m-1 , 所以这里最内循环共进行了0+1+...+m-1=(m-1)m/2次所以,i从0取到n, 则循环共进行了: 0+(1-1)*1/2+...+(n-1)n/2=n(n+1)(n-1)/6所以时间复杂度为O(n^3).
                                  

我们还应该区分算法的最坏情况的行为和期望行为。如快速排序的最 坏情况运行时间是 O(n^2)，但期望时间是 O(nlogn)。通过每次都仔细 地选择基准值，我们有可能把平方情况 (即O(n^2)情况)的概率减小到几乎等于 0。在实际中，精心实现的快速排序一般都能以 (O(nlogn)时间运行。
下面是一些常用的记法：


访问数组中的元素是常数时间操作，或说O(1)操作。一个算法如 果能在每个步骤去掉一半数据元素，如二分检索，通常它就取 O(logn)时间。用strcmp比较两个具有n个字符的串需要O(n)时间。常规的矩阵乘算法是O(n^3)，因为算出每个元素都需要将n对 元素相乘并加到一起，所有元素的个数是n^2。
指数时间算法通常来源于需要求出所有可能结果。例如，n个元 素的集合共有2n个子集,所以要求出所有子集的算法将是O(2n)的。指数算法一般说来是太复杂了，除非n的值非常小，因为，在 这个问题中增加一个元素就导致运行时间加倍。不幸的是，确实有许多问题 (如著名的“巡回售货员问题” )，到目前为止找到的算法都是指数的。如果我们真的遇到这种情况，通常应该用寻找近似最佳结果的算法替代之。
```

![image-20210329214601616](images\image-20210329214601616.png)

![image-20210329214742498](images\image-20210329214742498.png)

![image-20210329215841785](images\image-20210329215841785.png)

![image-20210329221503913](images\image-20210329221503913.png)





#### 空间复杂度

```
空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。比如直接插入排序的时间复杂度是O(n^2),空间复杂度是O(1) 。而一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。


```





## 第二节：数据结构

![image-20210228170002882](images\image-20210228170002882.png)

### 栈模型

https://blog.csdn.net/weixin_42041195/article/details/109730501

栈（又被称作堆栈，但与堆不是同一个概念）是用来存放对象的一种特殊的容器，它是最基本的数据结构之一，遵循“先进后出（Last-in-first-out，LIFO）”的原则。

栈有两个端点，起始的一端被称作栈底，另一端被称作栈顶（可以添加新元素的一端），栈底固定，而栈顶浮动，且栈内元素的增减只能在栈顶实现。一般会用一个指针指向栈顶的位置，以方便入栈和出栈的操作。

入栈和出栈是栈的两个最基本的接口，分别代表向栈内添加或删除元素。


先进后出原则

入栈/出栈/压栈

我们可以往栈中添加对象，此操作被称为“**入栈**”，一般我们习惯用 **push** 表示将一个对象压至栈顶。

对于入栈操作而言，如果栈的容量是固定的，那入栈操作就可能会有**栈溢出**的风险，在实际编写代码时需要注意到这一点。

![img](images\watermark1145.png)



同样的也可以删除栈中的元素，此操作被称为“**出栈**”，一般习惯用 **pop** 表示将一个对象从栈顶移除。

对于出栈操作而言，存在“**栈空**”的风险，即进行出栈操作时，栈内已经没有元素了。

![img](images\watermark1146.png)

栈的应用



Java 虚拟机（JVM）中的栈：
Java 的每一个程序都要被编译为一个二进制指令序列，这些指令可以在一个特定的计算模型 ——Java 虚拟机（Java Virtual Machine, JVM）上执行。对于 JVM 的定义而言，栈这一数据结构也是至关重要的。

任一运行中的Java程序（更准确地说，应该是运行中的Java线程）都会配备一个私有的栈，称作Java方法栈（Java method stack）或简称Java栈（Java stack），用来记录各个方法在被调用过程中的局部变量等重要信息。

JVM 还设置了一个被称作程序计数器（Program counter）的变量PC，负责记录程序在 JVM 中运行时的当前位置。当方法 N 要调用方法 M 时，程序计数器当前的数值就会被存放在 N 的实例所 对应的帧中⎯⎯这样，待M执行完毕后，JVM才能知道应该返回到什么位置并继续执行下去。

![img](images\watermark1147.png)

上图是一个Java方法栈的实例，如图所示，JVM通过栈实现了方法的调用，同时将参数以值传递的方式传递给被调用的方法。

实际上，JVM 对栈的应用并不仅限于方法栈。在对算术表达式进行求值时，JVM 也使用了另一个栈——操作数栈（Operand stack）。

以“a+b”为例，为了计算其值，首先将 a 和 b 依次压入栈中，然后执行一条专门的指令。该指令要求将栈顶的两个元素弹出，对它们实施加法，并将结果重新压入栈中。

其他应用：
除了在JVM中，栈在其它地方也有着广泛的应用，例如：

撤销操作
中断
实现一组数据的倒置
表达式中括号的匹配



#### 栈的实际应用

比如计算某个表达式7x2x2-5+1

stack(栈)----先入后出的有序列表

栈顶：为变化的一端

栈底：为固定的一端



#### 应用场景

1. 子程序的调用：在调用子程序前，会提前将下一个指令的地址保存至堆栈中，直到子程序执行完之后再取出，回到原来的程序中。类似return
2. 递归调用：将下一个指令的地址、参数、区域变量等数据存入堆栈中。
3. 表达式转换：【中缀表达式转后缀表达式】与求值
4. 二叉树的遍历 
5. 图形的深度优先（depth-first）搜索法



#### 示例

1. 数组模拟栈（com.atguigu.stack.ArrayStackDemo）：

思路分析：定义一top表示栈顶，初始化-1。当有数据入栈时top++，stack[top] = value。当有数据出栈时top--...



- 栈实现综合计算器（com.atguigu.stack.Calculator）

思路分析：![image-20210321153213744](images\image-20210321153213744.png)



- 前缀、中缀、后缀表达式（逆波兰表达式）

- 前缀：计算机从右向左扫描

  ![image-20210321214934786](images\image-20210321214934786.png)

- 中缀：

  ![image-20210321215047806](images\image-20210321215047806.png)

- 后缀：从左向右

  ![image-20210321215222854](images\image-20210321215222854.png)
  
  
  
- 递归（com.guigu.recursion）

定义：方法自己调用自己，每次调用时传入的变量不同，递归有助于解决复杂问题。

![image-20210324230220668](images\image-20210324230220668.png)

```
package com.atguigu.recursion;

public class RecursionTest {
    public static void main(String[] args) {
        System.out.println(factorial(4));
    }

    // 第一个递归调用
    public static void test(int n){
        if (n>2){
            test(n-1);
        }
        System.out.println("n="+n);
    }

    // 数的阶乘
    public static int factorial(int n){
        if (n==1){
            return 1;
        }else {
            return factorial(n-1)*n;
        }
    }
}
```

递归调用机制：

1、当一个递归程序执行时，首先会在栈中开辟一块空间，用来存放初始的局部变量及执行方法。

2、当满足递归的条件后，将继续在栈中开辟一块空间用来执行递归调用的方法，并且每次满足条件时都会在栈中独立开辟一块空间。

3、当条件不满足时开始进行回溯，一层一层的向最初的栈执行。并将每个栈中保存的要输出的值打印出来。

![image-20210324233458376](images\image-20210324233458376.png)

数的阶乘问题v

迷宫问题（回溯）（com.atguigu.recursion.MiGong）

![image-20210324234039238](images\image-20210324234039238.png)

```
package com.atguigu.recursion;

public class MiGong {
    public static void main(String[] args) {
        // 定义二维数组
        int[][] map = new int[8][7];

        // 添加上下挡板
        for (int i = 0; i < 7; i++) {
            map[0][i] = 1;
            map[7][i] = 1;
        }

        // 添加左右挡板
        for (int i = 0; i < 8; i++) {
            map[i][0] = 1;
            map[i][6] = 1;
        }

        // 添加特数当版
        map[3][1] = 1;
        map[3][2] = 1;

        // 输出
        System.out.println("地图：");
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(map[i][j] + " ");
            }
            System.out.println();
        }

        setWay(map,1,1);
        System.out.println("新地图：");
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(map[i][j] + " ");
            }
            System.out.println();
        }
    }
    // 使用递归回溯给小球找最短路径i开始   j结束   map地图
    // 如果是map[6][5]说明该位置已经通
    // 约定map中 1 为墙  2为通路可以走  3为该点已经走过，走不通
    // 定义策略  上--右---下--左
    public static boolean setWay(int[][] map,int i,int j){
        if (map[6][5] == 2){
            return true;
        }else {
            if (map[i][j] ==0){// 没走过，按策略走
                map[i][j] = 2;// 假设能走通
                if (setWay(map,i+1,j)){// 下
                    return true;
                }else if (setWay(map,i,j+1)){// 右
                    return true;
                }else if (setWay(map,i-1,j)){// 上
                    return true;
                }else if (setWay(map,i,j-1)){// 左
                    return true;
                }else {
                    map[i][j] = 3;// 走不通
                    return false;
                }
            }else {
                return false;
            }
        }
    }
}
```



- 递归-八皇后问题（回溯算法）

![image-20210329210035066](images\image-20210329210035066.png)

![image-20210329210922082](images\image-20210329210922082.png)





### 稀疏数组

![image-20210228170457141](images\image-20210228170457141.png)

```
当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。

稀疏数组的处理方法：
纪录数组一共有几行几列，有多少个不同的值。
把具有不同值的元素的行列及值纪录在一个小规模的数组中，从而缩小程序的规模。
```

![image-20210228171337489](images\image-20210228171337489.png)

![image-20210228171418110](images\image-20210228171418110.png)

![image-20210228201413571](images\image-20210228201413571.png)

```
package com.atguigu.sparse;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;

/**
 * @author mjl88
 * @date 2021/2/28  20:31
 */
public class SparseArray {
    public static void main(String[] args) {
        // 创建原始二维数组11*11
        // 0：无棋子  1：黑子  2：白子
        int chessArray1[][] = new int[11][11];
        chessArray1[1][2] = 1;
        chessArray1[2][3] = 2;

        System.out.println("原始数组：");
        for (int[] row:chessArray1){

            for (int item:row){
                System.out.printf("%d\t",item);
            }
            System.out.println();
        }

        // 将原始数组转化为稀疏数组
        int sum = 0;
        for (int i=0;i< chessArray1.length;i++){
            for (int j=0;j< chessArray1.length;j++){
                if (chessArray1[i][j] != 0){
                    sum++; // 得到有效数字
                }
            }

        }
        // 创建稀疏数组
        int sparseArr[][] = new int[sum+1][3];
        // 给稀疏数组赋值
        sparseArr[0][0] = 11;
        sparseArr[0][1] = 11;
        sparseArr[0][2] = sum;

        // 遍历二维数组将有效值放入稀疏数组中
        int count = 0;
        for (int i=0;i< chessArray1.length;i++){
            for (int j=0;j< chessArray1.length;j++){
                if (chessArray1[i][j] != 0){
                    count++;
                    sparseArr[count][0] = i;
                    sparseArr[count][1] = j;
                    sparseArr[count][2] = chessArray1[i][j];
                }
            }

        }

        // 输出稀疏数组
        System.out.println("稀疏数组为：");
        for (int i= 0;i<sparseArr.length;i++){
            System.out.printf("%d\t%d\t%d\t\n",sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]);
        }

        // 将稀疏数组---》二维数组
        int chessArray2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];
        // 取出有效值
        for (int i=1;i<sparseArr.length;i++){
            chessArray2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
        }
        System.out.println("还原后的数组：");
        for (int[] row:chessArray1){

            for (int item:row){
                System.out.printf("%d\t",item);
            }
            System.out.println();
        }
    }
}

```



### 队列模型

![image-20210301193603320](images\image-20210301193603320.png)

先进先出原则

![image-20210301194010217](images\image-20210301194010217.png)

![image-20210301194213853](images\image-20210301194213853.png)

顺序队列

```java
com.atguigu.queue
数组队列：
class ArrQueue{
    private int maxSize;// 最大容量
    private int front;// 队列头部
    private int rear;// 队列尾部
    private int[] arr;// 存放数据，模拟队列

    public ArrQueue(int arrMaxSize){
        maxSize = arrMaxSize;
        front = -1;// 初始化头部,指向头的迁移个位置
        rear = -1;// 初始化尾部，指向尾的前一个位置
        arr = new int[arrMaxSize];
    }

    // 判断队列是否满
    public boolean isFull(){
        return rear == maxSize-1;
    }
    // 判断是否为null
    public boolean isEmpty(){
        return rear == front;
    }

    // 添加数据到队列
    public void addQueue(int n){
        if (isFull()){
            System.out.println("队列已满。。。。");
            return;
        }
        rear++;
        arr[rear] = n;
    }

    // 取出数据
    public int getQueue() {
        if (isEmpty()){
            throw new RuntimeException("队列为空.....");
        }
        front++;
        return arr[front];
    }

    // 遍历队列s
    public void getArr() {
        if (isEmpty()){
            System.out.println("队列为空");
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.printf("arr[%d]=%d\n",i,arr[i]);
        }
    }

    // 取头信息
    public int headQueue(){
        if (isEmpty()){
            throw new RuntimeException("队列为空.....");
        }
        return arr[front+1];
    }
}
```

环形队列

![image-20210307110408526](images\image-20210307110408526.png)

```
 com.atguigu.queue
 // 使用数组模拟环形队列
    class ArrQueue {
        private int maxSize;// 最大容量
        private int front;// 队列头部
        private int rear;// 队列尾部
        private int[] arr;// 存放数据，模拟队列

        public ArrQueue(int arrMaxSize) {
            maxSize = arrMaxSize;
            front = 0;// 初始化头部,指向头的迁移个位置
            rear = 0;// 初始化尾部，指向尾的前一个位置
            arr = new int[maxSize];
        }

        // 判断队列是否满
        public boolean isFull() {
            return (rear + 1) % maxSize == front;
        }

        // 判断是否为null
        public boolean isEmpty() {
            return rear == front;
        }

        // 添加数据到队列
        public void addQueue(int n) {
            if (isFull()) {
                System.out.println("队列已满。。。。");
                return;
            }
            arr[rear] = n;
            rear = (rear + 1) % maxSize;
        }

        // 取出数据
        public int getQueue() {
            if (isEmpty()) {
                throw new RuntimeException("队列为空.....");
            }
            int value = arr[front];
            front = (front + 1) % maxSize;
            return value;
        }

        // 遍历队列s
        public void getArr() {
            if (isEmpty()) {
                System.out.println("队列为空");
                return;
            }
            for (int i = front; i < front + size(); i++) {
                System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]);
            }
        }

        // 求出当前队列有效数据个数
        public int size() {
            return (rear + maxSize - front) % maxSize;
        }

        // 取头信息
        public int headQueue(){
            if (isEmpty()){
                throw new RuntimeException("队列为空.....");
            }
            return arr[front];
        }
    }
```

链式队列

双端队列

优先队列

### 链表

![image-20210307115149159](images\image-20210307115149159.png)



单链表

![image-20210307115613142](images\image-20210307115613142.png)

![image-20210307120255435](images\image-20210307120255435.png)

```

package com.atguigu.linkedlist;

/**
 * @author mjl88
 * @date 2021/3/7  12:07
 */
public class SingleLinkedListDemo {
    public static void main(String[] args) {
        SingleLinkedList singleLinkedList = new SingleLinkedList();
        HeroNode node1 = new HeroNode(1,"小明","学习");
        HeroNode node2 = new HeroNode(2,"小红","玩耍");
        HeroNode node3 = new HeroNode(3,"小与","游戏");
        HeroNode node4 = new HeroNode(4,"小李","跑步");
        singleLinkedList.add(node1);
        singleLinkedList.add(node2);
        singleLinkedList.add(node3);
        singleLinkedList.add(node4);
        singleLinkedList.list();
    }
}
// 定义一个管理者 ，用来管理HeroNode
class SingleLinkedList{
    // 创建头节点
    HeroNode head = new HeroNode(0,"","");

    // 加入一个节点
    public void add(HeroNode node){
        // 因为头节点不能动，我们需定义一个辅助变量temp
        HeroNode temp = head;

        // 遍历找最后一个节点
        while (true){
            if (temp.next == null){
                break;
            }
            temp = temp.next;
        }
        temp.next = node;
    }

    // 遍历链表
    public void list(){
        // 判断链表是否为空
        if (head.next == null){
            System.out.println("链表为空...");
            return;
        }

        HeroNode temp = head.next;

        while (true){
            if (temp == null){
                break;
            }
            System.out.println(temp);
            temp = temp.next;
        }
    }
}
// 定义一个HeroNode，每个HeroNode就是一个节点
class HeroNode{
    public int no;
    public String name;
    public String nickName;
    public HeroNode next;// next域，指向下一个节点

    // 构造器

    public HeroNode(int no,String name, String nickName) {
        this.no = no;
        this.name = name;
        this.nickName = nickName;
    }

    // 重写toString方法

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickName='" + nickName +
                '}';
    }
}

```



查找单链表的有效长度

```
// 获取单链表节点个数
    public static int getLength(HeroNode node) {
        if (node.next == null) {
            return 0;
        }
        int length = 0;
        HeroNode crr = node.next;
        while (crr != null) {
            length++;
            crr = crr.next;
        }
        return length;
    }
```



查找链表中倒数第K个值

```
// 查找链表中倒数第K各值
    public static HeroNode getLastHeroNode(HeroNode node,int index){
        // 如果链表为null
        if (node.next==null){
            return null;
        }
        int size = getLength(node);// 得到长度
        // 第二次遍历size-index位置，就是倒数第k各节点
        if (index<=0||index>size){
            return null;
        }
        HeroNode cur = node.next;
        for (int i =0;i<size-index;i++){
            cur = cur.next;
        }
        return cur;
    }
```





双向链表

![image-20210313155408053](images\image-20210313155408053.png)



![image-20210313160655039](images\image-20210313160655039.png)



### 树模型

![image-20210407232457076](images\image-20210407232457076.png)

为什么要使用树模型：

1. 数组：由于数组是一个定长的存储结构，虽然它有下标能够促进查询出的速度，但当插入一个值时。从插入位置开始，后面的所有索引都会发生变化，且数组长度不够时，会进行扩容，也就是将原来的数据拷贝到数组，然后将xin-数据插入。
2. 链表：整体在进行增加和删除的时候，由于它具有指向节点。因此每次变化时只需找到对应节点进行操作即可。而在进行检索的时候，需从头节点开始遍历，因此效率较低。
3. 树：既可以保证检索速度，也可保证插入、删除的速度。

![image-20210407234242894](images\image-20210407234242894.png)

#### 二叉树

常用术语：

- 节点‘
- 根节点
- 父节点
- 子节点
- 叶子节点（没有子节点的节点）
- 节点的权（节点值）
- 路径（从root节点找到该节点的路线）
- 层
- 子树
- 树的高度（最大层数）
- 森林：多颗子树构成的森林



定义：

每个节点最多只能有两个子节点（左节点和右节点）

![image-20210412213725924](images\image-20210412213725924.png)



树的遍历：

![image-20210414210046563](images\image-20210414210046563.png)

先创建一个二叉树，输出当前节点（初始的时候是root节点）

前序遍历：

- 先输出当前节点
- 如果左子节点不为空，则递归继续前序遍历
- 如果右子节点不为空，则递归继续前序遍历



中序遍历：

- 如果当前节点的左子节点不为空，则递归中序遍历
- 输出当前节点
- 如果当前节点的右子节点不为空，则递归中序遍历



后序遍历：

- 如果当前节点的左子节点不为空，则递归后序遍历
- 如果当前节点的右子节点不为空，则递归后序遍历
- 输出当前节点

```
package com.atguigu.tree;

/**
 * 二叉树遍历
 * @author 25283
 * @version 1.0
 * @description: TODO
 * @date 2021/4/12 23:35
 */
public class BinaryTreeDemo {
    public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();

        Node root = new Node(1,"小明");
        Node node2 = new Node(2,"小云");
        Node node3 = new Node(3,"小彭");
        Node node4 = new Node(4,"小花");
        Node node5 = new Node(5,"关胜");

        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);
        tree.setRoot(root);

        System.out.println("前序遍历：");
        tree.preOrder();
        System.out.println("中序遍历：");
        tree.infixOrder();
        System.out.println("后序遍历：");
        tree.postOrder();
    }
}
// 创建一个二叉树
class BinaryTree{
    private Node root;// 根节点

    public void setRoot(Node root) {
        this.root = root;
    }

    // 前序遍历
    public void preOrder(){
        if (this.root != null){
            this.root.preOrder();
        }else {
            System.out.println("二叉树为空，无法遍历");
        }
    }
    // 中序遍历
    public void infixOrder(){
        if (this.root != null){
            this.root.indexOrder();
        }else {
            System.out.println("二叉树为空，无法遍历");
        }
    }
    // 后序遍历
    public void postOrder(){
        if (this.root != null){
            this.root.postOrder();
        }else {
            System.out.println("二叉树为空，无法遍历");
        }
    }
}
class Node{
    private int no;
    private String name;
    private Node left;// 左子节点
    private Node right;// 右子节点

    public Node(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setLeft(Node left) {
        this.left = left;
    }

    public void setRight(Node right) {
        this.right = right;
    }

    public int getNo() {
        return no;
    }

    public String getName() {
        return name;
    }

    public Node getLeft() {
        return left;
    }

    public Node getRight() {
        return right;
    }

    @Override
    public String toString() {
        return "Node{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }

    /**
     * 前序遍历
     */
    public void preOrder(){
        // 先输出根节点
        System.out.println(this);
        if (this.left != null){// 遍历左子节点
            this.left.preOrder();
        }
        if (this.right != null){// 遍历右子节点
            this.right.preOrder();
        }
    }

    /**
     * 中序遍历
     */
    public void indexOrder(){
        if (this.left != null){// 遍历左子节点
            this.left.indexOrder();
        }
        // 输出根节点
        System.out.println(this);
        if (this.right != null){// 遍历右子节点
            this.right.indexOrder();
        }
    }

    /**
     * 后序遍历
     */
    public void postOrder(){
        if (this.left != null){// 遍历左子节点
            this.left.postOrder();
        }
        if (this.right != null){// 遍历右子节点
            this.right.postOrder();
        }
        // 输出根节点
        System.out.println(this);
    }
}
```

![image-20210414215253545](images\image-20210414215253545.png)



#### 顺序存储二叉树

特点：

- 顺序二叉树通常只考虑完全二叉树
- 第n个元素的左子节点为2*n+1
- 第n个元素的右子节点为2*n+2
- 第n个元素的父节点为（n-1）/2
- n：表示二叉树中的第几个元素

![image-20210414222101264](images\image-20210414222101264.png)

![image-20210414222210088](images\image-20210414222210088.png)

堆排序中使用

```
package com.atguigu.tree;

/**
 * 顺序二叉树
 * @author 25283
 * @version 1.0
 * @description: TODO
 * @date 2021/4/14 22:32
 */
public class ArrBinaryTreeDemo {
    public static void main(String[] args) {
        int[] arr = {1,2,3,4,5,6,7};
        ArrBinaryTree tree = new ArrBinaryTree(arr);
        tree.infixOrder(0);
    }
}
class ArrBinaryTree{
    private int[] arr;

    public ArrBinaryTree(int[] arr) {
        this.arr = arr;
    }

    /**
     * 前序遍历
     * @param index 下标
     */
    public void preOrder(int index){
        if (arr == null || arr.length == 0){
            System.out.println("数组为空，无法遍历");
        }

        System.out.println(arr[index]);
        if ((index*2+1) < arr.length){// 左遍历
            preOrder(index*2+1);
        }
        if ((index*2+2) < arr.length){// 有遍历
            preOrder(index*2+2);
        }
    }

    /**
     * 中序遍历
     * @param index 下标
     */
    public void infixOrder(int index){
        if (arr == null || arr.length == 0){
            System.out.println("数组为空，无法遍历");
        }

        if ((index*2+1) < arr.length){// 左遍历
            infixOrder(index*2+1);
        }
        System.out.println(arr[index]);

        if ((index*2+2) < arr.length){// you遍历
            infixOrder(index*2+2);
        }
    }

    /**
     * hou序遍历
     * @param index 下标
     */
    public void postOrder(int index){
        if (arr == null || arr.length == 0){
            System.out.println("数组为空，无法遍历");
        }

        if ((index*2+1) < arr.length){// 左遍历
            infixOrder(index*2+1);
        }
        if ((index*2+2) < arr.length){// you遍历
            infixOrder(index*2+2);
        }
        System.out.println(arr[index]);
    }
}

```



#### AVL树

定义：

平衡二叉搜索树又被称为AVL树：它是一颗空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一颗平衡二叉树。

##### 平衡因子：

定义：某节点的左子树与右子树的高度差即为该节点的平衡因子，平衡二叉树上所有节点的平衡因子只可能是-1,0,或1.如果某一节点的平衡因子绝对值大于1这说明此树不是平衡二叉树。为了方便计算没一个节点的平衡因子我们可以为每个节点赋予height这一属性，表示此节点的高度。

```java
/**
 * AVLTree是BST，所以节点值必须是可比较的
 */
public class AvlTree<E extends Comparable<E>>{
	private class Node{
		public E e;
		public Node left;
		public Node right;
		public int height;

		public Node(E e){
			this.e = e;
			this.height = 1;
		}
	}

	private Node root;
	private int size;

	public AvlTree(){
		root=null;
		size=0;
	}

	//获取某一结点的高度
	private int getHeight(Node node){
		if(node==null){
			return 0;
		}
		return node.height;
	}
	
	public int getSize(){
		return size;
	}

	public boolean isEmpty(){
		return size == 0;
	}
	
	/**
	 * 获取节点的平衡因子
	 * @param node
	 * @return
	 */
	private int getBalanceFactor(Node node){
		if(node==null){
			return 0;
		}
		return getHeight(node.left)-getHeight(node.right);
	}
	
	//判断树是否为平衡二叉树
	public boolean isBalanced(){
		return isBalanced(root);
	}

	private boolean isBalanced(Node node){
		if(node==null){
			return true;
		}
		int balanceFactory = Math.abs(getBalanceFactor(node));// 计算平衡因子，从而判断是否满足AVL树
		if(balanceFactory>1){
			return false;
		}
		return isBalanced(node.left)&&isBalanced(node.right);
	}
}
————————————————
版权声明：本文为CSDN博主「带翅膀的猫」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_25343557/article/details/89110319
```

添加节点：每一次添加节点后都会导致平衡性被破坏

可以根据节点的不平衡性来判断该文件是左旋，还是右旋来保持平衡性

```
/**
 * 右旋转
 */
private Node rightRotate(Node y){
	Node x = y.left;
	Node t3 = x.right;
	x.right = y;
	y.left = t3;
	//更新height
	y.height = Math.max(getHeight(y.left),getHeight(y.right))+1;
	x.height = Math.max(getHeight(x.left),getHeight(x.right))+1;
	return x;
}
————————————————
版权声明：本文为CSDN博主「带翅膀的猫」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_25343557/article/details/89110319
```

![img](https://img-blog.csdnimg.cn/20190408214353545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MzQzNTU3,size_16,color_FFFFFF,t_70)

```
/**
 * 左旋转
 */
private Node leftRotate(Node y){
	Node x = y.right;
	Node t2 = x.left;
	x.left = y;
	y.right = t2;
	//更新height
	y.height = Math.max(getHeight(y.left),getHeight(y.right))+1;
	x.height = Math.max(getHeight(x.left),getHeight(x.right))+1;
	return x;
}
————————————————
版权声明：本文为CSDN博主「带翅膀的猫」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_25343557/article/details/89110319
```

![img](https://img-blog.csdnimg.cn/20190408220207905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MzQzNTU3,size_16,color_FFFFFF,t_70)





#### 线索二叉树

定义：

- n个节点的二叉链表中含有n+1公式2n-(n-1) = n+1个空指针区域，利用二叉链表中的空指针域，存放指向该节点在某种遍历次序下的前驱和后继节点的指针(这种附加的指针称为‘线索’)
- 这种加上了线索的二叉树被称为线索二叉树，又分为前序线索二叉树、中序线索二叉树、后序线索二叉树
- 一个节点的前一个节点，称为前驱节点
- 一个节点的后一个节点，称为后继节点

#### 红黑树

定义：全称为R-B Tree，全称是Red-Black Tree，它是一种特殊的二叉查找树。每个节点上都有存储位表示节点的颜色。

特点：

1. 每个节点或者是黑色，或者是红色
2. 跟节点是黑色
3. 每个叶子节点是黑色
4. 如果一个节点是红色的，则它的子节点必须是黑色
5. 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点

![img](https://images0.cnblogs.com/i/497634/201403/251730074203156.jpg)

红黑树的应用非常广泛，主要使用他来存储有序数据，他的时间复杂度是O(lgn),效率非常高。java集合中的TreeSet、TreeMap，以及linux虚拟内存的管理。都是通过红黑树去实现的。



红黑树基本操作删除和添加都会破坏红黑树中的节点，使他变成一个普通的树，因此需要左旋和右旋来保证树结构为红黑树

左旋

![img](https://images0.cnblogs.com/i/497634/201403/251733282013849.jpg)

![img](https://images0.cnblogs.com/i/497634/201403/251734577643655.jpg)



右旋：

![img](https://images0.cnblogs.com/i/497634/201403/251735527958942.jpg)

![img](https://images0.cnblogs.com/i/497634/201403/251737465769614.jpg)



#### 伸展树





### 哈希表（散列）

![image-20210407000008409](images\image-20210407000008409.png)

![image-20210407000444108](images\image-20210407000444108.png)

数组+链表

数组+二叉树

例子：使用hash表来管理雇员信息（不可借助数据库或现成的缓存组件）

![image-20210407213516976](images\image-20210407213516976.png)

```
package com.atguigu.hashtab;

import java.util.Scanner;

/**
 * @ProjectName: DataStructures
 * @Package: com.atguigu.hashtab
 * @ClassName: HashDemo
 * @author: mengjianglong
 * @description: 散列实现缓存
 * @date: 2021/4/7 21:44
 * @version: 1.0
 */
public class HashDemo {
    public static void main(String[] args) {
        HashTab hashTab = new HashTab(7);
        Scanner sc = new Scanner(System.in);
        String key = "";
        while (true){
            System.out.println("add: 添加");
            System.out.println("list: 遍历");
            System.out.println("find: 查询");
            System.out.println("del: 删除");
            System.out.println("exit: 退出");
            key = sc.next();

            switch (key){
                case "add":
                    System.out.println("请输入雇员id：");
                    int id = sc.nextInt();
                    System.out.println("输入名字：");
                    String name = sc.next();
                    Emp emp = new Emp(id,name);
                    hashTab.add(emp);
                    break;
                case "list":
                    hashTab.list();
                    break;
                case "find":
                    System.out.println("请输入要查询的雇员id：");
                    id = sc.nextInt();
                    hashTab.find(id);
                    break;
                case "del":
                    System.out.println("请输入要删除的雇员id：");
                    id = sc.nextInt();
                    hashTab.del(id);
                    break;
                case "exit":
                    sc.close();
                    System.exit(0);
                    break;
                default:
                    break;
            }
        }
    }
}

class HashTab {
    private EmpLinkedList[] empLinkedLists;
    private static int size;// 链表的长度

    public HashTab(int size) {
        this.empLinkedLists = new EmpLinkedList[size];
        this.size = size;
        for (int i = 0; i < size; i++) {// 初始化每一个链表
            empLinkedLists[i] = new EmpLinkedList();
        }
    }

    // 添加
    public void add(Emp emp) {
        int empLinkedListNo = empId(emp.id);
        empLinkedLists[empLinkedListNo].add(emp);
    }

    public static int empId(int id) {// 计算属于那个链表
        return id % size;
    }

    // 遍历
    public void list(){
        for (int i = 0; i < size; i++) {
            empLinkedLists[i].list(i);
        }
    }

    // 查询
    public void find(int id){
        int empLinkedListNo = empId(id);
        Emp emp = empLinkedLists[empLinkedListNo].find(id);
        if (emp !=null){
            System.out.println("找到了id = "+id);
        }else {
            System.out.println("未找到");
        }
    }

    // 删除
    public void del(int id){
        int empLinkedListNo = empId(id);
        empLinkedLists[empLinkedListNo].del(id);
    }
}

class Emp { // 储存的实体对象
    public int id;
    public String name;
    public Emp next; // 指向下一个emp

    public Emp(int id, String name) {
        this.id = id;
        this.name = name;
    }
}

class EmpLinkedList {
    // 定义头，指向第一个emp
    public Emp head;

    /**
     * 插入时，假设id由大到小，因此直接将其插入到最后面
     *
     * @param emp
     */
    public void add(Emp emp) {
        if (head == null) {
            head = emp;
            return;
        }

        // 如果不是第一个雇员吧
        Emp curEmp = head;
        while (true) {
            if (curEmp.next == null) {//找到退出
                break;
            }
            curEmp = curEmp.next;// 后移
        }
        curEmp.next = emp;
    }

    public void list(int no) {
        if (head == null) {
            System.out.println("第"+(no+1)+"链表为null");
            return;
        }

        System.out.println("第"+(no+1)+"链表为:");
        Emp curEmp = head;
        while (true) {
            System.out.println("id = " + curEmp.id + ",name = " + curEmp.name);
            if (curEmp.next == null) {
                break;
            }
            curEmp = curEmp.next;
        }
    }

    /**
     * 查询
     * @param id
     * @return
     */
    public Emp find(int id){
        if (head == null){
            System.out.println("链表为null");
            return null;
        }

        Emp curEmp = head;
        while (true){
            if (curEmp.id == id){
                break;
            }

            if (curEmp.next == null){
                curEmp = null;
                break;
            }
            curEmp = curEmp.next;
        }
        return curEmp;
    }

    /**
     * 删除
     * @param id
     */
    public void del(int id){
        if (head == null){
            System.out.println("链表为null，无法删除");
            return;
        }

        Emp curEmp = head;
        boolean flag = false;// 是否找到删除节点
        while (true){
            if (curEmp.id == id){// 找到节点
                flag = true;
                break;
            }
            if (curEmp.next == null){// 没找到节点
                break;
            }
            curEmp = curEmp.next;
        }

        if (flag){
            curEmp.next = curEmp.next.next;
        }else {
            System.out.println("节点不存在...");
        }
    }
}
```



### 散列模型

散列函数

线性探测法

平方探测法

双散列

#### 散列函数构造方法

##### 直接定址法

取关键字或关键字的某个线性函数值为哈希地址：H(key) = key 或 H(key) = a·key + b
其中a和b为常数，这种哈希函数叫做自身函数。

注意：由于直接定址所得地址集合和关键字集合的大小相同。因此，对于不同的关键字不会发生冲突。但实际中能使用这种哈希函数的情况很少。


##### 相乘取整法

首先用关键字key乘上某个常数A(0 < A < 1)，并抽取出key.A的小数部分；然后用m乘以该小数后取整。

注意：该方法最大的优点是m的选取比除余法要求更低。比如，完全可选择它是2的整数次幂。虽然该方法对任何A的值都适用，但对某些值效果会更好。Knuth建议选取 0.61803……。


##### 平方取中法

取关键字平方后的中间几位为哈希地址。

通过平方扩大差别，另外中间几位与乘数的每一位相关，由此产生的散列地址较为均匀。这是一种较常用的构造哈希函数的方法。

将一组关键字(0100，0110，1010，1001，0111)
平方后得(0010000，0012100，1020100，1002001，0012321)
若取表长为1000，则可取中间的三位数作为散列地址集：(100，121，201，020，123)。

##### 折叠法

##### 除留余数法

取关键字被数p除后所得余数为哈希地址：H(key) = key MOD p (p ≤ m)。

注意：这是一种最简单，也最常用的构造哈希函数的方法。它不仅可以对关键字直接取模(MOD)，也可在折迭、平方取中等运算之后取模。值得注意的是，在使用除留余数法时，对p的选择很重要。一般情况下可以选p为质数或不包含小于20的质因素的合数。


##### 随机数法

选择一个随机函数，取关键字的随机函数值为它的哈希地址，即 `H(key) = random (key)`，其中random为随机函数。通常，当关键字长度不等时采用此法构造哈希函数较恰当。

#### 处理冲突的方法

##### 线性探测再散列

##### 平方探测再散列

### 堆模型

#### 左式堆

#### 斜堆





## 第三节：算法实战

![image-20210228151357159](images\image-20210228151357159.png)

![image-20210228151445740](images\image-20210228151445740.png)

![image-20210228151539300](images\image-20210228151539300.png)





### 排序算法

![image-20210329213536131](images\image-20210329213536131.png)



#### 插入排序

定义：插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。

![image-20210331220724869](images\image-20210331220724869.png)

```java
package com.atguigu.sort;

import java.util.Arrays;

/**
 * 插入排序
 */
public class InsertSort {
    public static void main(String[] args) {
        int[] arr = {101,34,120,1};
        insertSort(arr);
    }

    /**
     * 插入排序
     * @param arr
     */
    public static void insertSort(int[] arr){
        for (int i = 1;i < arr.length;i++) {
            // 固定第一位的数，使之作为有序数。然后取出其后一个值进行插入
            int insertArr = arr[i];
            int insertIndex = i-1;

            // 寻找插入的位置小-大（小的后挪，大的往前让位）
        /*
        insertIndex >= 0防止数组下标越界
        insertArr < arr[insertIndex]判断插入值与有序数的大小
         */
            while (insertIndex >= 0 && insertArr < arr[insertIndex]) {
                arr[insertIndex + 1] = arr[insertIndex];// 有序数大的话就将自己向后挪一位进行保存
                insertIndex--;
            }

            if (insertIndex+1 != i){
                arr[insertIndex + 1] = insertArr;// 将最小的数放置在原来有序数的位置处，因为前边要多执行一次判断，因此insertIndex + 1
            }

            System.out.println("第"+i+"轮插入：");
            System.out.println(Arrays.toString(arr));
        }
    }
}

```



#### 希尔排序

![image-20210331230543373](images\image-20210331230543373.png)

![image-20210331230955530](images\image-20210331230955530.png)

```
package com.atguigu.sort;

import java.util.Arrays;

/**
 * @ProjectName: 希尔排序
 * @Package: com.atguigu.sort
 * @ClassName: ShellSort
 * @author: mengjianglong
 * @description:
 * @date: 2021/3/31 23:11
 * @version: 1.0
 */
public class ShellSort {
    public static void main(String[] args) {
        int[] arr = {8, 9, 1, 7, 2, 3, 5, 4, 6, 0};
        //shellSort(arr);
        shellMoveSort(arr);
    }

    /**
     * 交换法（慢）
     *
     * @param arr
     */
    public static void shellSort(int[] arr) {
        int temp = 0;
        // 分组规律
        for (int s = arr.length / 2; s > 0; s /= 2) {
            // 将数据分成s组
            for (int i = s; i < arr.length; i++) {
                // 遍历各组中的元素，（每组2个元素）
                for (int j = i - s; j >= 0; j -= s) {
                    // 判断每组中元素的大小并交换
                    if (arr[j] > arr[j + s]) {
                        temp = arr[j + s];
                        arr[j + s] = arr[j];
                        arr[j] = temp;
                    }
                }
            }
            System.out.println("希尔排序：" + Arrays.toString(arr));
        }
    }

    /**
     * 移动法（快）
     *
     * @param arr
     */
    public static void shellMoveSort(int[] arr) {
        for (int s = arr.length / 2; s > 0; s /= 2) {
            for (int i = s; i < arr.length; i++) {
                int j = i;
                int temp = arr[j]; // 固定每一组的一个值作为有序数
                if (arr[j] < arr[j - s]) {// 有序数小于了同组的另一个数时，需要移动
                    while (j - s >= 0 && temp < arr[j - s]) {
                        // 移动
                        arr[j] = arr[j - s];
                        j -= s;
                    }
                    arr[j] = temp;
                }
            }
            System.out.println("希尔排序：" + Arrays.toString(arr));
        }
    }
}

```



#### 堆排序

#### 归并排序

#### 快速排序

![image-20210331235917966](images\image-20210331235917966.png)

![image-20210401213514563](images\image-20210401213514563.png)

```
package com.atguigu.sort;

import java.util.Arrays;

/**
 * @ProjectName: DataStructures
 * @Package: com.atguigu.sort
 * @ClassName: QuickSort
 * @author: mengjianglong
 * @description: 快速排序
 * @date: 2021/4/6 21:24
 * @version: 1.0
 */
public class QuickSort {
    public static void main(String[] args) {
        int[] arr = {-9, 78, 0, 23, -567, 70};
        quickSort(arr,0, arr.length-1);
        System.out.println(Arrays.toString(arr));
    }

    public static void quickSort(int[] arr, int left, int right) {
        int l = left;
        int r = right;
        int pivot = arr[(left + right) / 2];// 中间值

        int temp = 0;// 临时变量
        while (l < r) {
            // 在pivot左边一直找，找到大于pivot的值
            while (arr[l] < pivot) {
                l += 1;
            }

            while (arr[r] > pivot) {
                r -= 1;
            }

            if (l >= r) {
                break;
            }

            // 交换
            temp = arr[l];
            arr[l] = arr[r];
            arr[r] = temp;

            // 如果交换完成发现arr[l] = pivot值，相等--前移
            if (arr[l] == pivot) {
                r -= 1;
            }

            // 如果交换完成发现arr[r] = pivot值，相等--前移
            if (arr[r] == pivot) {
                l += 1;
            }
        }

        // 如果l == r,必须l++，r--，防止栈溢出
        if (l==r){
            l+=1;
            r-=1;
        }

        // 向左递归
        if (left<r){
            quickSort(arr,left,r);
        }

        // 向右递归
        if (right>l){
            quickSort(arr,l,right);
        }
    }
}
```



#### 选择排序

![image-20210329225525965](images\image-20210329225525965.png)

![image-20210329230546058](images\image-20210329230546058.png)

```
package com.atguigu.sort;

import java.util.Arrays;

/**
 * 选择排序
 */
public class SelectSort {
    public static void main(String[] args) {
        int[] arr = {103,52,2,8};
        selectSort(arr);
    }

    // 定义选择排序方法
    public static void selectSort(int[] arr){
        /**
         * 假设最小的值就在下表为0的位置
         */
        for (int i = 0;i<arr.length-1;i++) {
            int minSize = i;
            int min = arr[i];// 假设最小值

            // 第一轮
            for (int j = i + 1; j < arr.length; j++) {
                if (min > arr[j]) {
                    minSize = j;//置换下标
                    min = arr[j];// 置换最小值
                }
            }

            if (minSize!=i) {
                arr[minSize] = arr[i];// 将原arr[0]位置的数据放置到arr[minSize]
                arr[i] = min;// 将真正的最小值放置首位
            }

            System.out.println("第"+i+"躺排序");
            System.out.println(Arrays.toString(arr));
        }
    }
}

```



#### 冒泡排序

![image-20210329222923252](images\image-20210329222923252.png)

```java
package com.atguigu.sort;

import java.util.Arrays;

/**
 * 冒泡排序
 */
public class BubbleSort {
    public static void main(String[] args) {
        int[] arr = {3, 9, -1, -2, 10};

        boolean blag = false;// 表示，是否进行过交换
        int temp = 0;// 中间变量
        for (int j = 0; j < arr.length - 1; j++) {
            for (int i = 0; i < arr.length - 1 - j; i++) {
                if (arr[i] > arr[i + 1]) {
                    blag = true;
                    temp = arr[i];
                    arr[i] = arr[i + 1];
                    arr[i + 1] = temp;
                }
            }
            System.out.println("第"+j+"躺排序");
            System.out.println(Arrays.toString(arr));
            if (!blag){
                break;
            }else {
                blag = false;// chongzhi2，进行下次循环
            }
        }
    }
}

```



#### 基数排序



### 实战算法

#### 查找算法

##### 顺序（线性）查找

思路：实际就是普通的线性查找，逐一比对。有相同值时返回其下标

```
package com.atguigu.search;

import java.util.ArrayList;
import java.util.List;

/**
 * @ProjectName: DataStructures
 * @Package: com.atguigu.search
 * @ClassName: SeqSearch
 * @author: mengjianglong
 * @description: 线性查找
 * @date: 2021/4/6 21:59
 * @version: 1.0
 */
public class SeqSearch {
    public static void main(String[] args) {
        int[] arr = {-1,88,5,4,11,0,11};

        List<Integer> list = seq(arr,11);

        for (int i:
             list) {
            System.out.print(i+"   ");
        }
    }
    public static List<Integer> seq(int[] arr,int value){
        List<Integer> list = new ArrayList<>();
        for (int a = 0; a < arr.length; a++) {
            if (arr[a] == value){
                list.add(a);
            }
        }
        return list;
    }
}
```



##### 二分查找/折半查找

思路：前提，执行二分查找时必须是有序的数组或集合。

首先我们需要确定该数组中间的下标 mid = （left+right）/2

然后判断我们查找的值和该数组中间值大小：若果大于中间值则需要右递归查找，反之则需要左递归查找。

递归结束：在找到该值时就结束，当left>right时也需要结束递归

```
package com.atguigu.search;

import java.util.ArrayList;
import java.util.List;

/**
 * @ProjectName: DataStructures
 * @Package: com.atguigu.search
 * @ClassName: BinarySearch
 * @author: mengjianglong
 * @description: 二分法查找
 * @date: 2021/4/6 22:39
 * @version: 1.0
 */
public class BinarySearch {
    public static void main(String[] args) {
        int[] arr = {-1,1,3,45,88,856,856,856,1458};
        List<Integer> list = binary2(arr,0,arr.length-1,856);
        System.out.println(list);
    }
    public static int binary(int[] arr,int left ,int right,int findVal){
        int mid = (left+right)/2;
        int midVal = arr[mid];

        if (left>right){// 查找不到
            return -1;
        }

        if (findVal > midVal){// 向右递归
            return binary(arr,mid+1,right,findVal);
        }else if(findVal < midVal){// 向左递归
            return binary(arr,left,mid-1,findVal);
        }else {
            return mid;
        }
    }

    /**
     * 出现重复值时
     * @param arr
     * @param left
     * @param right
     * @param findVal
     * @return
     */
    public static List<Integer> binary2(int[] arr,int left ,int right,int findVal){
        int mid = (left+right)/2;
        int midVal = arr[mid];

        if (left>right){// 查找不到
            return new ArrayList<>();
        }

        if (findVal > midVal){// 向右递归
            return binary2(arr,mid+1,right,findVal);
        }else if(findVal < midVal){// 向左递归
            return binary2(arr,left,mid-1,findVal);
        }else {
            List<Integer> list = new ArrayList<>();

            int temp = mid-1;
            while (true){// 向左扫
                if (temp < 0 || arr[temp] != findVal){
                    break;
                }

                // 如果不满足退出条件时就将该下标加入集合中，，索引位置继续向左移动
                list.add(temp);
                temp -= 1;
            }

            list.add(mid);
            temp = mid + 1;
            while (true){// 向右扫
                if (temp > arr.length-1 || arr[temp] != findVal){
                    break;
                }

                // 如果不满足退出条件时就将该下标加入集合中，，索引位置继续向右移动
                list.add(temp);
                temp += 1;
            }
            return list;
        }
    }
}
```



##### 插值查找

思路：根据前面的二分查找，将mid的计算方式进行优化，使其减少相应的查找次数。(数据量大，且数据分布比较均匀的数组已排序)

int mid = left+(right-left)*(findVal-arr[left])/(arr[right]-arr[left])

```
package com.atguigu.search;

/**
 * @ProjectName: DataStructures
 * @Package: com.atguigu.search
 * @ClassName: InsertValueSearch
 * @author: mengjianglong
 * @description: 插值查找
 * @date: 2021/4/6 23:22
 * @version: 1.0
 */
public class InsertValueSearch {
    public static void main(String[] args) {
        int[] arr  = new int[100];
        for (int i = 0; i < arr.length-1; i++) {
            arr[i] = i+1;
        }
        search1(arr,0,arr.length-1,100);
    }
    public static int search1(int[] arr,int left,int right,int findVal){
        // 当查找的值不存在时
        if (left > right || findVal < arr[0] || findVal > arr[arr.length-1]){
            return -1;
        }

        // 计算mid，自适应
        int mid = left + (right - left)*(findVal - arr[left])/(arr[right] - arr[left]);
        int midVal = arr[mid];

        if (findVal > midVal){// 向右递归
            return search1(arr,mid + 1,right,findVal);
        }else if (findVal < midVal) {// 向左递归
            return search1(arr,left,mid - 1,findVal);
        }else {
            return mid;
        }
    }
}
```



##### 斐波那契查找

思路：数据必须是有序的

![image-20210406233528722](images\image-20210406233528722.png)

![image-20210406233923037](images\image-20210406233923037.png)

```
package com.atguigu.search;

import java.util.Arrays;

/**
 * @ProjectName: DataStructures
 * @Package: com.atguigu.search
 * @ClassName: FibonacciSearch
 * @author: mengjianglong
 * @description: 斐波那契查找
 * @date: 2021/4/7 20:50
 * @version: 1.0
 */
public class FibonacciSearch {
    public static int maxSize = 20;
    public static void main(String[] args) {
        int[] arr = {1,8,10,89,1000,1234};
        System.out.println(fibSearch(arr,1234));
    }

    /**
     * 非递归得到一个斐波那契数列,mid = low+f(k-1)-1
     * @return
     */
    public static int[] fib(){
        int[] f = new int[maxSize];
        f[0] = 1;
        f[1] = 1;

        for (int i = 2; i < maxSize; i++) {
            f[i] = f[i-1] + f[i-2];
        }
        return f;
    }

    /**
     *
     * @param arr 数组
     * @param key 要查找的值
     * @return
     */
    public static int fibSearch(int[] arr,int key){
        int low = 0;
        int heigh = arr.length-1;
        int k = 0;// 斐波那契分割数值对应下标
        int mid = 0;

        int[] f = fib();// 获取到斐波那契数列
        while (heigh > f[k]-1){// 找到斐波那契下标
            k++;
        }

        // 因为f[k]的值可能大于arr的长度因此需要构造一个新的数组，不足部分使用0填充
        int[] temp = Arrays.copyOf(arr,f[k]);

        // 将填充的0改变为arr的最后一个元素
        for (int i = heigh+1; i < temp.length; i++) {
            temp[i] = arr[heigh];
        }

        // 使用循环找到key
        while(low <= heigh){
            mid = low + f[k-1] - 1;
            if (key < temp[mid]){// 向左查找
                heigh = mid - 1;
                // f[k] = f[k-1] + f[k-2]
                // 以为前面有 f[k-1]个元素，所以可以继续拆分f[k-1] = f[k-2] + f[k-3]，即在f[k-1]前面继续查找k--
                k--;
            }else  if (key > temp[mid]){// 向右查找
                low = mid + 1;
                // f[k] = f[k-1] + f[k-2]
                // 以为后面有 f[k-2]，所以可以继续拆分f[k-1] = f[k-3] + f[k-4]，即在f[k-2]前面继续查找k-=2
                k-=2;
            }else {
                if (mid < heigh){
                    return mid;
                }else {
                    return heigh;
                }
            }
        }
        return -1;
    }
}
```



#### 贪婪算法

##### 哈夫曼编码

##### 近似装箱问题



#### 分治算法

##### 分治算法的运行时间

##### 最近点问题

##### 选择问题



#### 动态规划

##### 用一个表代替递归

##### 矩阵乘法的顺序安排

##### 最优二叉查找树

##### 所有点对最短路径



#### 随机化算法

##### 随机数发生器

##### 跳跃表

##### 素性测试

 