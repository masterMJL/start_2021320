**世上无难事，只怕有心人！！！**

# 第十一部分：分布式消息中间件原理

## MQ基础概念模型

### 同步与异步

### 流量削峰

### 扩展性/解耦

### 缓冲/可恢复性

### 生产者与消费者



## MQ常见解决方案



### MQ如何避免消息堆积

#### 提高消费者速率（集群）

#### 消费者批量获取消息



### MQ如何避免消费者重复消费（幂等问题）

#### 全局id+业务场景保证唯一性



### MQ如何保证消息不丢失

#### 消息确认机制

#### 持久化

#### 消息ack



### MQ如何保证消息顺序一致性

#### 绑定同一个消费者和队列

### MQ推与拉取架构模型



### 生产者如何获取消费结果

#### 异步返回一个全局id，前端使用ajax定时主动查询



## 主流MQ框架



### Rabbitmq



#### 架构思想

##### Rabbitmq管理平台中心



##### Virtual Hosts

###### 分团队开发路径存放消息队列



##### Exchange

###### 路由分发消息

##### 路由key



#### RabitMQ队列模型

##### simple模式

##### work 模式

##### 广播模式---fanout

##### 路由模式--direct

##### 主题模式--topic



#### RabitMQ四种交换机类型

##### Direct exchange（直连交换机）

##### Fanout exchange（扇型交换机）

##### Topic exchange（主题交换机）

##### Headers exchange（头交换机）



#### RabbitMQ常见面试题



##### RabbitMQ如何保证消息不丢失



###### 生产者



确保生产者投递消息到MQ服务器端成功

Ack 消息确认机制(Confirms)

同步或者异步的形式

事务消息



###### 消费者



消费手动签收模式

自动签收（不推荐）

手动签收（推荐）

###### MQ服务器端消息持久化



##### RabbitMQ死信队列

###### 消息投递到MQ中存放 消息已经过期

###### 队列容器已经满了

###### 消费者消费多次消息失败，就会转移存放到死信队列中



##### RabbitMQ消息自动重试机制



###### 重试多次还是失败，如何处理

转移到死信队列中

记录到日志表中定时补偿或者人工补偿



###### 如何避免消费者幂等问题呢？

全局id+业务场景保证唯一性



### Kafka



#### Kafka核心架构设计模型

##### Broker（MQ服务器端）

##### Topic（主题根据业务分类）

##### Partiiton（分区存储消息）

##### Producer（生产者）

##### Consumer（消费者）

##### Consumer Group（消费者组）

##### Replica（副本机制）

##### Offset（消费记录）



#### 为什么kafka能够支撑高并发



##### 存储结构层面

###### 消息会实现压缩，减少带宽传输



###### kafka分区partition存储结构模型

.log存储消息文件

.index存储消息的索引

.timeIndex，时间索引文件

###### 分段存储日志（segment file）



###### 使用稀疏索引查找消息物理位置（不会为每个消息创建索引）

好处可以节约空间

###### 消息存储之后，消费成功不会立即删除 根据offset获取消息（需要考虑配置日志清理策略）



##### java应用层面



###### 生产者

生产者批量投递消息（缓冲池设计）



###### 消费者

消费者批量获取消息（多个offset）

每个分区对应一个消费者（可扩展性）



##### linux内核层面

###### 采用顺序读写方式



###### 使用零拷贝机制

sendfile+mmap 用户态与内核态映射

不需要cpu拷贝数据

减少用户态与内核态切换次数



###### 利用Page Cache缓存提高读写

需要考虑刷盘问题



#### Kafka如何保证可靠消息



##### 副本机制（Replication）



###### ISR副本可靠机制



分区中副本选举

HW高水位线 消费者能够消费最大offset

LEO队列中最大的offset值



##### 生产者投递消息ack

###### 0表示生产者不等待（可能会丢失消息）

###### 1表示生产者等待，Leader刷盘（建议默认配置）

###### -1表示生产者需要等待所有节点同步完成



##### Kafka选举原理控制器原理

###### 依托于Zookeeper临时节点实现选举

##### 消费者手动提交offset



#### Kafka如何查找指定offset的Message的

##### 1.根据offset查找Segment分段文件（二分查找）

##### 2.访问到index文件（稀疏索引），查找到对应物理存放位置



##### 3.根据物理访问位置，访问log日志查找物理对应消息



###### 查找到该消息索引值

直接返回物理消息(时间复杂度o(1))



###### 没有查找到该消息索引值

依次顺序查找(时间复杂度o(N))



#### Kafka的性能优化



##### 生产者

###### 生产者内存缓冲的大小



###### 重试策略“retries”和“retries.backoff.ms”

该参数设置定重试的次数、间隔时间

###### 确认机制：acks 建议设置为1比较平衡



##### 消费者

###### 消费者分区的个数

###### 消费者根据多个offset批量获取消息

###### 消费者开启手动提交offset



##### Broker（MQ服务器端）

###### 日志保留策略配置

###### log数据文件刷盘策略

###### replica复制配置

###### 网络和IO线程配置优化